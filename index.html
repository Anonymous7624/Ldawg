<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Prevent Tab Switch Glitch -->
  <script>
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === 'hidden') {
        localStorage.removeItem("nickname");
        window.location.href = "join.html";
      }
    });
  </script>
  <!-- Redirect to join.html if no nickname stored -->
  <script>
    if (!localStorage.getItem('nickname')) {
      window.location.href = "join.html";
    }
  </script>
  <meta charset="UTF-8">
  <title>3D Multiplayer Tank Game - Final Polish v1.1.2</title>
  <!-- Favicon Links -->
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <style>
    body { margin: 0; overflow: hidden; }
    /* Health Bar */
    #healthBarContainer {
      position: fixed; bottom: 220px; left: 50%;
      transform: translateX(-50%); width: 200px; height: 20px;
      background-color: #555; border: 2px solid #333;
      border-radius: 5px; z-index: 130;
    }
    #healthBar { width: 100%; height: 100%; background-color: green; border-radius: 3px; }
    /* Chat Input */
    #chatInput {
      position: fixed; bottom: 210px; left: 50%;
      transform: translateX(-50%); display: none;
      padding: 8px; font-size: 16px; z-index: 110;
    }
    /* Kill Feed */
    #killFeed { position: fixed; top: 10px; right: 10px; color: white; font-family: sans-serif; z-index: 110; }
    /* Minimap */
    #minimap { position: fixed; top: 10px; left: 10px; border: 2px solid #fff; background: rgba(0,0,0,0.5); z-index: 110; }
    /* Global Chat Log */
    #globalChatLog {
      position: fixed; bottom: 0; left: 0; width: 100%;
      max-height: 200px; overflow-y: auto;
      background: rgba(0,0,0,0.7); color: #fff;
      font-family: Arial, sans-serif; font-size: 14px;
      padding: 10px; box-sizing: border-box; z-index: 105;
    }
    /* Missile Selector Menu */
    #missileMenu {
      position: fixed; top: 50px; left: 50%;
      transform: translateX(-50%); background: rgba(0,0,0,0.7);
      color: #fff; padding: 10px; border-radius: 5px;
      z-index: 120; font-family: Arial, sans-serif;
    }
    #missileMenu label, #missileMenu select { font-size: 16px; }
    /* Info Bar */
    #infoBar {
      position: fixed; top: 10px; right: 10px;
      background: rgba(0, 0, 0, 0.6); color: #ffdd00;
      padding: 10px; border-radius: 5px;
      font-family: Arial, sans-serif; font-size: 14px;
      cursor: move; z-index: 200;
    }
    /* Damage Overlay */
    #damageOverlay {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255, 0, 0, 0);
      pointer-events: none; z-index: 300;
      transition: background 0.2s ease-out;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- UI Elements -->
  <div id="healthBarContainer"><div id="healthBar"></div></div>
  <div id="missileMenu">
    <label for="missileTypeSelect">Missile Type:</label>
    <select id="missileTypeSelect">
      <option value="bullet">Fast Bullet</option>
      <option value="splash">Splash Damage</option>
      <option value="rocket">Heavy Rocket</option>
    </select>
  </div>
  <input type="text" id="chatInput" placeholder="Type a message and hit Enter">
  <div id="killFeed"></div>
  <canvas id="minimap" width="200" height="200"></canvas>
  <div id="globalChatLog"></div>
  <!-- Info Bar with Version and Weather -->
  <div id="infoBar">
    <strong>Controls:</strong> WASD, SPACE/Left-Click (Shoot), 1-3 (Camera), SHIFT, T (Chat), I (Toggle Info)<br>
    <strong>Connection:</strong> <span id="latencyDisplay">--</span> ms<br>
    <strong>Players:</strong> --<br>
    <strong>Weather:</strong> --<br>
    <strong>Version:</strong> 1.1.2
  </div>
  <!-- Damage Overlay -->
  <div id="damageOverlay"></div>

  <!-- All client-side code in a single ES module script -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';

    // Declare missing variables
    let faster = false;
    let currentWeather = "sunny";
    let latency = 0;

    // Global Variables
    let currentMap = "desert";
    let prevTankPosition = new THREE.Vector3();
    let clock, scene, camera, renderer, localTank;
    let remoteTanks = {}, missiles = [], trailParticles = [];
    let ws;
    let cameraShakeTime = 0, cameraShakeIntensity = 0.5;
    let controls = { forward: false, backward: false, left: false, right: false, shoot: false };
    let playerData = {
      id: Math.floor(Math.random() * 1000000).toString(),
      nickname: localStorage.getItem('nickname') || 'Player' + Math.floor(Math.random() * 1000),
      color: '#' + (Math.floor(Math.random()*16777215) & 0x00FF00).toString(16)
    };

    // Throttle update: send update 15 times per second.
    let lastUpdateTime = 0;
    const updateInterval = 1000 / 15;

    // Dummy implementations for missing functions (replace with actual code if available)
    function updateHealthBar() { /* Update health UI */ }
    function updateInfoBar() { /* Update additional info */ }
    function updateRain(delta) { /* Update rain effects */ }
    function updateSnow(delta) { /* Update snow effects */ }
    function updateStorm(delta) { /* Update storm effects */ }

    // Define ImprovedNoise for terrain generation
    var ImprovedNoise = function () {
      var p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,
        140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,
        247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,
        57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,
        74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,
        60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,
        65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,
        196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,
        217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,
        206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,
        152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,
        253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,
        235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,
        176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,
        24,72,243,141,128,195,78,66,215,61,156,180];
      for (var i = 0; i < 256; i++) { p[256 + i] = p[i]; }
      function fade(t) { return t*t*t*(t*(t*6-15)+10); }
      function lerp(t, a, b) { return a + t*(b-a); }
      function grad(hash, x, y, z) {
          var h = hash & 15;
          var u = h < 8 ? x : y,
              v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
      }
      this.noise = function(x, y, z) {
          var floorX = Math.floor(x), floorY = Math.floor(y), floorZ = Math.floor(z);
          var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;
          x -= floorX; y -= floorY; z -= floorZ;
          var u = fade(x), v = fade(y), w = fade(z);
          var A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z;
          var B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;
          return lerp(w,
              lerp(v,
                  lerp(u, grad(p[AA], x, y, z), grad(p[BA], x-1, y, z)),
                  lerp(u, grad(p[AB], x, y-1, z), grad(p[BB], x-1, y-1, z))
              ),
              lerp(v,
                  lerp(u, grad(p[AA+1], x, y, z-1), grad(p[BA+1], x-1, y, z-1)),
                  lerp(u, grad(p[AB+1], x, y-1, z-1), grad(p[BB+1], x-1, y-1, z-1))
              )
          );
      };
    };

    // High-res skybox textures for weather
    const skyboxTextures = {
      sunny: [
        "https://threejs.org/examples/textures/cube/skyboxsun25deg/posx.jpg",
        "https://threejs.org/examples/textures/cube/skyboxsun25deg/negx.jpg",
        "https://threejs.org/examples/textures/cube/skyboxsun25deg/posy.jpg",
        "https://threejs.org/examples/textures/cube/skyboxsun25deg/negy.jpg",
        "https://threejs.org/examples/textures/cube/skyboxsun25deg/posz.jpg",
        "https://threejs.org/examples/textures/cube/skyboxsun25deg/negz.jpg"
      ],
      rain: [
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/posx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/negx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/posy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/negy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/posz.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/negz.jpg"
      ],
      snow: [
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park2/posx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park2/negx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park2/posy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park2/negy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park2/posz.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park2/negz.jpg"
      ],
      cloudy: [
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Bridge2/posx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Bridge2/negx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Bridge2/posy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Bridge2/negy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Bridge2/posz.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Bridge2/negz.jpg"
      ],
      storm: [
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/posx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/negx.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/posy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/negy.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/posz.jpg",
        "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/cube/Park3Med/negz.jpg"
      ]
    };

    // Missile types for shooting
    const missileTypes = {
      bullet: {
        speed: 100,
        explosionRadius: 5,
        geometry: () => new THREE.SphereGeometry(0.2, 8, 8),
        material: new THREE.MeshStandardMaterial({ color: 0xff0000 })
      },
      splash: {
        speed: 80,
        explosionRadius: 8,
        geometry: () => new THREE.SphereGeometry(0.3, 8, 8),
        material: new THREE.MeshStandardMaterial({ color: 0x00ff00 })
      },
      rocket: {
        speed: 60,
        explosionRadius: 10,
        geometry: () => new THREE.CylinderGeometry(0.2, 0.2, 2, 8),
        material: new THREE.MeshStandardMaterial({ color: 0x0000ff })
      }
    };

    // Cloud layer functions
    let cloudMesh = null;
    function startClouds() {
      if (cloudMesh) return;
      const loader = new THREE.TextureLoader();
      loader.load('https://threejs.org/examples/textures/cloud.png', function(texture){
        let geometry = new THREE.SphereGeometry(1200, 32, 32);
        let material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          opacity: 0.5,
          side: THREE.BackSide
        });
        cloudMesh = new THREE.Mesh(geometry, material);
        scene.add(cloudMesh);
      });
    }
    function removeClouds() {
      if (cloudMesh) { scene.remove(cloudMesh); cloudMesh = null; }
    }

    // Dust particles for desert atmosphere
    let dustParticles;
    function startDust() {
      let dustCount = 200;
      let dustGeometry = new THREE.BufferGeometry();
      let dustPositions = new Float32Array(dustCount * 3);
      for (let i = 0; i < dustCount; i++) {
        dustPositions[i * 3] = Math.random() * 1000 - 500;
        dustPositions[i * 3 + 1] = Math.random() * 100 + 50;
        dustPositions[i * 3 + 2] = Math.random() * 1000 - 500;
      }
      dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
      let dustMaterial = new THREE.PointsMaterial({ color: 0xffccaa, size: 1, transparent: true, opacity: 0.3 });
      dustParticles = new THREE.Points(dustGeometry, dustMaterial);
      scene.add(dustParticles);
    }
    function updateDust(delta) {
      if (dustParticles) {
        let positions = dustParticles.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += 0.5 * delta;
          if (positions[i + 1] > 200) { positions[i + 1] = 50; }
        }
        dustParticles.geometry.attributes.position.needsUpdate = true;
      }
    }

    // Create a green tank with optional camouflage
    function createTank(colorOverride) {
      const greenShades = [0x228B22, 0x2E8B57, 0x556B2F, 0x6B8E23];
      let baseColor = colorOverride || greenShades[Math.floor(Math.random() * greenShades.length)];
      let useCamo = Math.random() < 0.5;
      let chassisMatOpts = useCamo ? { map: createCamoTexture() } : { color: baseColor };
      let tank = new THREE.Group();
      let chassisGeom = new THREE.BoxGeometry(3.5, 1.2, 6);
      let chassisMat = new THREE.MeshStandardMaterial(Object.assign({ metalness: 0.6, roughness: 0.4 }, chassisMatOpts));
      let chassis = new THREE.Mesh(chassisGeom, chassisMat);
      chassis.castShadow = true;
      chassis.receiveShadow = true;
      chassis.position.y = 0.6;
      tank.add(chassis);
      const wheelGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      for (let side of [1, -1]) {
        for (let i = -1; i <= 1; i++) {
          let wheel = new THREE.Mesh(wheelGeom, wheelMat);
          wheel.rotation.z = Math.PI / 2;
          wheel.castShadow = true;
          wheel.receiveShadow = true;
          wheel.position.set(side * 2.1, 0.3, i * 2);
          tank.add(wheel);
        }
      }
      let hatchGeom = new THREE.BoxGeometry(1, 0.2, 1);
      let hatchMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
      let hatch = new THREE.Mesh(hatchGeom, hatchMat);
      hatch.position.set(0, 1.1, -0.5);
      hatch.castShadow = true;
      hatch.receiveShadow = true;
      tank.add(hatch);
      let turret = new THREE.Group();
      let turretBaseGeom = new THREE.BoxGeometry(2.5, 1, 3);
      let turretBaseMat = new THREE.MeshStandardMaterial(Object.assign({ metalness: 0.7, roughness: 0.3 }, chassisMatOpts));
      let turretBase = new THREE.Mesh(turretBaseGeom, turretBaseMat);
      turretBase.castShadow = true;
      turretBase.receiveShadow = true;
      turretBase.position.y = 0.5;
      turret.add(turretBase);
      // Cannon: rotate about X-axis so it points forward (+Z)
      let cannonGeom = new THREE.CylinderGeometry(0.2, 0.2, 5, 16);
      let cannonMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      let cannon = new THREE.Mesh(cannonGeom, cannonMat);
      cannon.castShadow = true;
      cannon.receiveShadow = true;
      cannon.rotation.x = Math.PI / 2;
      cannon.position.set(0, 0, 1.5);
      turret.add(cannon);
      turret.position.set(0, 1.4, 0);
      tank.add(turret);
      tank.userData.turret = turret;
      tank.userData.cannon = cannon;
      return tank;
    }

    // Generate a camo texture using canvas
    function createCamoTexture() {
      let size = 256;
      let canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      let ctx = canvas.getContext("2d");
      ctx.fillStyle = "#2E8B57";
      ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 10; i++) {
        let x = Math.random() * size;
        let y = Math.random() * size;
        let radius = Math.random() * 30 + 10;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = "#556B2F";
        ctx.fill();
      }
      return new THREE.CanvasTexture(canvas);
    }

    // Add nickname label above the tank
    function addNicknameLabel(tank, nickname) {
      tank.children = tank.children.filter(child => child.name !== "nicknameLabel");
      let canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 64;
      let ctx = canvas.getContext('2d');
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = "30px Arial";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.fillText(nickname, canvas.width / 2, canvas.height / 2 + 10);
      let texture = new THREE.CanvasTexture(canvas);
      let sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
      sprite.name = "nicknameLabel";
      sprite.scale.set(4, 1, 1);
      sprite.position.set(0, 3.5, 0);
      tank.add(sprite);
    }

    // Mouse input for turret rotation and shooting on left-click
    let turretRotationOffset = 0;
    document.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement === document.body) {
        turretRotationOffset -= e.movementX * 0.002;
        if (localTank && localTank.userData.turret) {
          localTank.userData.turret.rotation.y = turretRotationOffset;
        }
      }
    });
    document.addEventListener("mousedown", (e) => {
      if (e.button === 0) { sendShoot(); }
    });

    // Align tank with terrain slope and update its height
    function updateTankHeight() {
      if (!groundMesh) return;
      let origin = new THREE.Vector3(localTank.position.x, 1000, localTank.position.z);
      let raycaster = new THREE.Raycaster(origin, new THREE.Vector3(0, -1, 0));
      let intersects = raycaster.intersectObject(groundMesh);
      if (intersects.length > 0) {
        let intersect = intersects[0];
        localTank.position.y = intersect.point.y + 0.6;
        let normal = intersect.face.normal.clone();
        normal.transformDirection(groundMesh.matrixWorld);
        let currentEuler = new THREE.Euler().setFromQuaternion(localTank.quaternion, 'YXZ');
        let yaw = currentEuler.y;
        let forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
        let projectedForward = forward.clone().projectOnPlane(normal).normalize();
        if (projectedForward.length() < 0.001) { projectedForward = new THREE.Vector3(0, 0, 1); }
        let right = new THREE.Vector3().crossVectors(normal, projectedForward).normalize();
        let m = new THREE.Matrix4();
        m.makeBasis(right, normal, projectedForward);
        localTank.quaternion.setFromRotationMatrix(m);
      }
    }

    function checkCollisions() {
      for (let obs of treeColliders || []) {
        if (localTank.position.distanceTo(obs.position) < 10) {
          localTank.position.copy(prevTankPosition);
          return;
        }
      }
      const boundary = 500;
      if (localTank.position.x < -boundary || localTank.position.x > boundary ||
          localTank.position.z < -boundary || localTank.position.z > boundary) {
        localTank.position.copy(prevTankPosition);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(e) {
      if (e.code === "KeyT" && document.activeElement !== chatInput) { toggleChat(); return; }
      if (e.code === "KeyI") { toggleInfoBar(); return; }
      if (document.activeElement === chatInput) return;
      switch (e.code) {
        case "KeyW": controls.forward = true; break;
        case "KeyS": controls.backward = true; break;
        case "KeyA": controls.left = true; break;
        case "KeyD": controls.right = true; break;
        case "Space": controls.shoot = true; sendShoot(); break;
        case "ShiftLeft": faster = true; break;
        case "Digit1": cameraMode = 1; break;
        case "Digit2": cameraMode = 2; break;
        case "Digit3": cameraMode = 3; break;
      }
    }

    function onKeyUp(e) {
      switch (e.code) {
        case "KeyW": controls.forward = false; break;
        case "KeyS": controls.backward = false; break;
        case "KeyA": controls.left = false; break;
        case "KeyD": controls.right = false; break;
        case "Space": controls.shoot = false; break;
        case "ShiftLeft": faster = false; break;
      }
    }

    const chatInput = document.getElementById("chatInput");
    chatInput.addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        if (chatInput.value.trim() !== "") { sendChat(chatInput.value.trim()); chatInput.value = ""; }
        chatInput.style.display = "none";
      }
    });
    function toggleChat() {
      chatInput.style.display = (chatInput.style.display === "none" || chatInput.style.display === "") ? "block" : "none";
      if (chatInput.style.display === "block") chatInput.focus();
    }

    let isDragging = false, offsetX = 0, offsetY = 0;
    const infoBar = document.getElementById("infoBar");
    infoBar.addEventListener("mousedown", function(e) {
      isDragging = true;
      offsetX = e.clientX - infoBar.offsetLeft;
      offsetY = e.clientY - infoBar.offsetTop;
    });
    document.addEventListener("mousemove", function(e) {
      if (isDragging) { infoBar.style.left = (e.clientX - offsetX) + "px"; infoBar.style.top = (e.clientY - offsetY) + "px"; }
    });
    document.addEventListener("mouseup", function() { isDragging = false; });
    let infoVisible = true;
    function toggleInfoBar() {
      infoVisible = !infoVisible;
      infoBar.style.display = infoVisible ? "block" : "none";
    }

    // WebSocket Setup with error handling and reconnection logic
    function setupWebSocket() {
      ws = new WebSocket(WS_URL);
      ws.onopen = () => {
        ws.send(JSON.stringify({
          type: "join",
          id: playerData.id,
          nickname: playerData.nickname,
          color: playerData.color,
          position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z }
        }));
        setInterval(() => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "ping", timestamp: performance.now() }));
          }
        }, 2000);
      };
      ws.onmessage = (event) => {
        try {
          let msg = JSON.parse(event.data);
          if (msg.type === "pong") { 
            latency = performance.now() - msg.timestamp; 
            return; 
          }
          handleServerMessage(msg);
        } catch (err) {
          console.error("Failed to parse message:", err, event.data);
        }
      };
      ws.onclose = () => {
        console.log("Disconnected from server. Attempting to reconnect in 3 seconds...");
        setTimeout(setupWebSocket, 3000);
      };
      ws.onerror = (err) => {
        console.error("WebSocket error:", err);
      };
    }

    function handleServerMessage(msg) {
      switch (msg.type) {
        case "update":
          if (msg.id !== playerData.id) { updateRemoteTank(msg); }
          break;
        case "chat":
          displayChatBubble(msg);
          addGlobalChatMessage(`${msg.nickname}: ${msg.message}`);
          break;
        case "shoot":
          addKillFeed(`${msg.nickname} fired!`);
          if (msg.id !== playerData.id) { createRemoteMissile(msg); }
          break;
        case "kill":
          addKillFeed(`${msg.killer} eliminated ${msg.victim}`);
          break;
        case "join":
          if (msg.id !== playerData.id && !remoteTanks[msg.id]) {
            let tank = createTank();
            tank.position.set(msg.position.x, msg.position.y, msg.position.z);
            scene.add(tank);
            addNicknameLabel(tank, msg.nickname);
            remoteTanks[msg.id] = { mesh: tank, nickname: msg.nickname, health: 100 };
          }
          break;
        case "leave":
          if (remoteTanks[msg.id]) {
            scene.remove(remoteTanks[msg.id].mesh);
            delete remoteTanks[msg.id];
          }
          break;
      }
    }

    function updateRemoteTank(data) {
      if (!remoteTanks[data.id]) {
        let tank = createTank();
        tank.position.set(data.position.x, data.position.y, data.position.z);
        scene.add(tank);
        addNicknameLabel(tank, data.nickname);
        remoteTanks[data.id] = { mesh: tank, nickname: data.nickname, health: 100 };
      } else {
        let currentPos = remoteTanks[data.id].mesh.position;
        let targetPos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
        currentPos.lerp(targetPos, 0.1);
        remoteTanks[data.id].mesh.rotation.y = THREE.MathUtils.lerp(remoteTanks[data.id].mesh.rotation.y, data.rotation, 0.1);
      }
    }

    // Send updates at a fixed rate (15 updates per second)
    function sendUpdate() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "update",
          id: playerData.id,
          position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
          rotation: localTank.rotation.y
        }));
      }
    }

    // Chat and Shooting Functions
    let lastChatTime = 0;
    const chatCooldown = 2000;
    function sendChat(message) {
      let now = Date.now();
      if (now - lastChatTime < chatCooldown) return;
      lastChatTime = now;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "chat",
          id: playerData.id,
          nickname: playerData.nickname,
          message: message
        }));
        displayChatBubble({ id: playerData.id, nickname: playerData.nickname, message: message });
        addGlobalChatMessage(`${playerData.nickname}: ${message}`);
      }
    }
    function launchMissile() {
      let selectedMissileType = document.getElementById("missileTypeSelect").value;
      let missileProps = missileTypes[selectedMissileType];
      let cannon = localTank.userData.cannon;
      let direction = new THREE.Vector3();
      cannon.getWorldDirection(direction);
      let position = new THREE.Vector3();
      cannon.getWorldPosition(position);
      let spawnPos = position.clone().add(direction.clone().multiplyScalar(1));
      let missileMesh = new THREE.Mesh(missileProps.geometry(), missileProps.material);
      missileMesh.position.copy(spawnPos);
      missileMesh.quaternion.copy(cannon.getWorldQuaternion(new THREE.Quaternion()));
      let velocity = direction.multiplyScalar(missileProps.speed);
      missileMesh.userData.lastTrailTime = 0;
      missileMesh.userData.owner = playerData.id;
      missiles.push({ mesh: missileMesh, velocity: velocity, life: 5, type: selectedMissileType, owner: playerData.id });
      scene.add(missileMesh);
      let originalPos = cannon.position.clone();
      cannon.position.z -= 0.2;
      setTimeout(() => { cannon.position.copy(originalPos); }, 100);
    }
    function createRemoteMissile(data) {
      let missileType = data.missileType || "bullet";
      let missileProps = missileTypes[missileType];
      let missileMesh = new THREE.Mesh(missileProps.geometry(), missileProps.material);
      missileMesh.position.set(data.position.x, data.position.y, data.position.z);
      missileMesh.rotation.y = data.rotation;
      missileMesh.userData.lastTrailTime = 0;
      missileMesh.userData.owner = data.id;
      let direction = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), data.rotation);
      let velocity = direction.multiplyScalar(missileProps.speed);
      missiles.push({ mesh: missileMesh, velocity: velocity, life: 5, type: missileType, owner: data.id });
      scene.add(missileMesh);
    }
    function sendShoot() {
      let selectedMissileType = document.getElementById("missileTypeSelect").value;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "shoot",
          id: playerData.id,
          nickname: playerData.nickname,
          position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
          rotation: localTank.rotation.y,
          missileType: selectedMissileType
        }));
      }
      launchMissile();
    }

    // Animation Loop and Camera Update
    let cameraMode = 1;
    function animate() {
      requestAnimationFrame(animate);
      let delta = clock.getDelta();
      prevTankPosition.copy(localTank.position);
      let speed = 15 * delta * (faster ? 2 : 1);
      if (controls.forward) localTank.translateZ(speed);
      if (controls.backward) localTank.translateZ(-speed);
      if (controls.left) localTank.rotation.y += 2 * delta;
      if (controls.right) localTank.rotation.y -= 2 * delta;
      checkCollisions();
      updateTankHeight();
      updateCamera();
      localTank.children.forEach(child => { if (child.type === "Sprite") child.lookAt(camera.position); });
      for (let id in remoteTanks) {
        remoteTanks[id].mesh.children.forEach(child => { if (child.type === "Sprite") child.lookAt(camera.position); });
      }
      // Throttle sendUpdate() to 15 updates per second
      const now = performance.now();
      if (now - lastUpdateTime > updateInterval) {
        sendUpdate();
        lastUpdateTime = now;
      }
      updateMissiles(delta);
      updateTrailParticles(delta);
      if (currentWeather === "rain") { updateRain(delta); }
      else if (currentWeather === "snow") { updateSnow(delta); }
      else if (currentWeather === "storm") { updateStorm(delta); }
      updateDust(delta);
      renderer.render(scene, camera);
      updateMinimap();
      updateHealthBar();
      updateInfoBar();
    }
    function updateCamera() {
      let targetPos;
      if (cameraMode === 1) {
        targetPos = new THREE.Vector3(0, 5, -10).applyMatrix4(localTank.matrixWorld);
      } else if (cameraMode === 2) {
        targetPos = localTank.localToWorld(new THREE.Vector3(0, 2, 0));
      } else if (cameraMode === 3) {
        targetPos = localTank.position.clone().add(new THREE.Vector3(0, 30, 0));
      }
      if (cameraShakeTime > 0) {
        targetPos.x += (Math.random()-0.5) * cameraShakeIntensity;
        targetPos.y += (Math.random()-0.5) * cameraShakeIntensity;
        cameraShakeTime -= clock.getDelta();
      }
      camera.position.lerp(targetPos, 0.1);
      camera.lookAt(localTank.position);
    }
    function updateMinimap() {
      let minimap = document.getElementById("minimap"), ctx = minimap.getContext("2d");
      ctx.clearRect(0, 0, minimap.width, minimap.height);
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(0, 0, minimap.width, minimap.height);
      const fullMap = 1000, half = fullMap / 2;
      function worldToMinimap(x, z) {
        return { x: (x + half) * (minimap.width / fullMap), y: (half - z) * (minimap.height / fullMap) };
      }
      let pos = worldToMinimap(localTank.position.x, localTank.position.z);
      ctx.fillStyle = playerData.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      for (let id in remoteTanks) {
        let pos2 = worldToMinimap(remoteTanks[id].mesh.position.x, remoteTanks[id].mesh.position.z);
        ctx.beginPath();
        ctx.arc(pos2.x, pos2.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    setInterval(() => { currentMap = 'desert'; loadMap(currentMap); }, 180000);

    // Desert Terrain Setup
    let groundMesh, treeColliders;
    function setupTerrainTexture() {
      const loader = new THREE.TextureLoader();
      let sandTexture = loader.load('https://threejs.org/examples/textures/sand.jpg');
      sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;
      sandTexture.repeat.set(50, 50);
      return sandTexture;
    }
    function createBush() {
      let bush = new THREE.Group();
      let bushGeom = new THREE.SphereGeometry(1, 8, 8);
      let bushMat = new THREE.MeshStandardMaterial({ color: 0x775533 });
      let bushMesh = new THREE.Mesh(bushGeom, bushMat);
      bushMesh.castShadow = true;
      bushMesh.receiveShadow = true;
      bush.add(bushMesh);
      return bush;
    }
    function createCactusVariety() {
      let cactus = new THREE.Group();
      let scale = Math.random() * 0.5 + 0.8;
      let stem = new THREE.Mesh(new THREE.CylinderGeometry(0.3 * scale, 0.3 * scale, 4 * scale, 8),
        new THREE.MeshStandardMaterial({ color: 0x228B22 }));
      stem.position.y = 2 * scale;
      cactus.add(stem);
      if (Math.random() > 0.5) {
        let arm = new THREE.Mesh(new THREE.CylinderGeometry(0.2 * scale, 0.2 * scale, 2 * scale, 8),
          new THREE.MeshStandardMaterial({ color: 0x228B22 }));
        arm.rotation.z = Math.PI / 4;
        arm.position.set(0.5 * scale, 3 * scale, 0);
        cactus.add(arm);
        let arm2 = arm.clone();
        arm2.rotation.z = -Math.PI / 4;
        arm2.position.set(-0.5 * scale, 3 * scale, 0);
        cactus.add(arm2);
      }
      return cactus;
    }
    function loadMap(mapType) {
      if (typeof treeColliders === 'undefined') treeColliders = [];
      let mapGroup = scene.getObjectByName("mapGroup");
      if (mapGroup) { scene.remove(mapGroup); }
      mapGroup = new THREE.Group();
      mapGroup.name = "mapGroup";
      treeColliders = [];
      const size = 1000, segments = 200;
      const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
      geometry.rotateX(-Math.PI / 2);
      let amplitude = 8, scale = 150;
      let noise = new ImprovedNoise();
      let positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        let x = positions.getX(i), z = positions.getZ(i);
        let y = noise.noise(x / scale, z / scale, 0) * amplitude;
        positions.setY(i, y);
      }
      positions.needsUpdate = true;
      geometry.computeVertexNormals();
      const material = new THREE.MeshStandardMaterial({ map: setupTerrainTexture(), color: 0xF5DEB3 });
      groundMesh = new THREE.Mesh(geometry, material);
      groundMesh.receiveShadow = true;
      mapGroup.add(groundMesh);
      for (let i = 0; i < 70; i++) {
        let rockSize = Math.random() * 2 + 0.5;
        let rockGeom = new THREE.DodecahedronGeometry(rockSize, 0);
        let rockMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        let rock = new THREE.Mesh(rockGeom, rockMat);
        rock.castShadow = true;
        rock.receiveShadow = true;
        rock.position.set((Math.random()-0.5)*size, 0, (Math.random()-0.5)*size);
        let rockHeight = noise.noise(rock.position.x / scale, rock.position.z / scale, 0) * amplitude;
        rock.position.y = rockHeight + rockSize/2;
        rock.rotation.y = Math.random() * Math.PI * 2;
        mapGroup.add(rock);
      }
      for (let i = 0; i < 10; i++) {
        let cactus = createCactusVariety();
        cactus.traverse(child => { if(child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
        cactus.position.set((Math.random()-0.5)*size, 0, (Math.random()-0.5)*size);
        let y = noise.noise(cactus.position.x / scale, cactus.position.z / scale, 0) * amplitude;
        cactus.position.y = y;
        mapGroup.add(cactus);
      }
      for (let i = 0; i < 20; i++) {
        let bush = createBush();
        bush.traverse(child => { if(child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
        bush.position.set((Math.random()-0.5)*size, 0, (Math.random()-0.5)*size);
        let y = noise.noise(bush.position.x / scale, bush.position.z / scale, 0) * amplitude;
        bush.position.y = y;
        mapGroup.add(bush);
      }
      scene.add(mapGroup);
    }

    // Dynamic Skybox and Weather
    function applyWeather(weather) {
      currentWeather = weather;
      const infoBar = document.getElementById("infoBar");
      let weatherText = "Weather: " + weather.charAt(0).toUpperCase() + weather.slice(1);
      infoBar.innerHTML = `<strong>Controls:</strong> WASD, SPACE/Left-Click (Shoot), 1-3 (Camera), SHIFT, T (Chat), I (Toggle Info)<br>
        <strong>Connection:</strong> <span id="latencyDisplay">--</span> ms<br>
        <strong>Players:</strong> --<br>
        <strong>${weatherText}</strong><br>
        <strong>Version:</strong> 1.1.2`;
      
      const loader = new THREE.CubeTextureLoader();
      const textureURLs = skyboxTextures[weather] || skyboxTextures.sunny;
      let ambientLightIntensity = 0.6;
      switch (weather) {
        case "sunny":
          ambientLightIntensity = 0.6;
          removeWeatherParticles();
          removeClouds();
          break;
        case "rain":
          ambientLightIntensity = 0.4;
          startRain();
          removeClouds();
          break;
        case "snow":
          ambientLightIntensity = 0.5;
          startSnow();
          startClouds();
          break;
        case "cloudy":
          ambientLightIntensity = 0.5;
          removeWeatherParticles();
          startClouds();
          break;
        case "storm":
          ambientLightIntensity = 0.3;
          startStorm();
          startClouds();
          break;
      }
      let newTexture = loader.load(textureURLs);
      scene.background = newTexture;
      let ambient = scene.getObjectByName("ambientLight");
      if (ambient) { ambient.intensity = ambientLightIntensity; }
    }
    setInterval(() => {
      const weatherTypes = ["sunny", "rain", "snow", "cloudy", "storm"];
      const newWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
      applyWeather(newWeather);
    }, 60000);

    // Dummy weather functions (replace with actual implementations)
    function startRain() { /* Implement rain particle system */ }
    function startSnow() { /* Implement snow particle system */ }
    function startStorm() { /* Implement storm effects */ }
    function removeWeatherParticles() { /* Remove active weather particles */ }

    // WebSocket Setup (only one declaration)
    function setupWebSocket() {
      ws = new WebSocket(WS_URL);
      ws.onopen = () => {
        ws.send(JSON.stringify({
          type: "join",
          id: playerData.id,
          nickname: playerData.nickname,
          color: playerData.color,
          position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z }
        }));
        setInterval(() => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "ping", timestamp: performance.now() }));
          }
        }, 2000);
      };
      ws.onmessage = (event) => {
        try {
          let msg = JSON.parse(event.data);
          if (msg.type === "pong") { 
            latency = performance.now() - msg.timestamp; 
            return; 
          }
          handleServerMessage(msg);
        } catch (err) {
          console.error("Failed to parse message:", err, event.data);
        }
      };
      ws.onclose = () => {
        console.log("Disconnected from server. Reconnecting in 3 seconds...");
        setTimeout(setupWebSocket, 3000);
      };
      ws.onerror = (err) => {
        console.error("WebSocket error:", err);
      };
    }

    function handleServerMessage(msg) {
      switch (msg.type) {
        case "update":
          if (msg.id !== playerData.id) { updateRemoteTank(msg); }
          break;
        case "chat":
          displayChatBubble(msg);
          addGlobalChatMessage(`${msg.nickname}: ${msg.message}`);
          break;
        case "shoot":
          addKillFeed(`${msg.nickname} fired!`);
          if (msg.id !== playerData.id) { createRemoteMissile(msg); }
          break;
        case "kill":
          addKillFeed(`${msg.killer} eliminated ${msg.victim}`);
          break;
        case "join":
          if (msg.id !== playerData.id && !remoteTanks[msg.id]) {
            let tank = createTank();
            tank.position.set(msg.position.x, msg.position.y, msg.position.z);
            scene.add(tank);
            addNicknameLabel(tank, msg.nickname);
            remoteTanks[msg.id] = { mesh: tank, nickname: msg.nickname, health: 100 };
          }
          break;
        case "leave":
          if (remoteTanks[msg.id]) {
            scene.remove(remoteTanks[msg.id].mesh);
            delete remoteTanks[msg.id];
          }
          break;
      }
    }

    function updateRemoteTank(data) {
      if (!remoteTanks[data.id]) {
        let tank = createTank();
        tank.position.set(data.position.x, data.position.y, data.position.z);
        scene.add(tank);
        addNicknameLabel(tank, data.nickname);
        remoteTanks[data.id] = { mesh: tank, nickname: data.nickname, health: 100 };
      } else {
        let currentPos = remoteTanks[data.id].mesh.position;
        let targetPos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
        currentPos.lerp(targetPos, 0.1);
        remoteTanks[data.id].mesh.rotation.y = THREE.MathUtils.lerp(remoteTanks[data.id].mesh.rotation.y, data.rotation, 0.1);
      }
    }

    function sendUpdate() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "update",
          id: playerData.id,
          position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
          rotation: localTank.rotation.y
        }));
      }
    }

    // Chat and Shooting Functions
    let lastChatTime = 0;
    const chatCooldown = 2000;
    function sendChat(message) {
      let now = Date.now();
      if (now - lastChatTime < chatCooldown) return;
      lastChatTime = now;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "chat",
          id: playerData.id,
          nickname: playerData.nickname,
          message: message
        }));
        displayChatBubble({ id: playerData.id, nickname: playerData.nickname, message: message });
        addGlobalChatMessage(`${playerData.nickname}: ${message}`);
      }
    }
    function launchMissile() {
      let selectedMissileType = document.getElementById("missileTypeSelect").value;
      let missileProps = missileTypes[selectedMissileType];
      let cannon = localTank.userData.cannon;
      let direction = new THREE.Vector3();
      cannon.getWorldDirection(direction);
      let position = new THREE.Vector3();
      cannon.getWorldPosition(position);
      let spawnPos = position.clone().add(direction.clone().multiplyScalar(1));
      let missileMesh = new THREE.Mesh(missileProps.geometry(), missileProps.material);
      missileMesh.position.copy(spawnPos);
      missileMesh.quaternion.copy(cannon.getWorldQuaternion(new THREE.Quaternion()));
      let velocity = direction.multiplyScalar(missileProps.speed);
      missileMesh.userData.lastTrailTime = 0;
      missileMesh.userData.owner = playerData.id;
      missiles.push({ mesh: missileMesh, velocity: velocity, life: 5, type: selectedMissileType, owner: playerData.id });
      scene.add(missileMesh);
      let originalPos = cannon.position.clone();
      cannon.position.z -= 0.2;
      setTimeout(() => { cannon.position.copy(originalPos); }, 100);
    }
    function createRemoteMissile(data) {
      let missileType = data.missileType || "bullet";
      let missileProps = missileTypes[missileType];
      let missileMesh = new THREE.Mesh(missileProps.geometry(), missileProps.material);
      missileMesh.position.set(data.position.x, data.position.y, data.position.z);
      missileMesh.rotation.y = data.rotation;
      missileMesh.userData.lastTrailTime = 0;
      missileMesh.userData.owner = data.id;
      let direction = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), data.rotation);
      let velocity = direction.multiplyScalar(missileProps.speed);
      missiles.push({ mesh: missileMesh, velocity: velocity, life: 5, type: missileType, owner: data.id });
      scene.add(missileMesh);
    }
    function sendShoot() {
      let selectedMissileType = document.getElementById("missileTypeSelect").value;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "shoot",
          id: playerData.id,
          nickname: playerData.nickname,
          position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
          rotation: localTank.rotation.y,
          missileType: selectedMissileType
        }));
      }
      launchMissile();
    }

    // Animation Loop and Camera Update
    let cameraMode = 1;
    function animate() {
      requestAnimationFrame(animate);
      let delta = clock.getDelta();
      prevTankPosition.copy(localTank.position);
      let speed = 15 * delta * (faster ? 2 : 1);
      if (controls.forward) localTank.translateZ(speed);
      if (controls.backward) localTank.translateZ(-speed);
      if (controls.left) localTank.rotation.y += 2 * delta;
      if (controls.right) localTank.rotation.y -= 2 * delta;
      checkCollisions();
      updateTankHeight();
      updateCamera();
      localTank.children.forEach(child => { if (child.type === "Sprite") child.lookAt(camera.position); });
      for (let id in remoteTanks) {
        remoteTanks[id].mesh.children.forEach(child => { if (child.type === "Sprite") child.lookAt(camera.position); });
      }
      // Throttle sendUpdate() to 15 updates per second
      const now = performance.now();
      if (now - lastUpdateTime > updateInterval) {
        sendUpdate();
        lastUpdateTime = now;
      }
      updateMissiles(delta);
      updateTrailParticles(delta);
      if (currentWeather === "rain") { updateRain(delta); }
      else if (currentWeather === "snow") { updateSnow(delta); }
      else if (currentWeather === "storm") { updateStorm(delta); }
      updateDust(delta);
      renderer.render(scene, camera);
      updateMinimap();
      updateHealthBar();
      updateInfoBar();
    }
    function updateCamera() {
      let targetPos;
      if (cameraMode === 1) {
        targetPos = new THREE.Vector3(0, 5, -10).applyMatrix4(localTank.matrixWorld);
      } else if (cameraMode === 2) {
        targetPos = localTank.localToWorld(new THREE.Vector3(0, 2, 0));
      } else if (cameraMode === 3) {
        targetPos = localTank.position.clone().add(new THREE.Vector3(0, 30, 0));
      }
      if (cameraShakeTime > 0) {
        targetPos.x += (Math.random()-0.5) * cameraShakeIntensity;
        targetPos.y += (Math.random()-0.5) * cameraShakeIntensity;
        cameraShakeTime -= clock.getDelta();
      }
      camera.position.lerp(targetPos, 0.1);
      camera.lookAt(localTank.position);
    }
    function updateMinimap() {
      let minimap = document.getElementById("minimap"), ctx = minimap.getContext("2d");
      ctx.clearRect(0, 0, minimap.width, minimap.height);
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(0, 0, minimap.width, minimap.height);
      const fullMap = 1000, half = fullMap / 2;
      function worldToMinimap(x, z) {
        return { x: (x + half) * (minimap.width / fullMap), y: (half - z) * (minimap.height / fullMap) };
      }
      let pos = worldToMinimap(localTank.position.x, localTank.position.z);
      ctx.fillStyle = playerData.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      for (let id in remoteTanks) {
        let pos2 = worldToMinimap(remoteTanks[id].mesh.position.x, remoteTanks[id].mesh.position.z);
        ctx.beginPath();
        ctx.arc(pos2.x, pos2.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    setInterval(() => { currentMap = 'desert'; loadMap(currentMap); }, 180000);

    // Desert Terrain Setup
    let groundMesh, treeColliders;
    function setupTerrainTexture() {
      const loader = new THREE.TextureLoader();
      let sandTexture = loader.load('https://threejs.org/examples/textures/sand.jpg');
      sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;
      sandTexture.repeat.set(50, 50);
      return sandTexture;
    }
    function createBush() {
      let bush = new THREE.Group();
      let bushGeom = new THREE.SphereGeometry(1, 8, 8);
      let bushMat = new THREE.MeshStandardMaterial({ color: 0x775533 });
      let bushMesh = new THREE.Mesh(bushGeom, bushMat);
      bushMesh.castShadow = true;
      bushMesh.receiveShadow = true;
      bush.add(bushMesh);
      return bush;
    }
    function createCactusVariety() {
      let cactus = new THREE.Group();
      let scale = Math.random() * 0.5 + 0.8;
      let stem = new THREE.Mesh(new THREE.CylinderGeometry(0.3 * scale, 0.3 * scale, 4 * scale, 8),
        new THREE.MeshStandardMaterial({ color: 0x228B22 }));
      stem.position.y = 2 * scale;
      cactus.add(stem);
      if (Math.random() > 0.5) {
        let arm = new THREE.Mesh(new THREE.CylinderGeometry(0.2 * scale, 0.2 * scale, 2 * scale, 8),
          new THREE.MeshStandardMaterial({ color: 0x228B22 }));
        arm.rotation.z = Math.PI / 4;
        arm.position.set(0.5 * scale, 3 * scale, 0);
        cactus.add(arm);
        let arm2 = arm.clone();
        arm2.rotation.z = -Math.PI / 4;
        arm2.position.set(-0.5 * scale, 3 * scale, 0);
        cactus.add(arm2);
      }
      return cactus;
    }
    function loadMap(mapType) {
      if (typeof treeColliders === 'undefined') treeColliders = [];
      let mapGroup = scene.getObjectByName("mapGroup");
      if (mapGroup) { scene.remove(mapGroup); }
      mapGroup = new THREE.Group();
      mapGroup.name = "mapGroup";
      treeColliders = [];
      const size = 1000, segments = 200;
      const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
      geometry.rotateX(-Math.PI / 2);
      let amplitude = 8, scale = 150;
      let noise = new ImprovedNoise();
      let positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        let x = positions.getX(i), z = positions.getZ(i);
        let y = noise.noise(x / scale, z / scale, 0) * amplitude;
        positions.setY(i, y);
      }
      positions.needsUpdate = true;
      geometry.computeVertexNormals();
      const material = new THREE.MeshStandardMaterial({ map: setupTerrainTexture(), color: 0xF5DEB3 });
      groundMesh = new THREE.Mesh(geometry, material);
      groundMesh.receiveShadow = true;
      mapGroup.add(groundMesh);
      for (let i = 0; i < 70; i++) {
        let rockSize = Math.random() * 2 + 0.5;
        let rockGeom = new THREE.DodecahedronGeometry(rockSize, 0);
        let rockMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        let rock = new THREE.Mesh(rockGeom, rockMat);
        rock.castShadow = true;
        rock.receiveShadow = true;
        rock.position.set((Math.random()-0.5)*size, 0, (Math.random()-0.5)*size);
        let rockHeight = noise.noise(rock.position.x / scale, rock.position.z / scale, 0) * amplitude;
        rock.position.y = rockHeight + rockSize/2;
        rock.rotation.y = Math.random() * Math.PI * 2;
        mapGroup.add(rock);
      }
      for (let i = 0; i < 10; i++) {
        let cactus = createCactusVariety();
        cactus.traverse(child => { if(child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
        cactus.position.set((Math.random()-0.5)*size, 0, (Math.random()-0.5)*size);
        let y = noise.noise(cactus.position.x / scale, cactus.position.z / scale, 0) * amplitude;
        cactus.position.y = y;
        mapGroup.add(cactus);
      }
      for (let i = 0; i < 20; i++) {
        let bush = createBush();
        bush.traverse(child => { if(child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
        bush.position.set((Math.random()-0.5)*size, 0, (Math.random()-0.5)*size);
        let y = noise.noise(bush.position.x / scale, bush.position.z / scale, 0) * amplitude;
        bush.position.y = y;
        mapGroup.add(bush);
      }
      scene.add(mapGroup);
    }

    // Initialization and Terrain Setup
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function init() {
      clock = new THREE.Clock();
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0xEDC9AF, 0.002);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 5, -10);
      let ambient = new THREE.AmbientLight(0xfff4e5, 0.6);
      ambient.name = "ambientLight";
      scene.add(ambient);
      let dirLight = new THREE.DirectionalLight(0xffaa66, 1.5);
      dirLight.position.set(80, 100, -60);
      dirLight.castShadow = true;
      dirLight.shadow.camera.left = -200;
      dirLight.shadow.camera.right = 200;
      dirLight.shadow.camera.top = 200;
      dirLight.shadow.camera.bottom = -200;
      scene.add(dirLight);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      loadMap(currentMap);
      localTank = createTank();
      localTank.position.set(0, 0.6, 0);
      scene.add(localTank);
      addNicknameLabel(localTank, playerData.nickname);
      setupWebSocket();
      const weatherTypes = ["sunny", "rain", "snow", "cloudy", "storm"];
      currentWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
      applyWeather(currentWeather);
      startDust();
      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('keydown', onKeyDown, false);
      window.addEventListener('keyup', onKeyUp, false);
      animate();
    }
    init();
  </script>
</body>
</html>
