<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kennedy Chat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      height: 100vh;
      overflow: hidden;
      transition: background 0.3s ease;
    }

    body.light-mode {
      background: linear-gradient(135deg, #e0f4ff 0%, #ffffff 100%);
      color: #333;
    }

    body.dark-mode {
      background: linear-gradient(135deg, #001a33 0%, #003366 100%);
      color: #ffffff;
    }

    .container {
      display: flex;
      height: 100vh;
      max-width: 1400px;
      margin: 0 auto;
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      min-width: 0;
    }

    .sidebar {
      width: 300px;
      padding: 20px;
      border-left: 1px solid rgba(0, 0, 0, 0.1);
      overflow-y: auto;
    }

    body.dark-mode .sidebar {
      border-left-color: rgba(255, 255, 255, 0.2);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 28px;
      font-weight: 600;
    }

    .dark-mode-toggle {
      background: rgba(0, 0, 0, 0.1);
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    body.dark-mode .dark-mode-toggle {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .dark-mode-toggle:hover {
      transform: scale(1.05);
    }

    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 15px;
      padding: 20px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .chat-container {
      background: rgba(0, 26, 51, 0.5);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .messages {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 20px;
      padding-right: 10px;
    }

    .messages::-webkit-scrollbar {
      width: 8px;
    }

    .messages::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
    }

    .messages::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }

    body.dark-mode .messages::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .messages::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
    }

    .message {
      margin-bottom: 15px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 10px;
      animation: slideIn 0.3s ease;
      position: relative;
    }

    /* Own messages = GREEN */
    .message.own-message {
      background: rgba(34, 197, 94, 0.2);
      border-left: 3px solid #22c55e;
    }

    /* Others' messages = BLUE */
    .message.other-message {
      background: rgba(59, 130, 246, 0.2);
      border-left: 3px solid #3b82f6;
    }

    body.dark-mode .message {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .message.own-message {
      background: rgba(34, 197, 94, 0.15);
      border-left-color: #4ade80;
    }

    body.dark-mode .message.other-message {
      background: rgba(59, 130, 246, 0.15);
      border-left-color: #60a5fa;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(-20px);
      }
    }

    .message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
      opacity: 0.7;
    }

    .nickname {
      font-weight: 600;
      color: #0066cc;
    }

    body.dark-mode .nickname {
      color: #66b3ff;
    }

    .timestamp {
      font-size: 11px;
    }

    .message-content {
      word-wrap: break-word;
      line-height: 1.5;
    }

    .message-image {
      margin-top: 10px;
      max-width: 192px;
      max-height: 256px;
      cursor: pointer;
      border-radius: 8px;
      object-fit: cover;
      transition: transform 0.2s ease;
    }

    .message-image:hover {
      transform: scale(1.02);
    }

    .message-file {
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      display: inline-block;
    }

    body.dark-mode .message-file {
      background: rgba(255, 255, 255, 0.1);
    }

    .message-file a {
      color: #0066cc;
      text-decoration: none;
      font-weight: 500;
    }

    body.dark-mode .message-file a {
      color: #66b3ff;
    }

    .file-info {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 5px;
    }

    .file-warning {
      font-size: 11px;
      font-style: italic;
      opacity: 0.7;
      margin-top: 5px;
      color: #856404;
    }

    body.dark-mode .file-warning {
      color: #ffc107;
    }

    .file-download-btn {
      display: inline-block;
      padding: 8px 16px;
      background: #0066cc;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      margin-top: 8px;
    }

    .file-download-btn:hover {
      background: #0052a3;
      transform: translateY(-1px);
    }

    body.dark-mode .file-download-btn {
      background: #3b82f6;
    }

    body.dark-mode .file-download-btn:hover {
      background: #2563eb;
    }

    .input-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .photo-composer {
      display: none;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
    }

    body.dark-mode .photo-composer {
      background: rgba(255, 255, 255, 0.1);
    }

    .photo-composer.active {
      display: block;
    }

    .composer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 14px;
      font-weight: 600;
      opacity: 0.8;
    }

    .composer-preview {
      display: flex;
      gap: 15px;
      align-items: flex-start;
    }

    .preview-image {
      max-width: 150px;
      max-height: 150px;
      border-radius: 8px;
      object-fit: cover;
    }

    .preview-details {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .preview-filename {
      font-size: 13px;
      font-weight: 500;
      word-break: break-all;
    }

    .preview-size {
      font-size: 12px;
      opacity: 0.7;
    }

    .btn-remove {
      background: #dc3545;
      color: white;
      padding: 8px 16px;
      font-size: 13px;
    }

    .btn-remove:hover {
      background: #c82333;
    }

    .message-sending {
      opacity: 0.6;
    }

    .message-error {
      border-left: 3px solid #dc3545;
    }

    .message-status {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 5px;
      font-style: italic;
    }

    .deleteBtn {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 10px;
      padding: 3px 6px;
      background: rgba(220, 53, 69, 0.9);
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 10;
      font-weight: 500;
    }

    /* Show delete button on hover for desktop */
    .message.own-message:hover .deleteBtn {
      opacity: 1;
    }

    /* Always show delete button on mobile/touch devices */
    @media (hover: none) and (pointer: coarse) {
      .deleteBtn {
        opacity: 0.7;
        position: static;
        display: inline-block;
        margin-top: 6px;
        margin-left: 8px;
      }
    }

    body.dark-mode .deleteBtn {
      background: rgba(220, 53, 69, 0.95);
      color: white;
    }

    .deleteBtn:hover {
      background: #dc3545;
      opacity: 1;
    }

    body.dark-mode .deleteBtn:hover {
      background: #ff6b6b;
    }

    .recording-indicator {
      background: rgba(220, 53, 69, 0.2);
      color: #dc3545;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
      display: none;
    }

    .recording-indicator.active {
      display: block;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .audio-draft {
      display: none;
      background: rgba(0, 102, 204, 0.1);
      border: 2px solid rgba(0, 102, 204, 0.3);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
    }

    body.dark-mode .audio-draft {
      background: rgba(102, 179, 255, 0.15);
      border-color: rgba(102, 179, 255, 0.3);
    }

    .audio-draft.active {
      display: block;
    }

    .audio-draft-header {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      opacity: 0.9;
    }

    .audio-draft-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .audio-draft audio {
      width: 100%;
      margin-bottom: 10px;
    }

    /* Rich text toolbar */
    .text-toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 10px;
      background: rgba(0, 0, 0, 0.03);
      border-radius: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
      overflow: hidden;
      max-height: 200px;
    }

    .text-toolbar.collapsed {
      max-height: 0;
      padding: 0 10px;
      opacity: 0;
      margin-bottom: 0;
    }

    body.dark-mode .text-toolbar {
      background: rgba(255, 255, 255, 0.05);
    }

    .toolbar-toggle {
      background: rgba(0, 0, 0, 0.05);
      border: 1px solid rgba(0, 0, 0, 0.1);
      padding: 4px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 11px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    body.dark-mode .toolbar-toggle {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .toolbar-toggle:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .toolbar-toggle:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .toolbar-toggle-icon {
      transition: transform 0.3s ease;
    }

    .toolbar-toggle-icon.expanded {
      transform: rotate(180deg);
    }

    .toolbar-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      background: rgba(255, 255, 255, 0.8);
      border-radius: 5px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }

    body.dark-mode .toolbar-btn {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      color: white;
    }

    .toolbar-btn:hover {
      background: rgba(0, 102, 204, 0.2);
      border-color: #0066cc;
    }

    .toolbar-btn.active {
      background: #0066cc;
      color: white;
      border-color: #0066cc;
    }

    .toolbar-select {
      padding: 6px 10px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      background: rgba(255, 255, 255, 0.8);
      border-radius: 5px;
      font-size: 13px;
      cursor: pointer;
    }

    body.dark-mode .toolbar-select {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      color: white;
    }

    .emoji-picker-container {
      position: relative;
      display: inline-block;
    }

    .emoji-panel {
      display: none;
      position: absolute;
      bottom: 100%;
      left: 0;
      background: white;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      max-width: 320px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
      margin-bottom: 8px;
    }

    body.dark-mode .emoji-panel {
      background: #003366;
      border-color: rgba(255, 255, 255, 0.2);
    }

    .emoji-panel.active {
      display: block;
    }

    .emoji-panel span {
      font-size: 24px;
      cursor: pointer;
      display: inline-block;
      padding: 5px;
      transition: transform 0.2s;
    }

    .emoji-panel span:hover {
      transform: scale(1.3);
    }

    .quick-emoji {
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 5px;
      transition: all 0.2s;
      display: inline-block;
    }

    .quick-emoji:hover {
      background: rgba(0, 0, 0, 0.1);
      transform: scale(1.2);
    }

    body.dark-mode .quick-emoji:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    #composer {
      flex: 1;
      padding: 12px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-family: inherit;
      min-height: 60px;
      max-height: 150px;
      overflow-y: auto;
      transition: all 0.3s ease;
    }

    body.dark-mode #composer {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    #composer:focus {
      outline: none;
      border-color: #0066cc;
    }

    body.dark-mode #composer:focus {
      border-color: #66b3ff;
    }

    #composer:empty:before {
      content: attr(data-placeholder);
      color: rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    body.dark-mode #composer:empty:before {
      color: rgba(255, 255, 255, 0.4);
    }

    .input-row {
      display: flex;
      gap: 10px;
    }

    input[type="text"],
    textarea {
      flex: 1;
      padding: 12px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-family: inherit;
      transition: all 0.3s ease;
    }

    body.dark-mode input[type="text"],
    body.dark-mode textarea {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    input[type="text"]:focus,
    textarea:focus {
      outline: none;
      border-color: #0066cc;
    }

    body.dark-mode input[type="text"]:focus,
    body.dark-mode textarea:focus {
      border-color: #66b3ff;
    }

    textarea {
      resize: vertical;
      min-height: 60px;
    }

    .message-controls {
      display: flex;
      gap: 10px;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: #0066cc;
      color: white;
      flex: 1;
    }

    .btn-primary:hover:not(:disabled) {
      background: #0052a3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
    }

    .btn-icon {
      background: rgba(0, 0, 0, 0.1);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
    }

    body.dark-mode .btn-icon {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .btn-icon:hover:not(:disabled) {
      background: rgba(0, 0, 0, 0.2);
      transform: scale(1.1);
    }

    body.dark-mode .btn-icon:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.3);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .sidebar h2 {
      font-size: 18px;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid rgba(0, 102, 204, 0.3);
    }

    .sidebar-content {
      font-size: 14px;
      line-height: 1.8;
      opacity: 0.8;
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      position: relative;
    }

    body.dark-mode .modal-content {
      background: #003366;
    }

    .modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.2);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    body.dark-mode .modal-close {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .camera-preview {
      max-width: 100%;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .camera-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .fullscreen-image {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 10px;
    }

    .status-message {
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
    }

    .status-error {
      background: rgba(220, 53, 69, 0.2);
      color: #dc3545;
    }

    .status-muted {
      background: rgba(255, 193, 7, 0.2);
      color: #856404;
    }

    body.dark-mode .status-muted {
      color: #ffc107;
    }

    .hidden {
      display: none;
    }

    input[type="file"] {
      display: none;
    }

    /* Toast notification for delete feedback */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
    }

    .toast.success {
      background: rgba(34, 197, 94, 0.9);
    }

    .toast.error {
      background: rgba(220, 53, 69, 0.9);
    }

    body.dark-mode .toast {
      background: rgba(0, 0, 0, 0.95);
    }

    /* Typing indicators */
    .typing-indicators {
      padding: 8px 12px;
      margin-bottom: 10px;
      font-size: 13px;
      font-style: italic;
      opacity: 0.7;
      min-height: 24px;
    }

    .typing-indicator {
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 0.7; }
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        border-left: none;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        max-height: 200px;
      }

      body.dark-mode .sidebar {
        border-top-color: rgba(255, 255, 255, 0.2);
      }
    }
  </style>
</head>
<body class="light-mode">
  <div class="container">
    <div class="main-content">
      <div class="header">
        <div style="display: flex; align-items: center; gap: 15px;">
          <h1>Kennedy Chat</h1>
          <div id="onlineBadge" style="display:flex;align-items:center;gap:8px;">
            <span id="onlineDot" style="width:10px;height:10px;border-radius:50%;background:#22c55e;display:inline-block;"></span>
            <span id="onlineCount">Online: 0</span>
          </div>
        </div>
        <button class="dark-mode-toggle" onclick="toggleDarkMode()">Dark Mode</button>
      </div>

      <div class="chat-container">
        <div class="messages" id="messages"></div>

        <!-- Typing indicators -->
        <div class="typing-indicators" id="typingIndicators"></div>

        <div id="statusMessage" class="hidden"></div>
        
        <div id="recordingIndicator" class="recording-indicator">
          Recording... <span id="recordingTimer">0s</span>
          <button class="btn-remove" onclick="stopAudioRecording()" style="margin-left: 10px;">Stop</button>
        </div>

        <!-- Audio Draft Composer -->
        <div id="audioDraft" class="audio-draft">
          <div class="audio-draft-header">Voice Message Draft</div>
          <audio id="audioDraftPlayer" controls></audio>
          <textarea 
            id="audioCaptionInput" 
            placeholder="Add a caption (optional, max 1000 chars)" 
            maxlength="1000"
            style="width: 100%; min-height: 50px; margin-bottom: 10px;"
          ></textarea>
          <div class="audio-draft-controls">
            <button class="btn-primary" onclick="sendAudioDraft()">Send</button>
            <button class="btn-remove" onclick="discardAudioDraft()">Discard</button>
          </div>
        </div>

        <div class="input-section">
          <input 
            type="text" 
            id="nickname" 
            placeholder="Your nickname (max 100 chars)" 
            maxlength="100"
            autocomplete="off"
          >
          
          <!-- Photo Composer Preview -->
          <div id="photoComposer" class="photo-composer">
            <div class="composer-header">
              <span>Photo Attached</span>
              <button class="btn-remove" onclick="removePhotoAttachment()">Remove</button>
            </div>
            <div class="composer-preview">
              <img id="previewImage" class="preview-image" src="" alt="Preview">
              <div class="preview-details">
                <div class="preview-filename" id="previewFilename"></div>
                <div class="preview-size" id="previewSize"></div>
              </div>
            </div>
          </div>

          <!-- Toolbar Toggle Button -->
          <button class="toolbar-toggle" onclick="toggleToolbar()" id="toolbarToggle">
            <span class="toolbar-toggle-icon" id="toolbarToggleIcon">‚ñº</span>
            <span>Formatting</span>
          </button>

          <!-- Rich Text Toolbar -->
          <div class="text-toolbar collapsed" id="textToolbar">
            <button class="toolbar-btn" onclick="formatText('bold')" title="Bold"><b>B</b></button>
            <button class="toolbar-btn" onclick="formatText('italic')" title="Italic"><i>I</i></button>
            <button class="toolbar-btn" onclick="formatText('underline')" title="Underline"><u>U</u></button>
            <select class="toolbar-select" onchange="setTextStyle(this.value)" id="styleSelect">
              <option value="">Style</option>
              <option value="monospace">Monospace</option>
            </select>
            
            <!-- Quick Emojis -->
            <span class="quick-emoji" onclick="insertEmojiQuick('‚ù§Ô∏è')" title="Heart">‚ù§Ô∏è</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üòÇ')" title="Laughing">üòÇ</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üò≠')" title="Crying">üò≠</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üëç')" title="Thumbs up">üëç</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üî•')" title="Fire">üî•</span>
            
            <!-- Emoji Picker Dropdown -->
            <div class="emoji-picker-container">
              <button class="toolbar-btn" onclick="toggleEmojiPicker()" title="More Emojis">üòä+</button>
              <div class="emoji-panel" id="emojiPanel">
                <span onclick="insertEmoji('üòÄ')">üòÄ</span>
                <span onclick="insertEmoji('üòÅ')">üòÅ</span>
                <span onclick="insertEmoji('üòÇ')">üòÇ</span>
                <span onclick="insertEmoji('ü§£')">ü§£</span>
                <span onclick="insertEmoji('üòä')">üòä</span>
                <span onclick="insertEmoji('üòá')">üòá</span>
                <span onclick="insertEmoji('üôÇ')">üôÇ</span>
                <span onclick="insertEmoji('üòâ')">üòâ</span>
                <span onclick="insertEmoji('üòç')">üòç</span>
                <span onclick="insertEmoji('ü•∞')">ü•∞</span>
                <span onclick="insertEmoji('üòò')">üòò</span>
                <span onclick="insertEmoji('üòã')">üòã</span>
                <span onclick="insertEmoji('üòé')">üòé</span>
                <span onclick="insertEmoji('ü§î')">ü§î</span>
                <span onclick="insertEmoji('üò¥')">üò¥</span>
                <span onclick="insertEmoji('üò¢')">üò¢</span>
                <span onclick="insertEmoji('üò≠')">üò≠</span>
                <span onclick="insertEmoji('üò°')">üò°</span>
                <span onclick="insertEmoji('ü§Ø')">ü§Ø</span>
                <span onclick="insertEmoji('üò±')">üò±</span>
                <span onclick="insertEmoji('üëç')">üëç</span>
                <span onclick="insertEmoji('üëé')">üëé</span>
                <span onclick="insertEmoji('üëè')">üëè</span>
                <span onclick="insertEmoji('üôè')">üôè</span>
                <span onclick="insertEmoji('üí™')">üí™</span>
                <span onclick="insertEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</span>
                <span onclick="insertEmoji('üíî')">üíî</span>
                <span onclick="insertEmoji('ü•Ä')">ü•Ä</span>
                <span onclick="insertEmoji('üî•')">üî•</span>
                <span onclick="insertEmoji('‚≠ê')">‚≠ê</span>
                <span onclick="insertEmoji('üéâ')">üéâ</span>
              </div>
            </div>
          </div>

          <div class="input-row">
            <div 
              id="composer" 
              contenteditable="true" 
              data-placeholder="Type your message (max 1000 chars)"
            ></div>
          </div>
          <div class="message-controls">
            <button class="btn-icon" onclick="openCamera()" title="Take Photo" id="cameraBtn">
              Camera
            </button>
            <button class="btn-icon" onclick="document.getElementById('fileInput').click()" title="Upload File" id="fileBtn">
              File
            </button>
            <button class="btn-icon" onclick="toggleAudioRecording()" title="Record Audio" id="audioBtn">
              Audio Message
            </button>
            <button class="btn-primary" onclick="sendMessage()" id="sendBtn">Send</button>
          </div>
          <input type="file" id="fileInput" onchange="handleFileSelect()">
        </div>
      </div>
    </div>

    <div class="sidebar">
      <h2 style="font-size: 22px; font-weight: 700;">Rules</h2>
      <div class="sidebar-content" style="margin-bottom: 25px;">
        <p>No spamming (max 2 messages per 10s). Violators face escalating bans: 15s ‚Üí 1m ‚Üí 5m ‚Üí +5m each time.</p>
      </div>
      
      <h2 style="font-size: 22px; font-weight: 700;">Features</h2>
      <div class="sidebar-content">
        <ul style="list-style: disc; padding-left: 20px; line-height: 2;">
          <li>No moderators or login needed</li>
          <li>Rich text formatting + emojis</li>
          <li>Photo and GIF uploads</li>
          <li>Voice messages (up to 30s)</li>
          <li>Delete your own messages</li>
          <li>Typing indicators</li>
          <li>Online users count</li>
          <li>Dark Mode</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Camera Modal -->
  <div id="cameraModal" class="modal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeCamera()">√ó</button>
      <h2 style="margin-bottom: 20px;">Take a Photo</h2>
      <video id="cameraPreview" class="camera-preview" autoplay playsinline></video>
      <canvas id="cameraCanvas" style="display: none;"></canvas>
      <div class="camera-controls">
        <button class="btn-primary" onclick="capturePhoto()">Capture</button>
        <button onclick="closeCamera()" style="background: #6c757d; color: white;">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Image Preview Modal -->
  <div id="imageModal" class="modal" onclick="closeImagePreview()">
    <div class="modal-content" onclick="event.stopPropagation()">
      <button class="modal-close" onclick="closeImagePreview()">√ó</button>
      <img id="fullscreenImage" class="fullscreen-image" src="" alt="Full size image">
    </div>
  </div>

  <!-- Toast notification -->
  <div id="toast" class="toast"></div>

  <script>
    let ws;
    let reconnectTimeout;
    let muteTimer;
    let cameraStream;
    const isDarkMode = localStorage.getItem('darkMode') === 'true';

    // DEBUG flag for delete feature troubleshooting
    const DEBUG_DELETE = true; // Set to false in production

    // Client state - persist in sessionStorage to survive refreshes
    let myClientId = sessionStorage.getItem('myClientId') || null;
    let isVisible = !document.hidden;
    
    // Log client identity on startup
    if (myClientId) {
      console.log('[STARTUP] Restored myClientId from session:', myClientId);
    } else {
      console.log('[STARTUP] No existing client identity, will receive from server');
    }

    // Photo composer state
    let selectedFile = null;
    let previewURL = null;
    let pendingMessages = new Map(); // Map of client message ID to message data

    // Audio recording state
    let recorder = null;
    let audioStream = null;
    let audioChunks = [];
    let recordTimer = null;
    let recordingStartTime = 0;
    let audioDraftBlob = null;
    let audioDraftURL = null;

    // Typing indicator state
    let typingUsers = new Map(); // senderId -> { nickname, lastTs }
    let typingTimeout = null;
    let lastTypingSent = 0;
    const TYPING_THROTTLE = 800; // ms
    const TYPING_EXPIRE = 12000; // 12 seconds

    // Apply saved theme
    if (isDarkMode) {
      document.body.className = 'dark-mode';
      document.querySelector('.dark-mode-toggle').textContent = 'Light Mode';
    }

    // ========================================
    // TOKEN MANAGEMENT (Feature 2)
    // ========================================
    
    function getOrCreateToken() {
      // Try cookie first
      let token = getCookie('chat_token');
      
      // Fall back to localStorage
      if (!token) {
        token = localStorage.getItem('chat_token');
      }
      
      // Generate new token if none exists
      if (!token) {
        token = generateUUID();
        console.log('[TOKEN] Generated new token:', token);
      }
      
      // Store in both places
      setCookie('chat_token', token, 31536000); // 1 year
      localStorage.setItem('chat_token', token);
      
      return token;
    }

    // Initialize token on page load
    clientToken = getOrCreateToken();
    console.log('[TOKEN] Using client token:', clientToken);

    // WebSocket configuration
    const WS_URL = `wss://ws.ldawg7624.com?token=${encodeURIComponent(clientToken)}`;
    
    // Upload configuration
    const UPLOAD_URL = 'https://upload.ldawg7624.com/upload';

    // Ban state management
    function getCookie(name) {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
      return null;
    }

    function setCookie(name, value, maxAgeSeconds) {
      document.cookie = `${name}=${value}; path=/; max-age=${maxAgeSeconds}; SameSite=Lax; Secure`;
    }

    function getBanState() {
      // Check both localStorage and cookie
      const lsBanUntil = localStorage.getItem('chatBanUntil');
      const cookieBanUntil = getCookie('chatBanUntil');
      
      const banUntil = Math.max(
        lsBanUntil ? parseInt(lsBanUntil, 10) : 0,
        cookieBanUntil ? parseInt(cookieBanUntil, 10) : 0
      );
      
      return banUntil > Date.now() ? banUntil : null;
    }

    function setBanState(untilEpochMs) {
      const secondsRemaining = Math.ceil((untilEpochMs - Date.now()) / 1000);
      localStorage.setItem('chatBanUntil', untilEpochMs.toString());
      setCookie('chatBanUntil', untilEpochMs.toString(), secondsRemaining + 10);
    }

    function clearBanState() {
      localStorage.removeItem('chatBanUntil');
      setCookie('chatBanUntil', '', -1);
    }

    function checkAndApplyBanState() {
      const banUntil = getBanState();
      if (banUntil) {
        const secondsRemaining = Math.ceil((banUntil - Date.now()) / 1000);
        if (secondsRemaining > 0) {
          showBanMessage(banUntil);
          disableInputs(true);
          
          // Set timer to clear ban when it expires
          setTimeout(() => {
            clearBanState();
            disableInputs(false);
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.classList.add('hidden');
          }, secondsRemaining * 1000);
        } else {
          clearBanState();
        }
      }
    }

    function showBanMessage(untilEpochMs) {
      const statusDiv = document.getElementById('statusMessage');
      statusDiv.className = 'status-message status-error';
      
      function updateCountdown() {
        const remaining = Math.ceil((untilEpochMs - Date.now()) / 1000);
        if (remaining > 0) {
          const hours = Math.floor(remaining / 3600);
          const minutes = Math.floor((remaining % 3600) / 60);
          const seconds = remaining % 60;
          const timeStr = hours > 0 
            ? `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
            : `${minutes}:${seconds.toString().padStart(2, '0')}`;
          statusDiv.textContent = `Temporarily blocked until ${timeStr}`;
          setTimeout(updateCountdown, 1000);
        } else {
          statusDiv.classList.add('hidden');
          disableInputs(false);
          clearBanState();
        }
      }
      
      statusDiv.classList.remove('hidden');
      updateCountdown();
    }

    // Check ban state on page load
    checkAndApplyBanState();

    // Initialize toolbar state on page load
    window.addEventListener('DOMContentLoaded', initToolbarState);

    // Generate UUID v4
    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    // ========================================
    // HTML SANITIZATION (Feature 1)
    // ========================================
    
    function sanitizeHTML(html) {
      const div = document.createElement('div');
      div.innerHTML = html;
      
      // Allowed tags and attributes
      const allowedTags = ['B', 'STRONG', 'I', 'EM', 'U', 'BR', 'SPAN'];
      const allowedStyles = ['font-family', 'background', 'padding', 'border-radius'];
      
      function sanitizeNode(node) {
        // Text nodes are OK
        if (node.nodeType === 3) return true;
        
        // Element nodes must be in allowed list
        if (node.nodeType === 1) {
          if (!allowedTags.includes(node.tagName)) {
            return false;
          }
          
          // For SPAN, check style attribute
          if (node.tagName === 'SPAN') {
            const style = node.getAttribute('style');
            if (style) {
              // Parse and validate style
              const newStyle = [];
              const parts = style.split(';');
              for (const part of parts) {
                const [prop, value] = part.split(':').map(s => s.trim());
                if (allowedStyles.includes(prop)) {
                  if (prop === 'font-family') {
                    // Only allow monospace
                    if (value === 'monospace') {
                      newStyle.push(`${prop}: ${value}`);
                    }
                  } else if (prop === 'background') {
                    // Allow only rgba backgrounds
                    if (value.startsWith('rgba(')) {
                      newStyle.push(`${prop}: ${value}`);
                    }
                  } else if (prop === 'padding' || prop === 'border-radius') {
                    // Allow basic padding and border-radius
                    newStyle.push(`${prop}: ${value}`);
                  }
                }
              }
              node.setAttribute('style', newStyle.join('; '));
            }
            
            // Remove all other attributes
            const attrs = Array.from(node.attributes);
            for (const attr of attrs) {
              if (attr.name !== 'style') {
                node.removeAttribute(attr.name);
              }
            }
          } else {
            // Remove all attributes from other tags
            const attrs = Array.from(node.attributes);
            for (const attr of attrs) {
              node.removeAttribute(attr.name);
            }
          }
          
          return true;
        }
        
        return false;
      }
      
      function walk(node) {
        const children = Array.from(node.childNodes);
        for (const child of children) {
          if (!sanitizeNode(child)) {
            // Replace disallowed node with its text content
            const text = document.createTextNode(child.textContent);
            node.replaceChild(text, child);
          } else if (child.nodeType === 1) {
            walk(child);
          }
        }
      }
      
      walk(div);
      return div.innerHTML;
    }

    // ========================================
    // FILE UPLOAD VALIDATION
    // ========================================
    
    const BLOCKED_EXTENSIONS = [
      '.exe', '.msi', '.bat', '.cmd', '.com', '.scr', '.ps1', 
      '.vbs', '.js', '.jar', '.app', '.dmg', '.sh', '.deb', 
      '.rpm', '.apk', '.ipa'
    ];

    function isDangerousFile(filename) {
      const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
      return BLOCKED_EXTENSIONS.includes(ext);
    }

    function getFileExtension(filename) {
      return filename.substring(filename.lastIndexOf('.')).toLowerCase();
    }

    function isImageFile(filename, mime) {
      const imageExts = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
      const ext = getFileExtension(filename);
      return imageExts.includes(ext) || (mime && mime.startsWith('image/'));
    }

    function isAudioFile(filename, mime) {
      const audioExts = ['.mp3', '.wav', '.ogg', '.webm', '.m4a', '.aac'];
      const ext = getFileExtension(filename);
      return audioExts.includes(ext) || (mime && mime.startsWith('audio/'));
    }

    // ========================================
    // RICH TEXT EDITOR (Feature 1)
    // ========================================
    
    // Initialize toolbar state from sessionStorage
    function initToolbarState() {
      const toolbarExpanded = sessionStorage.getItem('toolbarExpanded') === 'true';
      const toolbar = document.getElementById('textToolbar');
      const toggleIcon = document.getElementById('toolbarToggleIcon');
      
      if (toolbarExpanded) {
        toolbar.classList.remove('collapsed');
        toggleIcon.classList.add('expanded');
      }
    }

    // Toggle toolbar collapsed/expanded state
    function toggleToolbar() {
      const toolbar = document.getElementById('textToolbar');
      const toggleIcon = document.getElementById('toolbarToggleIcon');
      const isCollapsed = toolbar.classList.contains('collapsed');
      
      if (isCollapsed) {
        toolbar.classList.remove('collapsed');
        toggleIcon.classList.add('expanded');
        sessionStorage.setItem('toolbarExpanded', 'true');
      } else {
        toolbar.classList.add('collapsed');
        toggleIcon.classList.remove('expanded');
        sessionStorage.setItem('toolbarExpanded', 'false');
      }
    }
    
    function formatText(command) {
      document.execCommand(command, false, null);
      document.getElementById('composer').focus();
    }

    function setTextStyle(style) {
      if (!style) return;
      
      const composer = document.getElementById('composer');
      const selection = window.getSelection();
      
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const span = document.createElement('span');
      
      if (style === 'monospace') {
        span.style.fontFamily = 'monospace';
        span.style.background = 'rgba(0, 0, 0, 0.05)';
        span.style.padding = '2px 4px';
        span.style.borderRadius = '3px';
      }
      
      try {
        range.surroundContents(span);
      } catch (e) {
        span.appendChild(range.extractContents());
        range.insertNode(span);
      }
      
      composer.focus();
      
      // Reset selector
      document.getElementById('styleSelect').value = '';
    }

    function toggleEmojiPicker() {
      const panel = document.getElementById('emojiPanel');
      panel.classList.toggle('active');
    }

    function insertEmoji(emoji) {
      const composer = document.getElementById('composer');
      composer.focus();
      document.execCommand('insertText', false, emoji);
      toggleEmojiPicker();
    }

    function insertEmojiQuick(emoji) {
      const composer = document.getElementById('composer');
      composer.focus();
      document.execCommand('insertText', false, emoji);
    }

    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
      const emojiContainer = document.querySelector('.emoji-picker-container');
      if (emojiContainer && !emojiContainer.contains(e.target)) {
        document.getElementById('emojiPanel').classList.remove('active');
      }
    });

    function getComposerHTML() {
      const composer = document.getElementById('composer');
      return sanitizeHTML(composer.innerHTML);
    }

    function getComposerText() {
      const composer = document.getElementById('composer');
      return composer.textContent || composer.innerText || '';
    }

    function clearComposer() {
      const composer = document.getElementById('composer');
      composer.innerHTML = '';
    }

    // ========================================
    // TYPING INDICATOR (Feature 3)
    // ========================================
    
    function sendTypingStatus(isTyping) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      
      const nickname = (document.getElementById('nickname').value.trim() || 'Anonymous').substring(0, 100);
      
      ws.send(JSON.stringify({
        type: 'typing',
        nickname,
        isTyping: !!isTyping,
        ts: Date.now()
      }));
    }

    function handleComposerInput() {
      const text = getComposerText().trim();
      const now = Date.now();
      
      if (text.length > 0) {
        // Throttle typing events
        if (now - lastTypingSent >= TYPING_THROTTLE) {
          sendTypingStatus(true);
          lastTypingSent = now;
        }
      } else {
        // Empty composer, send stop typing
        sendTypingStatus(false);
        lastTypingSent = 0;
      }
    }

    function updateTypingIndicators() {
      const now = Date.now();
      const container = document.getElementById('typingIndicators');
      
      // Remove expired entries
      for (const [senderId, info] of typingUsers) {
        if (now - info.lastTs > TYPING_EXPIRE) {
          typingUsers.delete(senderId);
        }
      }
      
      // Render
      const count = typingUsers.size;
      
      if (count === 0) {
        container.textContent = '';
      } else if (count <= 3) {
        const names = Array.from(typingUsers.values()).map(u => u.nickname);
        container.textContent = names.map(n => `${n} is typing...`).join(' ‚Ä¢ ');
      } else {
        container.textContent = 'Several people are typing...';
      }
    }

    // Set up typing detection
    document.getElementById('composer').addEventListener('input', handleComposerInput);
    document.getElementById('composer').addEventListener('blur', () => {
      sendTypingStatus(false);
    });

    // Auto-clean typing indicators every 1s
    setInterval(updateTypingIndicators, 1000);

    // ========================================
    // PRESENCE & ONLINE COUNT
    // ========================================
    
    function sendPresence(online) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "presence", online: !!online, ts: Date.now() }));
      }
    }

    // Set up visibility tracking
    document.addEventListener("visibilitychange", () => {
      isVisible = !document.hidden;
      sendPresence(isVisible);
    });

    window.addEventListener("focus", () => sendPresence(true));
    window.addEventListener("blur", () => sendPresence(false));

    // Online count display
    function setOnlineCount(n) {
      document.getElementById("onlineCount").textContent = `Online: ${n}`;
    }

    // ========================================
    // WEBSOCKET CONNECTION
    // ========================================
    
    function connect() {
      console.log('========================================');
      console.log('[CONNECT] Attempting WebSocket connection');
      console.log('[CONNECT] URL:', WS_URL);
      console.log('[CONNECT] Token:', clientToken);
      console.log('========================================');
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log('========================================');
        console.log('[CONNECT] ‚úì WebSocket connection OPEN');
        console.log('========================================');
        clearTimeout(reconnectTimeout);
        
        // Send initial presence
        sendPresence(isVisible);
        
        // Send a ping to verify ACK path works
        const pingId = generateUUID();
        const pingMessage = {
          type: 'ping',
          id: pingId,
          messageId: pingId,
          timestamp: Date.now()
        };
        
        console.log('[SELF-TEST] Sending ping with id=' + pingId);
        pendingMessages.set(pingId, { type: 'ping', testPing: true });
        
        const pingTimeout = setTimeout(() => {
          if (pendingMessages.has(pingId)) {
            console.error('[SELF-TEST] ‚ùå FAILED - No ACK received for ping');
            showStatus('Connected but ACK path not working', 'error');
            pendingMessages.delete(pingId);
          }
        }, 3000);
        
        pendingMessages.get(pingId).timeout = pingTimeout;
        ws.send(JSON.stringify(pingMessage));
      };

      ws.onmessage = (event) => {
        console.log('[WS] RX:', event.data);
        const data = JSON.parse(event.data);
        
        if (data.type === 'welcome') {
          // If we already have a session clientId, keep using it (for ownership persistence)
          // Otherwise, accept the new one from the server
          if (!myClientId) {
            myClientId = data.clientId;
            sessionStorage.setItem('myClientId', myClientId);
            console.log('[WELCOME] New myClientId assigned:', myClientId);
          } else {
            console.log('[WELCOME] Using existing myClientId from session:', myClientId);
            console.log('[WELCOME] Server offered:', data.clientId, '(ignored for ownership continuity)');
          }
          
          // If server sent us a token, store it
          if (data.token && data.token !== clientToken) {
            clientToken = data.token;
            setCookie('chat_token', clientToken, 31536000);
            localStorage.setItem('chat_token', clientToken);
            console.log('[TOKEN] Received token from server:', clientToken);
          }
          
          refreshDeleteButtons();
        } else if (data.type === 'online') {
          setOnlineCount(data.count);
        } else if (data.type === 'history') {
          console.log('[WS] History received with', data.items.length, 'items');
          displayHistory(data.items);
        } else if (data.type === 'delete') {
          if (DEBUG_DELETE) {
            console.log('========================================');
            console.log('[DELETE] üì° Received delete broadcast from server');
            console.log('[DELETE] Message ID to delete:', data.id);
          }
          removeMessageFromUI(data.id);
        } else if (data.type === 'typing') {
          // Update typing indicator
          if (data.senderId !== myClientId) {
            if (data.isTyping) {
              typingUsers.set(data.senderId, {
                nickname: data.nickname,
                lastTs: data.ts || Date.now()
              });
            } else {
              typingUsers.delete(data.senderId);
            }
            updateTypingIndicators();
          }
        } else if (data.type === 'ack') {
          const ackId = data.messageId || data.id;
          console.log('[WS] ‚úì ACK RECEIVED for id=' + ackId);
          
          if (!ackId) return;
          
          const pendingMsg = pendingMessages.get(ackId);
          if (pendingMsg && pendingMsg.testPing) {
            console.log('[SELF-TEST] ‚úì Ping ACK received');
            if (pendingMsg.timeout) clearTimeout(pendingMsg.timeout);
            pendingMessages.delete(ackId);
            showStatus('Connected ‚úì', 'success');
            return;
          }
          
          const msgElement = document.querySelector(`[data-msg-id="${ackId}"]`);
          if (msgElement) {
            msgElement.classList.remove('message-sending');
            msgElement.classList.add('message-sent');
            const statusSpan = msgElement.querySelector('.message-status');
            if (statusSpan) {
              statusSpan.textContent = 'Sent ‚úì';
              setTimeout(() => statusSpan.remove(), 2000);
            }
          }
        } else if (data.type === 'text' || data.type === 'image' || data.type === 'audio' || data.type === 'file') {
          if (pendingMessages.has(data.id)) {
            console.log('[WS] Received broadcast of our own message id=' + data.id);
            const msgElement = document.querySelector(`[data-msg-id="${data.id}"]`);
            if (msgElement && data.type === 'image') {
              const img = msgElement.querySelector('.message-image');
              if (img && data.url) {
                img.src = data.url;
                img.onclick = () => openImagePreview(data.url);
              }
            }
            pendingMessages.delete(data.id);
          } else {
            console.log('[WS] New message from another client');
            addMessage(data);
          }
        } else if (data.type === 'banned') {
          handleBanned(data);
        } else if (data.type === 'muted') {
          handleBanned({
            type: 'banned',
            until: data.until || (Date.now() + data.seconds * 1000),
            seconds: data.seconds,
            reason: 'rate'
          });
        }
      };

      ws.onclose = (event) => {
        console.log('[CLOSE] WebSocket connection closed');
        showStatus('Disconnected. Reconnecting...', 'error');
        reconnectTimeout = setTimeout(connect, 3000);
      };

      ws.onerror = (error) => {
        console.error('[ERROR] WebSocket error:', error);
        showStatus('Connection error', 'error');
      };
    }

    function showStatus(message, type) {
      const statusDiv = document.getElementById('statusMessage');
      statusDiv.className = `status-message ${type === 'error' ? 'status-error' : 'status-muted'}`;
      statusDiv.textContent = message;
      statusDiv.classList.remove('hidden');
      
      if (type === 'success') {
        setTimeout(() => {
          statusDiv.classList.add('hidden');
        }, 2000);
      }
    }

    function showToast(message, type = 'success') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${type} show`;
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, 2500);
    }

    function handleBanned(data) {
      const untilEpochMs = data.until || (Date.now() + (data.seconds || 0) * 1000);
      
      // Persist ban state
      setBanState(untilEpochMs);
      
      // Show ban message
      showBanMessage(untilEpochMs);
      
      // Disable inputs
      disableInputs(true);
      
      // Re-enable after ban period
      const secondsRemaining = Math.ceil((untilEpochMs - Date.now()) / 1000);
      setTimeout(() => {
        clearBanState();
        disableInputs(false);
        const statusDiv = document.getElementById('statusMessage');
        statusDiv.classList.add('hidden');
      }, secondsRemaining * 1000);
    }

    connect();

    // ========================================
    // MESSAGE DISPLAY
    // ========================================
    
    function displayHistory(items) {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.innerHTML = '';
      const displayItems = items.slice(-100);
      displayItems.forEach(item => addMessage(item, false));
      scrollToBottom();
    }

    function addMessage(data, scroll = true, messageId = null, status = 'sent') {
      const messagesDiv = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      
      if (status === 'sending') {
        messageDiv.classList.add('message-sending');
      } else if (status === 'error') {
        messageDiv.classList.add('message-error');
      }
      
      if (messageId || data.id) {
        messageDiv.setAttribute('data-msg-id', messageId || data.id);
      }
      
      if (data.senderId) {
        messageDiv.setAttribute('data-sender-id', data.senderId);
      }

      const timestamp = new Date(data.timestamp).toLocaleString();
      
      // Check if this is our own message (can delete + color green)
      const isOwnMessage = data.senderId && myClientId && data.senderId === myClientId;
      
      // Apply color classes based on ownership
      if (isOwnMessage) {
        messageDiv.classList.add('own-message');
      } else if (data.senderId) {
        // Only add 'other-message' if there's a senderId (not system messages)
        messageDiv.classList.add('other-message');
      }
      
      // Dev-only logging for ownership debugging (always enabled for now)
      console.log('[RENDER] üîç Ownership Check:', {
        messageId: data.id,
        senderId: data.senderId,
        myClientId: myClientId,
        isOwnMessage: isOwnMessage,
        canDelete: isOwnMessage && status === 'sent',
        colorClass: isOwnMessage ? 'GREEN' : 'BLUE'
      });
      
      let content = '';
      if (data.type === 'text') {
        // Prefer HTML if present, else text
        const displayContent = data.html ? sanitizeHTML(data.html) : escapeHtml(data.text);
        content = `<div class="message-content">${displayContent}</div>`;
      } else if (data.type === 'image') {
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        const imgId = 'img-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        content = `
          ${caption}
          <img id="${imgId}" src="${data.url}" class="message-image" data-url="${data.url}" alt="${escapeHtml(data.filename || 'Image')}">
        `;
      } else if (data.type === 'audio') {
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        const label = caption ? '' : '<div class="message-content">Voice message</div>';
        content = `
          ${caption || label}
          <audio controls src="${data.url}" style="max-width: 100%; margin-top: 8px;"></audio>
        `;
      } else if (data.type === 'file') {
        const sizeStr = formatFileSize(data.size);
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        content = `
          ${caption || '<div class="message-content">Shared a file</div>'}
          <div class="message-file">
            <div style="font-weight: 600; margin-bottom: 8px;">${escapeHtml(data.filename)}</div>
            <div class="file-info">${sizeStr} ¬∑ ${data.mime || 'unknown'}</div>
            <a href="${data.url}" download="${escapeHtml(data.filename)}" class="file-download-btn">Download File</a>
            <div class="file-warning">‚ö†Ô∏è This site does not scan files for malicious content. Only download files you trust.</div>
          </div>
        `;
      }
      
      let statusHTML = '';
      if (status === 'sending') {
        statusHTML = '<div class="message-status">Sending...</div>';
      } else if (status === 'error') {
        statusHTML = '<div class="message-status">Failed to send</div>';
      }

      let deleteButtonHTML = '';
      if (isOwnMessage && status === 'sent') {
        deleteButtonHTML = `<button class="deleteBtn" onclick="deleteMessage('${data.id}')" title="Delete this message">Delete</button>`;
        
        if (DEBUG_DELETE) {
          console.log('[RENDER] ‚úì Added delete button for message:', data.id);
        }
      }

      messageDiv.innerHTML = `
        <div class="message-header">
          <span class="nickname">${escapeHtml(data.nickname)}</span>
          <span class="timestamp">${timestamp}</span>
        </div>
        ${content}
        ${statusHTML}
        ${deleteButtonHTML}
      `;

      messagesDiv.appendChild(messageDiv);
      
      if (data.type === 'image') {
        const imgId = 'img-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        const imgElement = document.getElementById(imgId);
        if (imgElement) {
          imgElement.addEventListener('click', function() {
            openImagePreview(this.src);
          });
        }
      }
      
      if (scroll) {
        scrollToBottom();
      }
      
      return messageDiv;
    }

    function deleteMessage(msgId) {
      if (DEBUG_DELETE) {
        console.log('========================================');
        console.log('[DELETE] üóëÔ∏è  Delete button clicked');
        console.log('[DELETE] Message ID:', msgId);
        console.log('[DELETE] My Client ID:', myClientId);
        console.log('[DELETE] WebSocket state:', ws ? ws.readyState : 'no ws');
      }
      
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        if (DEBUG_DELETE) {
          console.error('[DELETE] ‚ùå Cannot delete - WebSocket not connected');
          console.log('========================================');
        }
        showToast('Cannot delete - not connected', 'error');
        return;
      }
      
      // Find the message to verify ownership
      const msgElement = document.querySelector(`[data-msg-id="${msgId}"]`);
      if (msgElement) {
        const senderId = msgElement.getAttribute('data-sender-id');
        if (DEBUG_DELETE) {
          console.log('[DELETE] Found message element');
          console.log('[DELETE] Message senderId:', senderId);
          console.log('[DELETE] Ownership match:', senderId === myClientId);
        }
        
        if (senderId !== myClientId) {
          if (DEBUG_DELETE) {
            console.error('[DELETE] ‚ùå Ownership mismatch - cannot delete');
            console.log('========================================');
          }
          showToast('Cannot delete - not your message', 'error');
          return;
        }
      }
      
      const deletePayload = { type: "delete", id: msgId };
      ws.send(JSON.stringify(deletePayload));
      
      if (DEBUG_DELETE) {
        console.log('[DELETE] ‚úì Delete request sent to server');
        console.log('[DELETE] Payload:', JSON.stringify(deletePayload));
        console.log('========================================');
      }
      
      // Optimistic UI update
      const elem = document.querySelector(`[data-msg-id="${msgId}"]`);
      if (elem) {
        elem.style.opacity = '0.5';
        elem.style.pointerEvents = 'none';
      }
    }

    function removeMessageFromUI(msgId) {
      if (DEBUG_DELETE) {
        console.log('========================================');
        console.log('[DELETE] üóëÔ∏è  Removing message from UI');
        console.log('[DELETE] Message ID:', msgId);
      }
      
      const msgElement = document.querySelector(`[data-msg-id="${msgId}"]`);
      if (msgElement) {
        // Check if this was our own message
        const senderId = msgElement.getAttribute('data-sender-id');
        const wasOwnMessage = senderId === myClientId;
        
        msgElement.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
          msgElement.remove();
          if (DEBUG_DELETE) {
            console.log('[DELETE] ‚úì Message removed from DOM');
            console.log('========================================');
          }
          
          // Show toast only if it was our own message being deleted
          if (wasOwnMessage) {
            showToast('Message deleted', 'success');
          }
        }, 300);
      } else {
        if (DEBUG_DELETE) {
          console.warn('[DELETE] ‚ö†Ô∏è  Message element not found in DOM');
          console.log('========================================');
        }
      }
    }

    // Refresh delete buttons and colors after myClientId is set/restored
    function refreshDeleteButtons() {
      if (!myClientId) {
        if (DEBUG_DELETE) {
          console.log('[REFRESH] ‚ö†Ô∏è  Skipping refresh - no myClientId yet');
        }
        return;
      }
      
      console.log('[REFRESH] üîÑ Refreshing ownership UI with myClientId:', myClientId);
      
      const allMessages = document.querySelectorAll('[data-msg-id]');
      let buttonCount = 0;
      let colorCount = 0;
      let ownMessageCount = 0;
      
      allMessages.forEach(msgElement => {
        const msgId = msgElement.getAttribute('data-msg-id');
        const senderId = msgElement.getAttribute('data-sender-id');
        
        if (!senderId) return; // Skip messages without senderId
        
        const isOwnMessage = senderId === myClientId;
        
        if (isOwnMessage) ownMessageCount++;
        
        // Apply color classes if not already applied
        if (isOwnMessage && !msgElement.classList.contains('own-message')) {
          msgElement.classList.remove('other-message');
          msgElement.classList.add('own-message');
          colorCount++;
        } else if (!isOwnMessage && !msgElement.classList.contains('other-message')) {
          msgElement.classList.remove('own-message');
          msgElement.classList.add('other-message');
          colorCount++;
        }
        
        // Add delete button if this is our message and button doesn't exist
        if (isOwnMessage) {
          const existingDeleteBtn = msgElement.querySelector('.deleteBtn');
          const canDelete = !msgElement.classList.contains('message-sending') && 
                           !msgElement.classList.contains('message-error');
          
          if (canDelete && !existingDeleteBtn) {
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'deleteBtn';
            deleteBtn.textContent = 'Delete';
            deleteBtn.title = 'Delete this message';
            deleteBtn.onclick = () => deleteMessage(msgId);
            msgElement.appendChild(deleteBtn);
            buttonCount++;
            if (DEBUG_DELETE) {
              console.log('[REFRESH] ‚úì Added delete button to message:', msgId);
            }
          }
        }
      });
      
      console.log('[REFRESH] ‚úì Found', ownMessageCount, 'own messages');
      console.log('[REFRESH] ‚úì Applied colors to', colorCount, 'messages');
      console.log('[REFRESH] ‚úì Added', buttonCount, 'delete buttons');
    }

    // ========================================
    // SEND MESSAGE (Updated for Feature 1)
    // ========================================
    
    async function sendMessage() {
      const nicknameInput = document.getElementById('nickname');
      const html = getComposerHTML();
      const text = getComposerText().trim();

      if (!text && !selectedFile) {
        return;
      }

      if (ws.readyState !== WebSocket.OPEN) {
        showStatus('Not connected. Please wait...', 'error');
        return;
      }

      const banUntil = getBanState();
      if (banUntil && banUntil > Date.now()) {
        showStatus('You are temporarily blocked from sending messages', 'error');
        return;
      }

      const nickname = (nicknameInput.value.trim() || 'Anonymous').substring(0, 100);
      const messageId = generateUUID();
      const timestamp = Date.now();

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      // Stop typing indicator
      sendTypingStatus(false);

      try {
        if (selectedFile) {
          // File upload flow
          console.log('[SEND] Uploading file with caption:', text.substring(0, 50));
          
          // Determine if it's an image, audio, or generic file
          const isImage = isImageFile(selectedFile.name, selectedFile.type);
          const isAudio = isAudioFile(selectedFile.name, selectedFile.type);
          const fileType = isImage ? 'image' : (isAudio ? 'audio' : 'file');
          
          const optimisticData = {
            type: fileType,
            id: messageId,
            nickname,
            timestamp,
            url: previewURL,
            filename: selectedFile.name,
            caption: text || '',
            size: selectedFile.size,
            mime: selectedFile.type,
            senderId: myClientId
          };
          
          const msgElement = addMessage(optimisticData, true, messageId, 'sending');
          pendingMessages.set(messageId, optimisticData);
          
          const ackTimeout = setTimeout(() => {
            if (pendingMessages.has(messageId)) {
              const elem = document.querySelector(`[data-msg-id="${messageId}"]`);
              if (elem) {
                elem.classList.remove('message-sending');
                elem.classList.add('message-error');
                const statusSpan = elem.querySelector('.message-status');
                if (statusSpan) {
                  statusSpan.textContent = 'Failed to send (timeout)';
                }
              }
              pendingMessages.delete(messageId);
            }
          }, 5000);
          
          clearComposer();
          
          const fileToUpload = selectedFile;
          const formData = new FormData();
          formData.append('file', fileToUpload);
          
          const response = await fetch(UPLOAD_URL, {
            method: 'POST',
            body: formData
          });
          
          if (!response.ok) {
            clearTimeout(ackTimeout);
            const errorText = await response.text();
            let errorMessage = `Upload failed: ${response.status}`;
            try {
              const errorJson = JSON.parse(errorText);
              errorMessage = errorJson.error || errorMessage;
            } catch (e) {}
            throw new Error(errorMessage);
          }

          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('[UPLOAD] Error - expected JSON but got:', text.substring(0, 200));
            throw new Error('Server returned non-JSON response');
          }

          const result = await response.json();

          if (result.success || result.ok) {
            const wsMessage = {
              type: fileType,
              id: messageId,
              messageId: messageId,
              nickname,
              timestamp,
              url: result.url,
              filename: result.filename || result.name,
              mime: result.mime,
              size: result.size,
              caption: text || ''
            };
            
            ws.send(JSON.stringify(wsMessage));
            
            removePhotoAttachment();
            
            if (msgElement) {
              if (fileType === 'image') {
                const img = msgElement.querySelector('.message-image');
                if (img) {
                  img.src = result.url;
                  img.setAttribute('data-url', result.url);
                }
              } else if (fileType === 'audio') {
                const audio = msgElement.querySelector('audio');
                if (audio) {
                  audio.src = result.url;
                }
              }
            }
          } else {
            clearTimeout(ackTimeout);
            throw new Error(result.error || 'Upload failed');
          }
        } else {
          // Text message with rich formatting
          console.log('[SEND] Sending text message with formatting');
          
          const messageData = {
            type: 'text',
            id: messageId,
            messageId: messageId,
            nickname,
            timestamp,
            html: html,
            text: text.substring(0, 1000),
            senderId: myClientId
          };
          
          addMessage(messageData, true, messageId, 'sending');
          pendingMessages.set(messageId, messageData);
          
          setTimeout(() => {
            if (pendingMessages.has(messageId)) {
              console.error('[SEND] ACK timeout for message:', messageId);
              const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
              if (msgElement) {
                msgElement.classList.remove('message-sending');
                msgElement.classList.add('message-error');
                const statusSpan = msgElement.querySelector('.message-status');
                if (statusSpan) {
                  statusSpan.textContent = 'Failed to send (timeout)';
                }
              }
              pendingMessages.delete(messageId);
            }
          }, 5000);
          
          clearComposer();
          ws.send(JSON.stringify(messageData));
          console.log('[SEND] Message sent, id=' + messageId);
        }
      } catch (error) {
        console.error('[SEND] Error:', error);
        showStatus('Send failed: ' + error.message, 'error');
        
        const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
        if (msgElement) {
          msgElement.classList.remove('message-sending');
          msgElement.classList.add('message-error');
          const statusSpan = msgElement.querySelector('.message-status');
          if (statusSpan) {
            statusSpan.textContent = 'Failed to send';
          }
        }
        
        pendingMessages.delete(messageId);
      } finally {
        sendBtn.disabled = false;
      }
    }

    function disableInputs(disabled) {
      document.getElementById('sendBtn').disabled = disabled;
      document.getElementById('composer').contentEditable = !disabled;
      document.getElementById('cameraBtn').disabled = disabled;
      document.getElementById('fileBtn').disabled = disabled;
      document.getElementById('audioBtn').disabled = disabled;
    }

    // ========================================
    // AUDIO RECORDING (unchanged)
    // ========================================
    
    async function startAudioRecording() {
      try {
        let permissionGranted = false;
        
        if (navigator.permissions && navigator.permissions.query) {
          try {
            const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
            console.log('[MIC] Permission status:', permissionStatus.state);
            
            if (permissionStatus.state === 'denied') {
              showStatus('Mic blocked - please enable in browser settings', 'error');
              return;
            }
            
            permissionGranted = permissionStatus.state === 'granted';
          } catch (permErr) {
            console.log('[MIC] Permission query not supported');
          }
        }
        
        try {
          audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log('[MIC] Access granted');
        } catch (error) {
          console.error('[MIC] getUserMedia error:', error);
          
          if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            showStatus('Mic blocked - please enable in browser settings', 'error');
          } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            showStatus('Mic error (no device found)', 'error');
          } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            showStatus('Mic error (device busy or OS blocked)', 'error');
          } else {
            showStatus(`Mic error (${error.name || 'unknown'})`, 'error');
          }
          return;
        }
        
        audioChunks = [];
        
        let mimeType = 'audio/webm';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = 'audio/webm;codecs=opus';
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'audio/ogg;codecs=opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
              mimeType = '';
            }
          }
        }

        recorder = new MediaRecorder(audioStream, mimeType ? { mimeType } : {});

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) audioChunks.push(e.data);
        };

        recorder.onstop = () => {
          if (audioStream) {
            audioStream.getTracks().forEach(t => t.stop());
            audioStream = null;
          }

          const blob = new Blob(audioChunks, { type: recorder.mimeType || 'audio/webm' });
          if (blob.size === 0) {
            showStatus('Recording failed (empty audio)', 'error');
            resetAudioButton();
            return;
          }

          createAudioDraft(blob);
        };

        recorder.start();
        recordingStartTime = Date.now();

        const indicator = document.getElementById('recordingIndicator');
        indicator.classList.add('active');

        const timerInterval = setInterval(() => {
          if (!recorder || recorder.state === 'inactive') {
            clearInterval(timerInterval);
            return;
          }
          const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
          document.getElementById('recordingTimer').textContent = elapsed + 's / 30s';
        }, 100);

        recordTimer = setTimeout(() => {
          stopAudioRecording();
          clearInterval(timerInterval);
        }, 30000);

      } catch (error) {
        showStatus('Microphone access error: ' + error.message, 'error');
        console.error('[AUDIO] Error:', error);
        
        if (audioStream) {
          audioStream.getTracks().forEach(t => t.stop());
          audioStream = null;
        }
      }
    }

    function stopAudioRecording() {
      if (recordTimer) clearTimeout(recordTimer);
      recordTimer = null;
      
      if (recorder && recorder.state !== 'inactive') {
        recorder.stop();
      }

      const indicator = document.getElementById('recordingIndicator');
      indicator.classList.remove('active');
    }

    function resetAudioButton() {
      document.getElementById('audioBtn').textContent = 'Audio Message';
      document.getElementById('audioBtn').style.background = '';
    }

    function createAudioDraft(blob) {
      audioDraftBlob = blob;
      
      if (audioDraftURL) {
        URL.revokeObjectURL(audioDraftURL);
      }
      
      audioDraftURL = URL.createObjectURL(blob);
      
      const draftDiv = document.getElementById('audioDraft');
      const player = document.getElementById('audioDraftPlayer');
      const captionInput = document.getElementById('audioCaptionInput');
      
      player.src = audioDraftURL;
      captionInput.value = '';
      
      draftDiv.classList.add('active');
      resetAudioButton();
      
      console.log('[AUDIO] Draft created, size:', blob.size);
    }

    function discardAudioDraft() {
      if (audioDraftURL) {
        URL.revokeObjectURL(audioDraftURL);
        audioDraftURL = null;
      }
      
      audioDraftBlob = null;
      
      const draftDiv = document.getElementById('audioDraft');
      draftDiv.classList.remove('active');
      
      document.getElementById('audioCaptionInput').value = '';
    }

    async function sendAudioDraft() {
      if (!audioDraftBlob) {
        showStatus('No audio to send', 'error');
        return;
      }

      const banUntil = getBanState();
      if (banUntil && banUntil > Date.now()) {
        showStatus('You are temporarily blocked from sending messages', 'error');
        return;
      }

      if (ws.readyState !== WebSocket.OPEN) {
        showStatus('Not connected. Please wait...', 'error');
        return;
      }

      const caption = document.getElementById('audioCaptionInput').value.trim();
      const nickname = (document.getElementById('nickname').value.trim() || 'Anonymous').substring(0, 100);
      const messageId = generateUUID();

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      try {
        const optimisticData = {
          type: 'audio',
          id: messageId,
          nickname,
          timestamp: Date.now(),
          url: audioDraftURL,
          caption: caption || '',
          senderId: myClientId
        };
        
        addMessage(optimisticData, true, messageId, 'sending');
        pendingMessages.set(messageId, optimisticData);

        const fd = new FormData();
        const ext = audioDraftBlob.type.includes('ogg') ? 'ogg' : 'webm';
        fd.append('file', audioDraftBlob, `audio-${Date.now()}.${ext}`);

        const res = await fetch(UPLOAD_URL, { method: 'POST', body: fd });
        const json = await res.json();

        if (!json.success && !json.ok) {
          throw new Error(json.error || 'Upload failed');
        }

        const audioUrl = json.url;

        const messageData = {
          type: 'audio',
          id: messageId,
          messageId: messageId,
          nickname,
          timestamp: Date.now(),
          url: audioUrl,
          caption: caption || ''
        };

        ws.send(JSON.stringify(messageData));

        const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
        if (msgElement) {
          const audio = msgElement.querySelector('audio');
          if (audio) {
            audio.src = audioUrl;
          }
        }

        discardAudioDraft();

      } catch (error) {
        console.error('[AUDIO] Upload error:', error);
        showStatus('Audio upload failed: ' + error.message, 'error');
        
        const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
        if (msgElement) {
          msgElement.classList.remove('message-sending');
          msgElement.classList.add('message-error');
          const statusSpan = msgElement.querySelector('.message-status');
          if (statusSpan) {
            statusSpan.textContent = 'Failed to send';
          }
        }
        
        pendingMessages.delete(messageId);
      } finally {
        sendBtn.disabled = false;
      }
    }

    function toggleAudioRecording() {
      if (recorder && recorder.state === 'recording') {
        stopAudioRecording();
      } else {
        startAudioRecording();
      }
    }

    // ========================================
    // FILE/PHOTO HANDLING
    // ========================================
    
    function handleFileSelect() {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      
      if (!file) return;

      // Check for dangerous file extensions
      if (isDangerousFile(file.name)) {
        showStatus(`File type not allowed for security reasons: ${getFileExtension(file.name)}`, 'error');
        fileInput.value = '';
        return;
      }

      if (file.size > 10 * 1024 * 1024) {
        showStatus('File size must be less than 10MB', 'error');
        fileInput.value = '';
        return;
      }

      selectedFile = file;
      
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
      }
      
      previewURL = URL.createObjectURL(file);
      
      const composer = document.getElementById('photoComposer');
      const previewImg = document.getElementById('previewImage');
      const previewFilename = document.getElementById('previewFilename');
      const previewSize = document.getElementById('previewSize');
      
      // Only show image preview if it's actually an image
      if (isImageFile(file.name, file.type)) {
        previewImg.src = previewURL;
        previewImg.style.display = 'block';
      } else {
        previewImg.style.display = 'none';
      }
      
      previewFilename.textContent = file.name;
      previewSize.textContent = formatFileSize(file.size);
      
      composer.classList.add('active');
      document.getElementById('composer').focus();
    }

    function removePhotoAttachment() {
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
        previewURL = null;
      }
      
      selectedFile = null;
      document.getElementById('fileInput').value = '';
      
      const composer = document.getElementById('photoComposer');
      composer.classList.remove('active');
    }

    async function openCamera() {
      try {
        const modal = document.getElementById('cameraModal');
        const video = document.getElementById('cameraPreview');
        
        cameraStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'user' },
          audio: false 
        });
        
        video.srcObject = cameraStream;
        modal.classList.add('active');
      } catch (error) {
        alert('Camera access denied or not available: ' + error.message);
      }
    }

    function closeCamera() {
      const modal = document.getElementById('cameraModal');
      const video = document.getElementById('cameraPreview');
      
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      
      video.srcObject = null;
      modal.classList.remove('active');
    }

    function capturePhoto() {
      const video = document.getElementById('cameraPreview');
      const canvas = document.getElementById('cameraCanvas');
      const context = canvas.getContext('2d');

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      context.drawImage(video, 0, 0);

      canvas.toBlob((blob) => {
        const file = new File([blob], `camera-${Date.now()}.jpg`, { type: 'image/jpeg' });
        
        selectedFile = file;
        
        if (previewURL) {
          URL.revokeObjectURL(previewURL);
        }
        
        previewURL = URL.createObjectURL(file);
        
        const composer = document.getElementById('photoComposer');
        const previewImg = document.getElementById('previewImage');
        const previewFilename = document.getElementById('previewFilename');
        const previewSize = document.getElementById('previewSize');
        
        previewImg.src = previewURL;
        previewFilename.textContent = file.name;
        previewSize.textContent = formatFileSize(file.size);
        
        composer.classList.add('active');
        closeCamera();
        document.getElementById('composer').focus();
      }, 'image/jpeg', 0.8);
    }

    function openImagePreview(url) {
      const modal = document.getElementById('imageModal');
      const img = document.getElementById('fullscreenImage');
      img.src = url;
      modal.classList.add('active');
    }

    function closeImagePreview() {
      const modal = document.getElementById('imageModal');
      modal.classList.remove('active');
    }

    function toggleDarkMode() {
      const body = document.body;
      const button = document.querySelector('.dark-mode-toggle');
      
      if (body.classList.contains('light-mode')) {
        body.className = 'dark-mode';
        button.textContent = 'Light Mode';
        localStorage.setItem('darkMode', 'true');
      } else {
        body.className = 'light-mode';
        button.textContent = 'Dark Mode';
        localStorage.setItem('darkMode', 'false');
      }
    }

    function scrollToBottom() {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Send message on Enter key (Shift+Enter for new line in contenteditable)
    document.getElementById('composer').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  </script>
</body>
</html>
