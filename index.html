<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Prevent Tab Switch Glitch -->
  <script>
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === 'hidden') {
        localStorage.removeItem("nickname");
        window.location.href = "join.html";
      }
    });
  </script>
  <!-- Redirect to join.html if no nickname stored -->
  <script>
    if (!localStorage.getItem('nickname')) {
      window.location.href = "join.html";
    }
  </script>
  <meta charset="UTF-8">
  <title>3D Multiplayer Tank Game â€“ Biomes, Weather & Camera Shake</title>
  <style>
    body { margin: 0; overflow: hidden; }
    /* Health Bar */
    #healthBarContainer {
      position: fixed;
      bottom: 220px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 20px;
      background-color: #555;
      border: 2px solid #333;
      border-radius: 5px;
      z-index: 130;
    }
    #healthBar {
      width: 100%;
      height: 100%;
      background-color: green;
      border-radius: 3px;
    }
    /* Chat Input */
    #chatInput {
      position: fixed;
      bottom: 210px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      padding: 8px;
      font-size: 16px;
      z-index: 110;
    }
    /* Kill Feed */
    #killFeed {
      position: fixed;
      top: 10px;
      right: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 110;
    }
    /* Minimap */
    #minimap {
      position: fixed;
      top: 10px;
      left: 10px;
      border: 2px solid #fff;
      background: rgba(0,0,0,0.5);
      z-index: 110;
    }
    /* Global Chat Log */
    #globalChatLog {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      z-index: 105;
    }
    /* Missile Selector Menu */
    #missileMenu {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 10px;
      border-radius: 5px;
      z-index: 120;
      font-family: Arial, sans-serif;
    }
    #missileMenu label, #missileMenu select {
      font-size: 16px;
    }
    /* Info Bar */
    #infoBar {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #ffdd00;
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      cursor: move;
      z-index: 200;
    }
    /* Damage Overlay */
    #damageOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255, 0, 0, 0);
      pointer-events: none;
      z-index: 300;
      transition: background 0.2s ease-out;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- UI Elements -->
  <div id="healthBarContainer"><div id="healthBar"></div></div>
  <div id="missileMenu">
    <label for="missileTypeSelect">Missile Type:</label>
    <select id="missileTypeSelect">
      <option value="bullet">Fast Bullet</option>
      <option value="splash">Splash Damage</option>
      <option value="rocket">Heavy Rocket</option>
    </select>
  </div>
  <input type="text" id="chatInput" placeholder="Type a message and hit Enter">
  <div id="killFeed"></div>
  <canvas id="minimap" width="200" height="200"></canvas>
  <div id="globalChatLog"></div>
  <!-- Info Bar -->
  <div id="infoBar">
    <strong>Controls:</strong> WASD, SPACE, 1-3 (Camera), SHIFT, T (Chat), I (Toggle Info)<br>
    <strong>Connection:</strong> <span id="latencyDisplay">--</span> ms<br>
    <strong>Players:</strong> --
  </div>
  <!-- Damage Overlay -->
  <div id="damageOverlay"></div>

  <!-- Three.js and GLTFLoader -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>
  
  <script>
    // --- Global Helper: updateHealthBar ---
    function updateHealthBar() {
      document.getElementById("healthBar").style.width = playerData.health + "%";
    }

    // --- Define Missile Types ---
    const missileTypes = {
      bullet: {
        speed: 60,
        geometry: function() {
          let geom = new THREE.CylinderGeometry(0.2, 0.2, 5, 16);
          geom.rotateZ(Math.PI / 2);
          return geom;
        },
        material: new THREE.MeshStandardMaterial({ color: 0xffff00 }),
        explosionRadius: 3
      },
      splash: {
        speed: 54,
        geometry: function() {
          return new THREE.SphereGeometry(0.3, 8, 8);
        },
        material: new THREE.MeshStandardMaterial({ color: 0xff4500 }),
        explosionRadius: 5
      },
      rocket: {
        speed: 48,
        geometry: function() {
          let geom = new THREE.CylinderGeometry(0.2, 0.2, 5, 16);
          geom.rotateZ(Math.PI / 2);
          return geom;
        },
        material: new THREE.MeshStandardMaterial({ color: 0xffa500 }),
        explosionRadius: 7
      }
    };

    // --- Camera Shake Function (Prompt 5) ---
    function cameraShake(intensity = 0.5, duration = 200) {
      const originalPos = camera.position.clone();
      const start = performance.now();
      function shake() {
        const now = performance.now();
        const elapsed = now - start;
        if (elapsed < duration) {
          camera.position.x = originalPos.x + (Math.random() - 0.5) * intensity;
          camera.position.y = originalPos.y + (Math.random() - 0.5) * intensity;
          camera.position.z = originalPos.z + (Math.random() - 0.5) * intensity;
          requestAnimationFrame(shake);
        } else {
          camera.position.copy(originalPos);
        }
      }
      shake();
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Request pointer lock
      document.body.addEventListener("click", () => {
        document.body.requestPointerLock();
      });

      // ------------- ImprovedNoise for Terrain -------------
      var ImprovedNoise = function () {
        var p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,
                 140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,
                 247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,
                 57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,
                 74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,
                 60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,
                 65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,
                 196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,
                 217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,
                 206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,
                 152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,
                 253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
                 228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,
                 235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,
                 176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,
                 24,72,243,141,128,195,78,66,215,61,156,180];
        for (var i = 0; i < 256; i++) { p[256 + i] = p[i]; }
        function fade(t) { return t*t*t*(t*(t*6-15)+10); }
        function lerp(t, a, b) { return a + t*(b-a); }
        function grad(hash, x, y, z) {
          var h = hash & 15;
          var u = h < 8 ? x : y, v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        this.noise = function(x, y, z) {
          var floorX = Math.floor(x), floorY = Math.floor(y), floorZ = Math.floor(z);
          var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;
          x -= floorX; y -= floorY; z -= floorZ;
          var u = fade(x), v = fade(y), w = fade(z);
          var A = p[X] + Y, AA = p[A] + Z, AB = p[A+1] + Z;
          var B = p[X+1] + Y, BA = p[B] + Z, BB = p[B+1] + Z;
          return lerp(w,
            lerp(v,
              lerp(u, grad(p[AA], x, y, z), grad(p[BA], x-1, y, z)),
              lerp(u, grad(p[AB], x, y-1, z), grad(p[BB], x-1, y-1, z))
            ),
            lerp(v,
              lerp(u, grad(p[AA+1], x, y, z-1), grad(p[BA+1], x-1, y, z-1)),
              lerp(u, grad(p[AB+1], x, y-1, z-1), grad(p[BB+1], x-1, y-1, z-1))
            )
          );
        };
      };

      // -----------------------
      // Global Variables & Player Data
      // -----------------------
      let scene, camera, renderer, localTank, clock;
      let remoteTanks = {}, killFeedMessages = [];
      let ws, cameraMode = 1, currentMap = 'split', missiles = [];
      let groundMesh = null, treeColliders = [], prevTankPosition = new THREE.Vector3();
      let faster = false, turretRotationOffset = 0;
      let trailParticles = [];
      let latency = 100;  // in ms
      let cameraShakeTime = 0;
      let cameraShakeIntensity = 0.5;
      let weatherParticles = null;
      const controls = { forward: false, backward: false, left: false, right: false, shoot: false };
      const storedNickname = localStorage.getItem('nickname');
      const playerData = {
        id: Math.floor(Math.random() * 1000000).toString(),
        nickname: storedNickname ? storedNickname : 'Player' + Math.floor(Math.random() * 1000),
        color: '#' + Math.floor(Math.random() * 16777215).toString(16),
        health: 100
      };
      const WS_URL = "wss://game.ldawg7624.com";
      let lastChatTime = 0;
      const chatCooldown = 2000; // ms

      // -----------------------
      // Create a Texture Loader
      // -----------------------
      const loader = new THREE.TextureLoader();

      // -----------------------
      // Audio Setup
      // -----------------------
      let listener = new THREE.AudioListener();
      let explosionSound = new THREE.Audio(listener);
      let engineSound = new THREE.Audio(listener);
      let audioLoader = new THREE.AudioLoader();
      // Replace these URLs with your actual audio files that allow CORS
      audioLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/sounds/explosion.mp3', function(buffer) {
        explosionSound.setBuffer(buffer);
        explosionSound.setVolume(0.5);
      });
      audioLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/sounds/engine.ogg', function(buffer) {
        engineSound.setBuffer(buffer);
        engineSound.setLoop(true);
        engineSound.setVolume(0.3);
      });

      // -----------------------
      // Define Missile Types
      // -----------------------
      const missileTypes = {
        bullet: {
          speed: 60,
          geometry: function() {
            let geom = new THREE.CylinderGeometry(0.2, 0.2, 5, 16);
            geom.rotateZ(Math.PI / 2);
            return geom;
          },
          material: new THREE.MeshStandardMaterial({ color: 0xffff00 }),
          explosionRadius: 3
        },
        splash: {
          speed: 54,
          geometry: function() {
            return new THREE.SphereGeometry(0.3, 8, 8);
          },
          material: new THREE.MeshStandardMaterial({ color: 0xff4500 }),
          explosionRadius: 5
        },
        rocket: {
          speed: 48,
          geometry: function() {
            let geom = new THREE.CylinderGeometry(0.2, 0.2, 5, 16);
            geom.rotateZ(Math.PI / 2);
            return geom;
          },
          material: new THREE.MeshStandardMaterial({ color: 0xffa500 }),
          explosionRadius: 7
        }
      };

      // -----------------------
      // Detailed Tank Model with Correct Cannon Alignment
      // -----------------------
      function createTank(color) {
        let tank = new THREE.Group();
        // Chassis
        let chassisGeom = new THREE.BoxGeometry(3.5, 1.2, 6);
        let chassisMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.4 });
        let chassis = new THREE.Mesh(chassisGeom, chassisMat);
        chassis.castShadow = true;
        chassis.receiveShadow = true;
        chassis.position.y = 0.6;
        tank.add(chassis);
        // Side wheels (simulate tracks)
        const wheelGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        for (let side of [1, -1]) {
          for (let i = -1; i <= 1; i++) {
            let wheel = new THREE.Mesh(wheelGeom, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.castShadow = true;
            wheel.receiveShadow = true;
            wheel.position.set(side * 2.1, 0.3, i * 2);
            tank.add(wheel);
          }
        }
        // Hatch on top
        let hatchGeom = new THREE.BoxGeometry(1, 0.2, 1);
        let hatchMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        let hatch = new THREE.Mesh(hatchGeom, hatchMat);
        hatch.position.set(0, 1.1, -0.5);
        hatch.castShadow = true;
        hatch.receiveShadow = true;
        tank.add(hatch);
        // Turret with cannon
        let turret = new THREE.Group();
        let turretBaseGeom = new THREE.BoxGeometry(2.5, 1, 3);
        let turretBaseMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.7, roughness: 0.3 });
        let turretBase = new THREE.Mesh(turretBaseGeom, turretBaseMat);
        turretBase.castShadow = true;
        turretBase.receiveShadow = true;
        turretBase.position.y = 0.5;
        turret.add(turretBase);
        // Cannon: centered on turret, pointing forward (positive Z)
        let cannonGeom = new THREE.CylinderGeometry(0.2, 0.2, 5, 16);
        let cannonMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
        let cannon = new THREE.Mesh(cannonGeom, cannonMat);
        cannon.castShadow = true;
        cannon.receiveShadow = true;
        cannon.rotation.z = Math.PI / 2; // point along +Z
        cannon.position.set(0, 0.4, 1.5); // adjust so projectiles exit at tank level
        turret.add(cannon);
        turret.position.set(0, 1.4, 0);
        tank.add(turret);
        tank.userData.turret = turret;
        tank.userData.cannon = cannon;
        return tank;
      }
      function addNicknameLabel(tank, nickname) {
        tank.children = tank.children.filter(child => child.name !== "nicknameLabel");
        let canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 64;
        let ctx = canvas.getContext('2d');
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "30px Arial";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(nickname, canvas.width / 2, canvas.height / 2 + 10);
        let texture = new THREE.CanvasTexture(canvas);
        let sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
        sprite.name = "nicknameLabel";
        sprite.scale.set(4, 1, 1);
        sprite.position.set(0, 2.5, 0);
        tank.add(sprite);
      }

      // -----------------------
      // Pointer Lock & Turret Aiming
      // -----------------------
      document.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement === document.body) {
          turretRotationOffset -= e.movementX * 0.002;
          if (localTank && localTank.userData.turret) {
            localTank.userData.turret.rotation.y = turretRotationOffset;
          }
        }
      });

      // -----------------------
      // Environment: Desert Terrain & Skybox (Prompt 4)
      // -----------------------
      function setupTerrainTexture() {
        let sandTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sand.jpg');
        sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;
        sandTexture.repeat.set(50, 50);
        return sandTexture;
      }
      function setupSkybox() {
        const skyboxUrls = [
          'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skybox/px.jpg',
          'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skybox/nx.jpg',
          'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skybox/py.jpg',
          'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skybox/ny.jpg',
          'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skybox/pz.jpg',
          'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skybox/nz.jpg'
        ];
        const cubeLoader = new THREE.CubeTextureLoader();
        let cubeTexture = cubeLoader.load(skyboxUrls);
        scene.background = cubeTexture;
      }
      // Additional details: Dry bushes and varied cacti
      function createBush() {
        let bush = new THREE.Group();
        let bushGeom = new THREE.SphereGeometry(1, 8, 8);
        let bushMat = new THREE.MeshStandardMaterial({ color: 0x775533 });
        let bushMesh = new THREE.Mesh(bushGeom, bushMat);
        bushMesh.castShadow = true;
        bushMesh.receiveShadow = true;
        bush.add(bushMesh);
        return bush;
      }
      function createCactusVariety() {
        let cactus = new THREE.Group();
        let scale = Math.random() * 0.5 + 0.8;
        let stem = new THREE.Mesh(new THREE.CylinderGeometry(0.3*scale, 0.3*scale, 4*scale, 8),
          new THREE.MeshStandardMaterial({ color: 0x228B22 }));
        stem.position.y = 2*scale;
        cactus.add(stem);
        if (Math.random() > 0.5) {
          let arm = new THREE.Mesh(new THREE.CylinderGeometry(0.2*scale, 0.2*scale, 2*scale, 8),
            new THREE.MeshStandardMaterial({ color: 0x228B22 }));
          arm.rotation.z = Math.PI / 4;
          arm.position.set(0.5*scale, 3*scale, 0);
          cactus.add(arm);
          let arm2 = arm.clone();
          arm2.rotation.z = -Math.PI / 4;
          arm2.position.set(-0.5*scale, 3*scale, 0);
          cactus.add(arm2);
        }
        return cactus;
      }

      // -----------------------
      // Split Map into Biomes: Desert + City (Prompt 5)
      // -----------------------
      function loadMap() {
        let mapGroup = scene.getObjectByName("mapGroup");
        if (mapGroup) { scene.remove(mapGroup); }
        mapGroup = new THREE.Group();
        mapGroup.name = "mapGroup";
        
        // Desert Biome: 500x500, centered at (-250,0)
        let desertGeom = new THREE.PlaneGeometry(500, 500, 100, 100);
        desertGeom.rotateX(-Math.PI/2);
        desertGeom.translate(-250, 0, 0);
        let amplitude = 8, scale = 150;
        const noise = new ImprovedNoise();
        const desertPos = desertGeom.attributes.position;
        for (let i = 0; i < desertPos.count; i++) {
          let x = desertPos.getX(i);
          let z = desertPos.getZ(i);
          let y = noise.noise(x / scale, z / scale, 0) * amplitude;
          desertPos.setY(i, y);
        }
        desertPos.needsUpdate = true;
        desertGeom.computeVertexNormals();
        let sandTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sand.jpg');
        sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;
        sandTexture.repeat.set(50, 50);
        let desertMat = new THREE.MeshStandardMaterial({ map: sandTexture });
        let desertMesh = new THREE.Mesh(desertGeom, desertMat);
        desertMesh.receiveShadow = true;
        mapGroup.add(desertMesh);
        
        // City Biome: 500x500, centered at (250,0)
        let cityGeom = new THREE.PlaneGeometry(500, 500, 50, 50);
        cityGeom.rotateX(-Math.PI/2);
        cityGeom.translate(250, 0, 0);
        const cityPos = cityGeom.attributes.position;
        for (let i = 0; i < cityPos.count; i++) {
          let x = cityPos.getX(i);
          let z = cityPos.getZ(i);
          let y = noise.noise(x / 300, z / 300, 0) * 2;
          cityPos.setY(i, y);
        }
        cityPos.needsUpdate = true;
        cityGeom.computeVertexNormals();
        let concreteTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg');
        concreteTexture.wrapS = concreteTexture.wrapT = THREE.RepeatWrapping;
        concreteTexture.repeat.set(20, 20);
        let cityMat = new THREE.MeshStandardMaterial({ map: concreteTexture });
        let cityMesh = new THREE.Mesh(cityGeom, cityMat);
        cityMesh.receiveShadow = true;
        mapGroup.add(cityMesh);
        
        // Divider between biomes (a wall)
        let dividerGeom = new THREE.BoxGeometry(2, 20, 500);
        let dividerMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        let divider = new THREE.Mesh(dividerGeom, dividerMat);
        divider.position.set(0, 10, 0);
        divider.castShadow = true;
        divider.receiveShadow = true;
        mapGroup.add(divider);
        
        scene.add(mapGroup);
        // Use desert mesh for height updates
        groundMesh = desertMesh;
      }

      // -----------------------
      // Health System & Damage Feedback
      // -----------------------
      function showDamageFlash() {
        const overlay = document.getElementById("damageOverlay");
        overlay.style.background = "rgba(255, 0, 0, 0.5)";
        setTimeout(() => { overlay.style.background = "rgba(255, 0, 0, 0)"; }, 150);
      }
      function checkExplosionDamage(explosionPos, missileType) {
        let distance = explosionPos.distanceTo(localTank.position);
        let explosionRadius = missileTypes[missileType].explosionRadius;
        if (distance < explosionRadius) {
          let damage = missileType === "bullet" ? 10 : (missileType === "splash" ? 25 : 40);
          playerData.health -= damage;
          updateHealthBar();
          showDamageFlash();
          cameraShake(0.5, 200);
          if (playerData.health <= 0) {
            createExplosion(localTank.position, 2);
            addKillFeed(`${playerData.nickname} has been eliminated`);
            setTimeout(() => { window.location.href = "join.html"; }, 1000);
          }
        }
      }
      function applyDamageToRemote(id, missileType) {
        let damage = missileType === "bullet" ? 10 : (missileType === "splash" ? 25 : 40);
        if (remoteTanks[id]) {
          if (remoteTanks[id].health === undefined) remoteTanks[id].health = 100;
          remoteTanks[id].health -= damage;
          if (remoteTanks[id].health <= 0) {
            createExplosion(remoteTanks[id].mesh.position, 2);
            addKillFeed(`${playerData.nickname} eliminated ${remoteTanks[id].nickname}`);
            scene.remove(remoteTanks[id].mesh);
            delete remoteTanks[id];
          }
        }
      }

      // -----------------------
      // Update Tank Height & Collision Detection
      // -----------------------
      function updateTankHeight() {
        if (!groundMesh) return;
        let raycaster = new THREE.Raycaster(
          new THREE.Vector3(localTank.position.x, 1000, localTank.position.z),
          new THREE.Vector3(0, -1, 0)
        );
        let intersects = raycaster.intersectObject(groundMesh);
        if (intersects.length > 0) {
          localTank.position.y = intersects[0].point.y + 0.6;
        }
      }
      function checkCollisions() {
        for (let obs of treeColliders) {
          if (localTank.position.distanceTo(obs.position) < 10) {
            localTank.position.copy(prevTankPosition);
            return;
          }
        }
        if (localTank.position.x < -500 || localTank.position.x > 500 ||
            localTank.position.z < -250 || localTank.position.z > 250) {
          localTank.position.copy(prevTankPosition);
        }
      }

      // -----------------------
      // Window Resize Handler
      // -----------------------
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // -----------------------
      // Keyboard Controls & Info Toggle ("I")
      // -----------------------
      function onKeyDown(e) {
        if (e.code === "KeyT" && document.activeElement !== chatInput) { toggleChat(); return; }
        if (e.code === "KeyI") { toggleInfoBar(); return; }
        if (document.activeElement === chatInput) return;
        switch (e.code) {
          case "KeyW": controls.forward = true; break;
          case "KeyS": controls.backward = true; break;
          case "KeyA": controls.left = true; break;
          case "KeyD": controls.right = true; break;
          case "Space": controls.shoot = true; sendShoot(); break;
          case "ShiftLeft": faster = true; break;
          case "Digit1": cameraMode = 1; break;
          case "Digit2": cameraMode = 2; break;
          case "Digit3": cameraMode = 3; break;
        }
      }
      function onKeyUp(e) {
        switch (e.code) {
          case "KeyW": controls.forward = false; break;
          case "KeyS": controls.backward = false; break;
          case "KeyA": controls.left = false; break;
          case "KeyD": controls.right = false; break;
          case "Space": controls.shoot = false; break;
          case "ShiftLeft": faster = false; break;
        }
      }
      const chatInput = document.getElementById("chatInput");
      chatInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter") {
          if (chatInput.value.trim() !== "") { sendChat(chatInput.value.trim()); chatInput.value = ""; }
          chatInput.style.display = "none";
        }
      });
      function toggleChat() {
        chatInput.style.display = (chatInput.style.display === "none" || chatInput.style.display === "") ? "block" : "none";
        if (chatInput.style.display === "block") chatInput.focus();
      }

      // -----------------------
      // Info Bar & Draggable Panel (Prompt 6)
      // -----------------------
      let isDragging = false, offsetX = 0, offsetY = 0;
      const infoBar = document.getElementById("infoBar");
      infoBar.addEventListener("mousedown", function(e) {
        isDragging = true;
        offsetX = e.clientX - infoBar.offsetLeft;
        offsetY = e.clientY - infoBar.offsetTop;
      });
      document.addEventListener("mousemove", function(e) {
        if (isDragging) {
          infoBar.style.left = (e.clientX - offsetX) + "px";
          infoBar.style.top = (e.clientY - offsetY) + "px";
        }
      });
      document.addEventListener("mouseup", function() { isDragging = false; });
      let infoVisible = true;
      function toggleInfoBar() {
        infoVisible = !infoVisible;
        infoBar.style.display = infoVisible ? "block" : "none";
      }
      function updateInfoBar() {
        let quality = (latency < 50) ? "Great" :
                      (latency < 100) ? "Good" :
                      (latency < 200) ? "Ok" :
                      (latency < 350) ? "Mid" : "Poor";
        let activePlayers = Object.keys(remoteTanks).length + 1;
        infoBar.innerHTML = `
          <strong>Controls:</strong> WASD, SPACE, 1-3 (Camera), SHIFT, T (Chat), I (Toggle Info)<br>
          <strong>Connection:</strong> ${quality} (<span id="latencyDisplay">${Math.round(latency)}</span> ms)<br>
          <strong>Players:</strong> ${activePlayers}
        `;
      }

      // -----------------------
      // WebSocket Communication with Ping-Pong for Latency
      // -----------------------
      function setupWebSocket() {
        ws = new WebSocket(WS_URL);
        ws.onopen = () => {
          ws.send(JSON.stringify({
            type: "join",
            id: playerData.id,
            nickname: playerData.nickname,
            color: playerData.color,
            position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z }
          }));
          setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "ping", timestamp: performance.now() }));
            }
          }, 2000);
        };
        ws.onmessage = (event) => {
          let msg = JSON.parse(event.data);
          if (msg.type === "pong") {
            latency = performance.now() - msg.timestamp;
            return;
          }
          handleServerMessage(msg);
        };
        ws.onclose = () => { console.log("Disconnected from server."); };
      }
      function handleServerMessage(msg) {
        switch (msg.type) {
          case "update":
            if (msg.id !== playerData.id) { updateRemoteTank(msg); }
            break;
          case "chat":
            displayChatBubble(msg);
            addGlobalChatMessage(`${msg.nickname}: ${msg.message}`);
            break;
          case "shoot":
            addKillFeed(`${msg.nickname} fired!`);
            if (msg.id !== playerData.id) { createRemoteMissile(msg); }
            break;
          case "kill":
            addKillFeed(`${msg.killer} eliminated ${msg.victim}`);
            break;
          case "join":
            if (msg.id !== playerData.id && !remoteTanks[msg.id]) {
              let tank = createTank(msg.color);
              tank.position.set(msg.position.x, msg.position.y, msg.position.z);
              scene.add(tank);
              addNicknameLabel(tank, msg.nickname);
              remoteTanks[msg.id] = { mesh: tank, nickname: msg.nickname, health: 100 };
            }
            break;
          case "leave":
            if (remoteTanks[msg.id]) {
              scene.remove(remoteTanks[msg.id].mesh);
              delete remoteTanks[msg.id];
            }
            break;
        }
      }
      function updateRemoteTank(data) {
        if (!remoteTanks[data.id]) {
          let tank = createTank(data.color);
          tank.position.set(data.position.x, data.position.y, data.position.z);
          scene.add(tank);
          addNicknameLabel(tank, data.nickname);
          remoteTanks[data.id] = { mesh: tank, nickname: data.nickname, health: 100 };
        } else {
          let currentPos = remoteTanks[data.id].mesh.position;
          let targetPos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
          currentPos.lerp(targetPos, 0.1);
          remoteTanks[data.id].mesh.rotation.y = THREE.MathUtils.lerp(remoteTanks[data.id].mesh.rotation.y, data.rotation, 0.1);
        }
      }
      function sendUpdate() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "update",
            id: playerData.id,
            position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
            rotation: localTank.rotation.y
          }));
        }
      }
      function sendChat(message) {
        let now = Date.now();
        if (now - lastChatTime < chatCooldown) return;
        lastChatTime = now;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "chat",
            id: playerData.id,
            nickname: playerData.nickname,
            message: message
          }));
          displayChatBubble({ id: playerData.id, nickname: playerData.nickname, message: message });
          addGlobalChatMessage(`${playerData.nickname}: ${message}`);
        }
      }

      // -----------------------
      // Missile Logic with Collision, Trails & Cannon Recoil
      // -----------------------
      function launchMissile() {
        let selectedMissileType = document.getElementById("missileTypeSelect").value;
        let missileProps = missileTypes[selectedMissileType];
        let cannon = localTank.userData.cannon;
        let direction = new THREE.Vector3();
        cannon.getWorldDirection(direction);
        let position = new THREE.Vector3();
        cannon.getWorldPosition(position);
        let spawnPos = position.clone().add(direction.clone().multiplyScalar(1));
        let missileMesh = new THREE.Mesh(missileProps.geometry(), missileProps.material);
        missileMesh.position.copy(spawnPos);
        missileMesh.quaternion.copy(cannon.getWorldQuaternion(new THREE.Quaternion()));
        let velocity = direction.multiplyScalar(missileProps.speed);
        missileMesh.userData.lastTrailTime = 0;
        missileMesh.userData.owner = playerData.id;
        missiles.push({ mesh: missileMesh, velocity: velocity, life: 5, type: selectedMissileType, owner: playerData.id });
        scene.add(missileMesh);
        // Minor recoil shake on fire
        cameraShake(0.2, 100);
        // Cannon recoil animation
        let originalPos = cannon.position.clone();
        cannon.position.z -= 0.2;
        setTimeout(() => { cannon.position.copy(originalPos); }, 100);
      }
      function createRemoteMissile(data) {
        let missileType = data.missileType || "bullet";
        let missileProps = missileTypes[missileType];
        let missileMesh = new THREE.Mesh(missileProps.geometry(), missileProps.material);
        missileMesh.position.set(data.position.x, data.position.y, data.position.z);
        missileMesh.rotation.y = data.rotation;
        missileMesh.userData.lastTrailTime = 0;
        missileMesh.userData.owner = data.id;
        let direction = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), data.rotation);
        let velocity = direction.multiplyScalar(missileProps.speed);
        missiles.push({ mesh: missileMesh, velocity: velocity, life: 5, type: missileType, owner: data.id });
        scene.add(missileMesh);
      }
      function sendShoot() {
        let selectedMissileType = document.getElementById("missileTypeSelect").value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "shoot",
            id: playerData.id,
            nickname: playerData.nickname,
            position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
            rotation: localTank.rotation.y,
            missileType: selectedMissileType
          }));
        }
        launchMissile();
      }
      function updateMissiles(delta) {
        for (let i = missiles.length - 1; i >= 0; i--) {
          let missile = missiles[i];
          missile.mesh.position.add(missile.velocity.clone().multiplyScalar(delta));
          missile.life -= delta;
          if (performance.now() - missile.mesh.userData.lastTrailTime > 50) {
            createMissileTrail(missile.mesh.position);
            missile.mesh.userData.lastTrailTime = performance.now();
          }
          if (missile.owner === playerData.id) {
            for (let id in remoteTanks) {
              let remoteTank = remoteTanks[id].mesh;
              if (missile.mesh.position.distanceTo(remoteTank.position) < 1.5) {
                applyDamageToRemote(id, missile.type);
                createExplosion(missile.mesh.position, missileTypes[missile.type].explosionRadius);
                scene.remove(missile.mesh);
                missiles.splice(i, 1);
                break;
              }
            }
          } else {
            if (missile.mesh.position.distanceTo(localTank.position) < 1.5) {
              checkExplosionDamage(missile.mesh.position, missile.type);
              createExplosion(missile.mesh.position, missileTypes[missile.type].explosionRadius);
              scene.remove(missile.mesh);
              missiles.splice(i, 1);
            }
          }
          if (missile.life <= 0) {
            if (missile.owner === playerData.id) {
              for (let id in remoteTanks) {
                if (missile.mesh.position.distanceTo(remoteTanks[id].mesh.position) < missileTypes[missile.type].explosionRadius) {
                  applyDamageToRemote(id, missile.type);
                }
              }
            } else {
              checkExplosionDamage(missile.mesh.position, missile.type);
            }
            createExplosion(missile.mesh.position, missileTypes[missile.type].explosionRadius);
            scene.remove(missile.mesh);
            missiles.splice(i, 1);
          }
        }
      }
      function createMissileTrail(position) {
        const particleGeom = new THREE.SphereGeometry(0.1, 6, 6);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.5 });
        let particle = new THREE.Mesh(particleGeom, particleMat);
        particle.position.copy(position);
        particle.userData.life = 0.3;
        scene.add(particle);
        trailParticles.push(particle);
      }
      function updateTrailParticles(delta) {
        for (let i = trailParticles.length - 1; i >= 0; i--) {
          let p = trailParticles[i];
          p.userData.life -= delta;
          p.material.opacity = Math.max(p.userData.life / 0.3, 0);
          if (p.userData.life <= 0) {
            scene.remove(p);
            trailParticles.splice(i, 1);
          }
        }
      }
      function createExplosion(position, radius = 1.5) {
        let explosionGeom = new THREE.SphereGeometry(radius, 16, 16);
        let explosionMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true });
        let explosionMesh = new THREE.Mesh(explosionGeom, explosionMat);
        explosionMesh.position.copy(position);
        scene.add(explosionMesh);
        if (explosionSound.isPlaying) explosionSound.stop();
        explosionSound.play();
        cameraShake(0.5, 200);
        let explosionLife = 0.5, start = performance.now();
        function animateExplosion() {
          let elapsed = (performance.now() - start) / 1000;
          if (elapsed < explosionLife) {
            explosionMesh.material.opacity = 1 - (elapsed / explosionLife);
            requestAnimationFrame(animateExplosion);
          } else {
            scene.remove(explosionMesh);
          }
        }
        animateExplosion();
      }

      // -----------------------
      // Chat and Kill Feed UI
      // -----------------------
      function displayChatBubble(msg) {
        let target = (msg.id === playerData.id) ? localTank : (remoteTanks[msg.id] ? remoteTanks[msg.id].mesh : null);
        if (!target) return;
        let canvas = document.createElement('canvas'); 
        canvas.width = 256; canvas.height = 64;
        let ctx = canvas.getContext('2d');
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "20px Arial";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(msg.message, canvas.width / 2, canvas.height / 2 + 8);
        let sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
        sprite.scale.set(4, 1, 1);
        sprite.position.set(0, 3, 0);
        target.add(sprite);
        setTimeout(() => { target.remove(sprite); }, 3000);
      }
      function addKillFeed(text) {
        killFeedMessages.push(text);
        document.getElementById("killFeed").innerHTML = killFeedMessages.slice(-5).join("<br>");
      }
      function addGlobalChatMessage(text) {
        let chatLog = document.getElementById("globalChatLog");
        let messageElem = document.createElement("div");
        messageElem.textContent = text;
        chatLog.appendChild(messageElem);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      // -----------------------
      // Animation Loop & Camera Shake
      // -----------------------
      function animate() {
        requestAnimationFrame(animate);
        let delta = clock.getDelta();
        prevTankPosition.copy(localTank.position);
        let speed = 15 * delta * (faster ? 2 : 1);
        if (controls.forward) localTank.translateZ(speed);
        if (controls.backward) localTank.translateZ(-speed);
        if (controls.left) localTank.rotation.y += 2 * delta;
        if (controls.right) localTank.rotation.y -= 2 * delta;
        checkCollisions();
        updateTankHeight();
        updateCamera();
        localTank.children.forEach(child => { if (child.type === "Sprite") child.lookAt(camera.position); });
        for (let id in remoteTanks) {
          remoteTanks[id].mesh.children.forEach(child => { if (child.type === "Sprite") child.lookAt(camera.position); });
        }
        sendUpdate();
        updateMissiles(delta);
        updateTrailParticles(delta);
        // Update weather particles for rain and snow
        if (currentWeather === "rain" && weatherParticles) {
          weatherParticles.children.forEach(drop => {
            drop.position.y -= delta * 50;
            if (drop.position.y < 0) drop.position.y = Math.random() * 50 + 50;
          });
        }
        if (currentWeather === "snow" && weatherParticles) {
          weatherParticles.children.forEach(flake => {
            flake.position.y -= delta * 10;
            if (flake.position.y < 0) flake.position.y = Math.random() * 50 + 50;
          });
        }
        // For storm, occasional lightning flash
        if (currentWeather === "storm" && Math.random() < 0.01) {
          let overlay = document.getElementById("damageOverlay");
          overlay.style.background = "rgba(255,255,255,0.8)";
          setTimeout(() => { overlay.style.background = "rgba(255,255,255,0)"; }, 100);
        }
        renderer.render(scene, camera);
        updateMinimap();
        updateHealthBar();
        updateInfoBar();
      }
      function updateCamera() {
        let targetPos;
        if (cameraMode === 1) {
          targetPos = new THREE.Vector3(0, 5, -10).applyMatrix4(localTank.matrixWorld);
        } else if (cameraMode === 2) {
          targetPos = localTank.localToWorld(new THREE.Vector3(0, 2, 0));
        } else if (cameraMode === 3) {
          targetPos = localTank.position.clone().add(new THREE.Vector3(0, 30, 0));
        }
        if (cameraShakeTime > 0) {
          targetPos.x += (Math.random()-0.5) * cameraShakeIntensity;
          targetPos.y += (Math.random()-0.5) * cameraShakeIntensity;
          cameraShakeTime -= clock.getDelta();
        }
        camera.position.lerp(targetPos, 0.1);
        camera.lookAt(localTank.position);
      }
      function updateMinimap() {
        let minimap = document.getElementById("minimap"), ctx = minimap.getContext("2d");
        ctx.clearRect(0, 0, minimap.width, minimap.height);
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0, 0, minimap.width, minimap.height);
        function worldToMinimap(x, z) {
          return { x: (x + 500) * (minimap.width / 1000), y: (250 - z) * (minimap.height / 500) };
        }
        let pos = worldToMinimap(localTank.position.x, localTank.position.z);
        ctx.fillStyle = playerData.color;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        for (let id in remoteTanks) {
          let pos2 = worldToMinimap(remoteTanks[id].mesh.position.x, remoteTanks[id].mesh.position.z);
          ctx.beginPath();
          ctx.arc(pos2.x, pos2.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      setInterval(() => {
        currentMap = 'desert';
        loadMap(currentMap);
      }, 180000);

      // -----------------------
      // Initialization with Split Biomes, Warm Lighting, Audio & Weather
      // -----------------------
      function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        setupSkybox();
        scene.fog = new THREE.FogExp2(0xEDC9AF, 0.002);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 5, -10);
        camera.add(listener);
        engineSound.play();
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        let ambient = new THREE.AmbientLight(0xfff4e5, 0.6);
        scene.add(ambient);
        let dirLight = new THREE.DirectionalLight(0xffcc99, 1.2);
        dirLight.position.set(80, 100, -60);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        scene.add(dirLight);
        loadMap(currentMap);
        localTank = createTank(playerData.color);
        // Place local tank randomly within overall bounds: x [-500,500], z [-250,250]
        localTank.position.set(
          Math.random() * 1000 - 500,
          0,
          Math.random() * 500 - 250
        );
        scene.add(localTank);
        addNicknameLabel(localTank, playerData.nickname);
        setupWebSocket();
        // Apply randomized weather
        currentWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
        applyWeather(currentWeather);
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', onKeyDown, false);
        window.addEventListener('keyup', onKeyUp, false);
        animate();
      }
      init();
    });
  </script>
</body>
</html>
