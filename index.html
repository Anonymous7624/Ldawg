<!DOCTYPE html>
<html lang="en">
<head>
  <script>
  // Redirect to join.html if no nickname is stored
  if (!localStorage.getItem('nickname')) {
    window.location.href = "join.html";
  }
</script>

  <meta charset="UTF-8">
  <title>3D Multiplayer Tank Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    /* Chat Input (hidden by default) */
    #chatInput {
      position: fixed;
      bottom: 210px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      padding: 8px;
      font-size: 16px;
      z-index: 110;
    }
    /* Kill Feed in top-right */
    #killFeed {
      position: fixed;
      top: 10px;
      right: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 110;
    }
    /* Minimap in top-left */
    #minimap {
      position: fixed;
      top: 10px;
      left: 10px;
      border: 2px solid #fff;
      background: rgba(0,0,0,0.5);
      z-index: 110;
    }
    /* Global Chat Log at the bottom */
    #globalChatLog {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      z-index: 105;
    }
  </style>
</head>
<body>
  <input type="text" id="chatInput" placeholder="Type a message and hit Enter">
  <div id="killFeed"></div>
  <canvas id="minimap" width="200" height="200"></canvas>
  <div id="globalChatLog"></div>
  
  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // -----------------------
      // Global Variables & Setup
      // -----------------------
      let scene, camera, renderer, localTank, clock;
      let remoteTanks = {}; // key: player id, value: {mesh, nickname}
      let killFeedMessages = []; // kill feed messages
      let ws;
      let cameraMode = 1; // 1: third-person, 2: first-person turret, 3: top-down
      let currentMap = 'desert'; // 'desert', 'grass', 'city'
      let weather = null;
      const controls = { forward: false, backward: false, left: false, right: false, shoot: false };

      // Retrieve nickname from localStorage (or use a fallback)
      const storedNickname = localStorage.getItem('nickname');
      const playerData = {
        id: Math.floor(Math.random()*1000000).toString(),
        nickname: storedNickname ? storedNickname : 'Player' + Math.floor(Math.random()*1000),
        color: '#' + Math.floor(Math.random()*16777215).toString(16),
        health: 100
      };

      // WebSocket URL â€“ using your Cloudflare Tunnel (secure)
      const WS_URL = "wss://game.ldawg7624.com";

      // -----------------------
      // Initialization
      // -----------------------
      function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.002);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, -10);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, -50);
        scene.add(directionalLight);
        
        loadMap(currentMap);
        
        localTank = createTank(playerData.color);
        localTank.position.set(0, 0.5, 0);
        scene.add(localTank);
        addNicknameLabel(localTank, playerData.nickname);
        
        setupWebSocket();
        
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', onKeyDown, false);
        window.addEventListener('keyup', onKeyUp, false);
        
        animate();
      }
      
      // -----------------------
      // Map Loading & Weather
      // -----------------------
      function loadMap(mapType) {
        let mapGroup = scene.getObjectByName("mapGroup");
        if (mapGroup) { scene.remove(mapGroup); }
        mapGroup = new THREE.Group();
        mapGroup.name = "mapGroup";
        
        let groundGeometry, groundMaterial;
        switch(mapType) {
          case 'desert':
            groundGeometry = new THREE.PlaneGeometry(200, 200, 10, 10);
            groundMaterial = new THREE.MeshLambertMaterial({ color: 0xEDC9AF });
            scene.fog.color.setHex(0xEDC9AF);
            break;
          case 'grass':
            groundGeometry = new THREE.PlaneGeometry(200, 200, 10, 10);
            groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7CFC00 });
            scene.fog.color.setHex(0x7CFC00);
            break;
          case 'city':
            groundGeometry = new THREE.PlaneGeometry(200, 200, 10, 10);
            groundMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            scene.fog.color.setHex(0x808080);
            break;
          default:
            groundGeometry = new THREE.PlaneGeometry(200, 200);
            groundMaterial = new THREE.MeshLambertMaterial({ color: 0x999999 });
        }
        let ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        mapGroup.add(ground);
        
        // Add structures: bunkers, hills, city buildings, trees
        for (let i = 0; i < 10; i++) {
          let boxGeom = new THREE.BoxGeometry(5, 3, 5);
          let boxMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
          let box = new THREE.Mesh(boxGeom, boxMat);
          box.position.set((Math.random()-0.5)*150, 1.5, (Math.random()-0.5)*150);
          mapGroup.add(box);
        }
        // Optionally add trees (simple cylinders & cones)
        for (let i = 0; i < 5; i++) {
          let trunkGeom = new THREE.CylinderGeometry(0.5, 0.5, 3);
          let trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
          let trunk = new THREE.Mesh(trunkGeom, trunkMat);
          trunk.position.set((Math.random()-0.5)*150, 1.5, (Math.random()-0.5)*150);
          let foliageGeom = new THREE.ConeGeometry(2, 4);
          let foliageMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
          let foliage = new THREE.Mesh(foliageGeom, foliageMat);
          foliage.position.set(0, 3.5, 0);
          trunk.add(foliage);
          mapGroup.add(trunk);
        }
        scene.add(mapGroup);
        
        // Random weather (30% chance)
        let weatherRoll = Math.random();
        if (weatherRoll < 0.3) {
          weather = ['rain','fog','sandstorm'][Math.floor(Math.random()*3)];
          applyWeather(weather);
        } else {
          weather = null;
          scene.fog.density = 0.002;
        }
      }
      
      function applyWeather(type) {
        switch(type) {
          case 'rain':
            scene.fog.density = 0.005;
            break;
          case 'fog':
            scene.fog.density = 0.01;
            break;
          case 'sandstorm':
            scene.fog.density = 0.02;
            break;
        }
      }
      
      // -----------------------
      // Tank Creation & Labels
      // -----------------------
      function createTank(color) {
        let tankGroup = new THREE.Group();
        let bodyGeom = new THREE.BoxGeometry(2, 1, 3);
        let bodyMat = new THREE.MeshLambertMaterial({ color: color });
        let body = new THREE.Mesh(bodyGeom, bodyMat);
        body.position.y = 0.5;
        tankGroup.add(body);
        let turretGeom = new THREE.BoxGeometry(1, 0.5, 1.5);
        let turretMat = new THREE.MeshLambertMaterial({ color: color });
        let turret = new THREE.Mesh(turretGeom, turretMat);
        turret.position.y = 1;
        tankGroup.add(turret);
        return tankGroup;
      }
      
      function addNicknameLabel(tank, nickname) {
        let canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 64;
        let context = canvas.getContext('2d');
        context.fillStyle = "rgba(0,0,0,0.5)";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.font = "30px Arial";
        context.fillStyle = "#ffffff";
        context.textAlign = "center";
        context.fillText(nickname, canvas.width/2, canvas.height/2 + 10);
        let texture = new THREE.CanvasTexture(canvas);
        let spriteMat = new THREE.SpriteMaterial({ map: texture });
        let sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(4, 1, 1);
        sprite.position.set(0, 2.5, 0);
        tank.add(sprite);
      }
      
      // -----------------------
      // Window Resize
      // -----------------------
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      // -----------------------
      // Keyboard Input
      // -----------------------
      function onKeyDown(e) {
        // Open chat input when "T" is pressed if not already focused
        if (e.code === "KeyT" && document.activeElement !== chatInput) {
          toggleChat();
          return;
        }
        // Block movement if chat input is active
        if (document.activeElement === chatInput) return;
        switch(e.code) {
          case "KeyW": controls.forward = true; break;
          case "KeyS": controls.backward = true; break;
          case "KeyA": controls.left = true; break;
          case "KeyD": controls.right = true; break;
          case "Space": 
            controls.shoot = true;
            sendShoot();
            break;
          case "Digit1": cameraMode = 1; break;
          case "Digit2": cameraMode = 2; break;
          case "Digit3": cameraMode = 3; break;
        }
      }
      
      function onKeyUp(e) {
        switch(e.code) {
          case "KeyW": controls.forward = false; break;
          case "KeyS": controls.backward = false; break;
          case "KeyA": controls.left = false; break;
          case "KeyD": controls.right = false; break;
          case "Space": controls.shoot = false; break;
        }
      }
      
      // -----------------------
      // Chat Input Handling
      // -----------------------
      const chatInput = document.getElementById("chatInput");
      chatInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter") {
          if (chatInput.value.trim() !== "") {
            sendChat(chatInput.value.trim());
            chatInput.value = "";
          }
          chatInput.style.display = "none";
        }
      });
      
      function toggleChat() {
        if (chatInput.style.display === "none" || chatInput.style.display === "") {
          chatInput.style.display = "block";
          chatInput.focus();
        } else {
          chatInput.style.display = "none";
        }
      }
      
      // -----------------------
      // WebSocket Communication
      // -----------------------
      function setupWebSocket() {
        ws = new WebSocket(WS_URL);
        ws.onopen = () => {
          ws.send(JSON.stringify({
            type: "join",
            id: playerData.id,
            nickname: playerData.nickname,
            color: playerData.color,
            position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z }
          }));
        };
        ws.onmessage = (event) => {
          let msg = JSON.parse(event.data);
          handleServerMessage(msg);
        };
        ws.onclose = () => {
          console.log("Disconnected from server.");
        };
      }
      
      function handleServerMessage(msg) {
        switch(msg.type) {
          case "update":
            if (msg.id !== playerData.id) {
              updateRemoteTank(msg);
            }
            break;
          case "chat":
            // Show chat bubble and add to global chat log
            displayChatBubble(msg);
            addGlobalChatMessage(`${msg.nickname}: ${msg.message}`);
            break;
          case "shoot":
            addKillFeed(`${msg.nickname} fired!`);
            break;
          case "kill":
            addKillFeed(`${msg.killer} eliminated ${msg.victim}`);
            break;
          case "join":
            if (msg.id !== playerData.id && !remoteTanks[msg.id]) {
              let tank = createTank(msg.color);
              tank.position.set(msg.position.x, msg.position.y, msg.position.z);
              scene.add(tank);
              addNicknameLabel(tank, msg.nickname);
              remoteTanks[msg.id] = { mesh: tank, nickname: msg.nickname };
            }
            break;
          case "leave":
            if (remoteTanks[msg.id]) {
              scene.remove(remoteTanks[msg.id].mesh);
              delete remoteTanks[msg.id];
            }
            break;
        }
      }
      
      function updateRemoteTank(data) {
        if (!remoteTanks[data.id]) {
          let tank = createTank(data.color);
          tank.position.set(data.position.x, data.position.y, data.position.z);
          scene.add(tank);
          addNicknameLabel(tank, data.nickname);
          remoteTanks[data.id] = { mesh: tank, nickname: data.nickname };
        } else {
          remoteTanks[data.id].mesh.position.set(data.position.x, data.position.y, data.position.z);
          remoteTanks[data.id].mesh.rotation.y = data.rotation;
        }
      }
      
      function sendUpdate() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "update",
            id: playerData.id,
            position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
            rotation: localTank.rotation.y
          }));
        }
      }
      
      function sendChat(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "chat",
            id: playerData.id,
            nickname: playerData.nickname,
            message: message
          }));
          // Optionally display local chat bubble immediately
          displayChatBubble({ id: playerData.id, nickname: playerData.nickname, message: message });
          addGlobalChatMessage(`${playerData.nickname}: ${message}`);
        }
      }
      
      function sendShoot() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "shoot",
            id: playerData.id,
            nickname: playerData.nickname,
            position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
            rotation: localTank.rotation.y
          }));
        }
      }
      
      // -----------------------
      // Floating Chat Bubbles & Kill Feed
      // -----------------------
      function displayChatBubble(msg) {
        // Attach the chat bubble to the correct tank (local or remote)
        let targetTank = (msg.id === playerData.id) ? localTank : (remoteTanks[msg.id] ? remoteTanks[msg.id].mesh : null);
        if (!targetTank) return;
        
        let canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 64;
        let context = canvas.getContext('2d');
        context.fillStyle = "rgba(0,0,0,0.6)";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.font = "20px Arial";
        context.fillStyle = "#ffffff";
        context.textAlign = "center";
        context.fillText(msg.message, canvas.width/2, canvas.height/2 + 8);
        let texture = new THREE.CanvasTexture(canvas);
        let spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        let sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(4, 1, 1);
        sprite.position.set(0, 3, 0);
        targetTank.add(sprite);
        
        // Remove the bubble after 3 seconds
        setTimeout(() => { targetTank.remove(sprite); }, 3000);
      }
      
      function addKillFeed(text) {
        killFeedMessages.push(text);
        const feedDiv = document.getElementById("killFeed");
        feedDiv.innerHTML = killFeedMessages.slice(-5).join("<br>");
      }
      
      function addGlobalChatMessage(text) {
        const chatLog = document.getElementById("globalChatLog");
        const messageElem = document.createElement("div");
        messageElem.textContent = text;
        chatLog.appendChild(messageElem);
        // Auto-scroll to bottom
        chatLog.scrollTop = chatLog.scrollHeight;
      }
      
      // -----------------------
      // Animation Loop & Controls
      // -----------------------
      function animate() {
        requestAnimationFrame(animate);
        let delta = clock.getDelta();
        let moveSpeed = 10 * delta;
        if (controls.forward) { localTank.translateZ(moveSpeed); }
        if (controls.backward) { localTank.translateZ(-moveSpeed); }
        if (controls.left) { localTank.rotation.y += 2 * delta; }
        if (controls.right) { localTank.rotation.y -= 2 * delta; }
        updateCamera();
        
        // Ensure nickname labels face the camera (local and remote)
        localTank.children.forEach(child => {
          if (child.type === "Sprite") { child.lookAt(camera.position); }
        });
        for (let id in remoteTanks) {
          remoteTanks[id].mesh.children.forEach(child => {
            if (child.type === "Sprite") { child.lookAt(camera.position); }
          });
        }
        
        sendUpdate();
        renderer.render(scene, camera);
        updateMinimap();
      }
      
      function updateCamera() {
        if (cameraMode === 1) {
          const relativeCameraOffset = new THREE.Vector3(0, 5, -10);
          const cameraOffset = relativeCameraOffset.applyMatrix4(localTank.matrixWorld);
          camera.position.lerp(cameraOffset, 0.1);
          camera.lookAt(localTank.position);
        } else if (cameraMode === 2) {
          let offset = new THREE.Vector3(0, 2, 0);
          let pos = localTank.localToWorld(offset.clone());
          camera.position.lerp(pos, 0.1);
          let lookAtPos = new THREE.Vector3(0, 2, 10).applyMatrix4(localTank.matrixWorld);
          camera.lookAt(lookAtPos);
        } else if (cameraMode === 3) {
          let pos = localTank.position.clone();
          pos.y += 30;
          camera.position.lerp(pos, 0.1);
          camera.lookAt(localTank.position);
        }
      }
      
      // -----------------------
      // Minimap Update
      // -----------------------
      function updateMinimap() {
        let minimap = document.getElementById("minimap");
        let ctx = minimap.getContext("2d");
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0, 0, minimap.width, minimap.height);
        let centerX = minimap.width/2;
        let centerY = minimap.height/2;
        ctx.fillStyle = playerData.color;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 5, 0, Math.PI*2);
        ctx.fill();
        const scale = 0.5;
        for (let id in remoteTanks) {
          let pos = remoteTanks[id].mesh.position;
          let dx = (pos.x - localTank.position.x) * scale;
          let dz = (pos.z - localTank.position.z) * scale;
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(centerX + dx, centerY + dz, 5, 0, Math.PI*2);
          ctx.fill();
        }
      }
      
      // -----------------------
      // Map Switching (every 3 minutes)
      // -----------------------
      setInterval(() => {
        const maps = ['desert', 'grass', 'city'];
        currentMap = maps[Math.floor(Math.random()*maps.length)];
        loadMap(currentMap);
      }, 180000);
      
      // -----------------------
      // Start Everything
      // -----------------------
      init();
    });
  </script>
</body>
</html>
