<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kennedy Chat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      height: 100vh;
      overflow: hidden;
      transition: background 0.3s ease;
    }

    body.light-mode {
      background: linear-gradient(135deg, #e0f4ff 0%, #ffffff 100%);
      color: #333;
    }

    body.dark-mode {
      background: linear-gradient(135deg, #001a33 0%, #003366 100%);
      color: #ffffff;
    }

    .container {
      display: flex;
      height: 100vh;
      max-width: 1400px;
      margin: 0 auto;
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      min-width: 0;
    }

    .sidebar {
      width: 300px;
      padding: 20px;
      border-left: 1px solid rgba(0, 0, 0, 0.1);
      overflow-y: auto;
    }

    body.dark-mode .sidebar {
      border-left-color: rgba(255, 255, 255, 0.2);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 28px;
      font-weight: 600;
    }

    .dark-mode-toggle {
      background: rgba(0, 0, 0, 0.1);
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    body.dark-mode .dark-mode-toggle {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .dark-mode-toggle:hover {
      transform: scale(1.05);
    }

    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 15px;
      padding: 20px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .chat-container {
      background: rgba(0, 26, 51, 0.5);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .messages {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 20px;
      padding-right: 10px;
    }

    .messages::-webkit-scrollbar {
      width: 8px;
    }

    .messages::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
    }

    .messages::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }

    body.dark-mode .messages::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .messages::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
    }

    .message {
      margin-bottom: 15px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 10px;
      animation: slideIn 0.3s ease;
    }

    body.dark-mode .message {
      background: rgba(255, 255, 255, 0.1);
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
      opacity: 0.7;
    }

    .nickname {
      font-weight: 600;
      color: #0066cc;
    }

    body.dark-mode .nickname {
      color: #66b3ff;
    }

    .timestamp {
      font-size: 11px;
    }

    .message-content {
      word-wrap: break-word;
      line-height: 1.5;
    }

    .message-image {
      margin-top: 10px;
      max-width: 192px;
      max-height: 256px;
      cursor: pointer;
      border-radius: 8px;
      object-fit: cover;
      transition: transform 0.2s ease;
    }

    .message-image:hover {
      transform: scale(1.02);
    }

    .message-file {
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      display: inline-block;
    }

    body.dark-mode .message-file {
      background: rgba(255, 255, 255, 0.1);
    }

    .message-file a {
      color: #0066cc;
      text-decoration: none;
      font-weight: 500;
    }

    body.dark-mode .message-file a {
      color: #66b3ff;
    }

    .file-info {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 5px;
    }

    .input-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .photo-composer {
      display: none;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
    }

    body.dark-mode .photo-composer {
      background: rgba(255, 255, 255, 0.1);
    }

    .photo-composer.active {
      display: block;
    }

    .composer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 14px;
      font-weight: 600;
      opacity: 0.8;
    }

    .composer-preview {
      display: flex;
      gap: 15px;
      align-items: flex-start;
    }

    .preview-image {
      max-width: 150px;
      max-height: 150px;
      border-radius: 8px;
      object-fit: cover;
    }

    .preview-details {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .preview-filename {
      font-size: 13px;
      font-weight: 500;
      word-break: break-all;
    }

    .preview-size {
      font-size: 12px;
      opacity: 0.7;
    }

    .btn-remove {
      background: #dc3545;
      color: white;
      padding: 8px 16px;
      font-size: 13px;
    }

    .btn-remove:hover {
      background: #c82333;
    }

    .message-sending {
      opacity: 0.6;
    }

    .message-error {
      border-left: 3px solid #dc3545;
    }

    .message-status {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 5px;
      font-style: italic;
    }

    .input-row {
      display: flex;
      gap: 10px;
    }

    input[type="text"],
    textarea {
      flex: 1;
      padding: 12px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-family: inherit;
      transition: all 0.3s ease;
    }

    body.dark-mode input[type="text"],
    body.dark-mode textarea {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    input[type="text"]:focus,
    textarea:focus {
      outline: none;
      border-color: #0066cc;
    }

    body.dark-mode input[type="text"]:focus,
    body.dark-mode textarea:focus {
      border-color: #66b3ff;
    }

    textarea {
      resize: vertical;
      min-height: 60px;
    }

    .message-controls {
      display: flex;
      gap: 10px;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: #0066cc;
      color: white;
      flex: 1;
    }

    .btn-primary:hover:not(:disabled) {
      background: #0052a3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
    }

    .btn-icon {
      background: rgba(0, 0, 0, 0.1);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
    }

    body.dark-mode .btn-icon {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .btn-icon:hover:not(:disabled) {
      background: rgba(0, 0, 0, 0.2);
      transform: scale(1.1);
    }

    body.dark-mode .btn-icon:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.3);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .sidebar h2 {
      font-size: 18px;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid rgba(0, 102, 204, 0.3);
    }

    .sidebar-content {
      font-size: 14px;
      line-height: 1.8;
      opacity: 0.8;
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      position: relative;
    }

    body.dark-mode .modal-content {
      background: #003366;
    }

    .modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.2);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    body.dark-mode .modal-close {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .camera-preview {
      max-width: 100%;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .camera-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .fullscreen-image {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 10px;
    }

    .status-message {
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
    }

    .status-error {
      background: rgba(220, 53, 69, 0.2);
      color: #dc3545;
    }

    .status-success {
      background: rgba(40, 167, 69, 0.2);
      color: #28a745;
    }

    .status-muted {
      background: rgba(255, 193, 7, 0.2);
      color: #856404;
    }

    body.dark-mode .status-muted {
      color: #ffc107;
    }

    body.dark-mode .status-success {
      color: #4ade80;
    }

    .hidden {
      display: none;
    }

    input[type="file"] {
      display: none;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        border-left: none;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        max-height: 200px;
      }

      body.dark-mode .sidebar {
        border-top-color: rgba(255, 255, 255, 0.2);
      }
    }
  </style>
</head>
<body class="light-mode">
  <div class="container">
    <div class="main-content">
      <div class="header">
        <h1>Kennedy Chat</h1>
        <button class="dark-mode-toggle" onclick="toggleDarkMode()">Dark Mode</button>
      </div>

      <div class="chat-container">
        <div class="messages" id="messages"></div>

        <div id="statusMessage" class="hidden"></div>

        <div class="input-section">
          <input 
            type="text" 
            id="nickname" 
            placeholder="Your nickname (max 100 chars)" 
            maxlength="100"
            autocomplete="off"
          >
          
          <!-- Photo Composer Preview -->
          <div id="photoComposer" class="photo-composer">
            <div class="composer-header">
              <span>ðŸ“· Photo Attached</span>
              <button class="btn-remove" onclick="removePhotoAttachment()">Remove</button>
            </div>
            <div class="composer-preview">
              <img id="previewImage" class="preview-image" src="" alt="Preview">
              <div class="preview-details">
                <div class="preview-filename" id="previewFilename"></div>
                <div class="preview-size" id="previewSize"></div>
              </div>
            </div>
          </div>

          <div class="input-row">
            <textarea 
              id="messageInput" 
              placeholder="Type your message or caption (max 1000 chars)" 
              maxlength="1000"
            ></textarea>
          </div>
          <div class="message-controls">
            <button class="btn-icon" onclick="openCamera()" title="Take Photo" id="cameraBtn">
              Camera
            </button>
            <button class="btn-icon" onclick="document.getElementById('fileInput').click()" title="Upload File" id="fileBtn">
              File
            </button>
            <button class="btn-primary" onclick="sendMessage()" id="sendBtn">Send</button>
          </div>
          <input type="file" id="fileInput" onchange="handleFileSelect()" accept="image/*">
        </div>
      </div>
    </div>

    <div class="sidebar">
      <h2 style="font-size: 22px; font-weight: 700;">Rules</h2>
      <div class="sidebar-content" style="margin-bottom: 25px;">
        <p>No spamming. Violators will be muted for 60 seconds.</p>
      </div>
      
      <h2 style="font-size: 22px; font-weight: 700;">Benefits</h2>
      <div class="sidebar-content">
        <ul style="list-style: disc; padding-left: 20px; line-height: 2;">
          <li>No moderators</li>
          <li>No login needed</li>
          <li>Photo and GIF uploads</li>
          <li>Cleaner UI and Dark Mode</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Camera Modal -->
  <div id="cameraModal" class="modal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeCamera()">Ã—</button>
      <h2 style="margin-bottom: 20px;">Take a Photo</h2>
      <video id="cameraPreview" class="camera-preview" autoplay playsinline></video>
      <canvas id="cameraCanvas" style="display: none;"></canvas>
      <div class="camera-controls">
        <button class="btn-primary" onclick="capturePhoto()">Capture</button>
        <button onclick="closeCamera()" style="background: #6c757d; color: white;">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Image Preview Modal -->
  <div id="imageModal" class="modal" onclick="closeImagePreview()">
    <div class="modal-content" onclick="event.stopPropagation()">
      <button class="modal-close" onclick="closeImagePreview()">Ã—</button>
      <img id="fullscreenImage" class="fullscreen-image" src="" alt="Full size image">
    </div>
  </div>

  <script>
    let ws;
    let reconnectTimeout;
    let muteTimer;
    let cameraStream;
    const isDarkMode = localStorage.getItem('darkMode') === 'true';

    // Photo composer state
    let selectedFile = null;
    let previewURL = null;
    let pendingMessages = new Map(); // Map of client message ID to {data, timeout}

    // Apply saved theme
    if (isDarkMode) {
      document.body.className = 'dark-mode';
      document.querySelector('.dark-mode-toggle').textContent = 'Light Mode';
    }

    // WebSocket configuration
    const WS_URL = 'wss://ws.ldawg7624.com';
    
    // Upload configuration
    const UPLOAD_URL = 'https://upload.ldawg7624.com/upload';

    // Generate UUID v4
    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    // Connect to WebSocket
    function connect() {
      console.log('[CONNECT] Attempting WebSocket connection to:', WS_URL);
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log('[CONNECT] âœ“ WebSocket connection OPEN');
        clearTimeout(reconnectTimeout);
        
        // Send a ping to verify ACK path works (self-test)
        const pingId = generateUUID();
        const pingMessage = {
          type: 'ping',
          id: pingId,
          messageId: pingId,
          timestamp: Date.now()
        };
        
        console.log('[SELF-TEST] Sending ping with id=' + pingId);
        
        // Set timeout for ping ACK response
        const pingTimeout = setTimeout(() => {
          if (pendingMessages.has(pingId)) {
            console.error('[SELF-TEST] âŒ FAILED - No ACK received for ping within 1s');
            showStatus('Connected but ACK path not working', 'error');
            pendingMessages.delete(pingId);
          }
        }, 1000); // 1 second timeout for self-test
        
        pendingMessages.set(pingId, { 
          type: 'ping', 
          testPing: true,
          timeout: pingTimeout 
        });
        
        ws.send(JSON.stringify(pingMessage));
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        console.log('[WS] RX type=' + data.type + ' id=' + (data.id || data.messageId || 'none'));
        
        if (data.type === 'history') {
          console.log('[WS] History received:', data.items.length, 'items');
          displayHistory(data.items);
        } else if (data.type === 'ack') {
          // Handle ACK from server - backward compatible with both messageId and id
          const ackId = data.messageId || data.id;
          console.log('[ACK] âœ“ Received ACK for msgId=' + ackId);
          
          if (!ackId) {
            console.error('[ACK] ERROR: ACK has no messageId or id field!');
            return;
          }
          
          // Check if this is a ping ACK (self-test)
          const pendingMsg = pendingMessages.get(ackId);
          if (pendingMsg && pendingMsg.testPing) {
            console.log('[SELF-TEST] âœ“ Ping ACK received - connection verified!');
            if (pendingMsg.timeout) {
              clearTimeout(pendingMsg.timeout);
            }
            pendingMessages.delete(ackId);
            showStatus('Connected âœ“', 'success');
            return;
          }
          
          // Update UI for regular messages
          const msgElement = document.querySelector(`[data-msg-id="${ackId}"]`);
          if (msgElement) {
            msgElement.classList.remove('message-sending');
            const statusSpan = msgElement.querySelector('.message-status');
            if (statusSpan) {
              statusSpan.textContent = 'Sent âœ“';
              setTimeout(() => statusSpan.remove(), 2000);
            }
            console.log('[ACK] Message marked as SENT in UI');
          }
          
          // Clear timeout and remove from pending
          if (pendingMsg && pendingMsg.timeout) {
            clearTimeout(pendingMsg.timeout);
          }
          pendingMessages.delete(ackId);
          
        } else if (data.type === 'pong') {
          // Legacy pong support (ignore, we use ACK for self-test)
          console.log('[PONG] Received legacy pong (ignored)');
        } else if (data.type === 'text' || data.type === 'image' || data.type === 'file') {
          // Check if this is our own message (already displayed optimistically)
          if (pendingMessages.has(data.id)) {
            console.log('[WS] Received broadcast of our own message id=' + data.id);
            // Update the element with server data
            const msgElement = document.querySelector(`[data-msg-id="${data.id}"]`);
            if (msgElement && data.type === 'image') {
              const img = msgElement.querySelector('.message-image');
              if (img && data.url) {
                img.src = data.url;
                img.onclick = () => openImagePreview(data.url);
              }
            }
          } else {
            // Message from another client
            console.log('[WS] New message from another client');
            addMessage(data);
          }
        } else if (data.type === 'muted') {
          handleMuted(data);
        }
      };

      ws.onclose = (event) => {
        console.log('[CLOSE] WebSocket connection closed, code=' + event.code);
        showStatus('Disconnected. Reconnecting...', 'error');
        reconnectTimeout = setTimeout(connect, 3000);
      };

      ws.onerror = (error) => {
        console.error('[ERROR] WebSocket error:', error);
        showStatus('Connection error', 'error');
      };
    }

    function showStatus(message, type) {
      const statusDiv = document.getElementById('statusMessage');
      const statusClass = type === 'error' ? 'status-error' : 
                         type === 'success' ? 'status-success' : 'status-muted';
      statusDiv.className = `status-message ${statusClass}`;
      statusDiv.textContent = message;
      statusDiv.classList.remove('hidden');
      
      if (type === 'success') {
        setTimeout(() => {
          statusDiv.classList.add('hidden');
        }, 2000);
      }
    }

    connect();

    function displayHistory(items) {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.innerHTML = '';
      items.forEach(item => addMessage(item, false));
      scrollToBottom();
    }

    function addMessage(data, scroll = true, messageId = null, status = 'sent') {
      const messagesDiv = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      
      if (status === 'sending') {
        messageDiv.classList.add('message-sending');
      } else if (status === 'error') {
        messageDiv.classList.add('message-error');
      }
      
      // Store message ID for ACK matching
      if (messageId || data.id) {
        messageDiv.setAttribute('data-msg-id', messageId || data.id);
      }

      const timestamp = new Date(data.timestamp).toLocaleString();
      
      let content = '';
      if (data.type === 'text') {
        content = `<div class="message-content">${escapeHtml(data.text)}</div>`;
      } else if (data.type === 'image') {
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        const imgId = 'img-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        content = `
          ${caption}
          <img id="${imgId}" src="${data.url}" class="message-image" data-url="${data.url}" alt="${escapeHtml(data.filename || 'Image')}">
        `;
      } else if (data.type === 'file') {
        const sizeStr = formatFileSize(data.size);
        content = `
          <div class="message-content">Shared a file</div>
          <div class="message-file">
            <a href="${data.url}" download="${escapeHtml(data.filename)}">${escapeHtml(data.filename)}</a>
            <div class="file-info">${sizeStr} Â· ${data.mime}</div>
          </div>
        `;
      }
      
      let statusHTML = '';
      if (status === 'sending') {
        statusHTML = '<div class="message-status">Sending...</div>';
      } else if (status === 'error') {
        statusHTML = '<div class="message-status">Failed to send</div>';
      }

      messageDiv.innerHTML = `
        <div class="message-header">
          <span class="nickname">${escapeHtml(data.nickname)}</span>
          <span class="timestamp">${timestamp}</span>
        </div>
        ${content}
        ${statusHTML}
      `;

      messagesDiv.appendChild(messageDiv);
      
      // Add click handler for images
      if (data.type === 'image') {
        const imgId = 'img-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        const imgElement = document.getElementById(imgId);
        if (imgElement) {
          imgElement.addEventListener('click', function() {
            openImagePreview(this.src);
          });
        }
      }
      
      if (scroll) {
        scrollToBottom();
      }
      
      return messageDiv;
    }

    async function sendMessage() {
      const nicknameInput = document.getElementById('nickname');
      const messageInput = document.getElementById('messageInput');
      const text = messageInput.value.trim();

      // Check if we have a photo attachment or text
      if (!text && !selectedFile) {
        return;
      }

      if (ws.readyState !== WebSocket.OPEN) {
        showStatus('Not connected. Please wait...', 'error');
        return;
      }

      const nickname = (nicknameInput.value.trim() || 'Anonymous').substring(0, 100);
      const messageId = generateUUID();
      const timestamp = Date.now();

      // Disable send button during operation
      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      try {
        if (selectedFile) {
          // Photo upload flow
          console.log('[SEND] Uploading photo with caption:', text.substring(0, 50));
          
          // Show optimistic message
          const optimisticData = {
            type: 'image',
            id: messageId,
            nickname,
            timestamp,
            url: previewURL,
            filename: selectedFile.name,
            caption: text || '',
            size: selectedFile.size
          };
          
          addMessage(optimisticData, true, messageId, 'sending');
          
          // Set timeout for ACK (1 second)
          const ackTimeout = setTimeout(() => {
            if (pendingMessages.has(messageId)) {
              console.error('[SEND] ACK timeout for message:', messageId);
              const elem = document.querySelector(`[data-msg-id="${messageId}"]`);
              if (elem) {
                elem.classList.remove('message-sending');
                elem.classList.add('message-error');
                const statusSpan = elem.querySelector('.message-status');
                if (statusSpan) {
                  statusSpan.textContent = 'Failed to send (no ACK)';
                }
              }
              pendingMessages.delete(messageId);
            }
          }, 1000);
          
          pendingMessages.set(messageId, { data: optimisticData, timeout: ackTimeout });
          
          // Clear input and composer immediately
          messageInput.value = '';
          
          // Store the file reference before removing composer
          const fileToUpload = selectedFile;
          
          // Upload the file
          const formData = new FormData();
          formData.append('file', fileToUpload);
          
          console.log('[UPLOAD] Uploading to:', UPLOAD_URL);
          
          const response = await fetch(UPLOAD_URL, {
            method: 'POST',
            body: formData
          });

          console.log('[UPLOAD] Response status:', response.status);
          
          if (!response.ok) {
            clearTimeout(ackTimeout);
            pendingMessages.delete(messageId);
            throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
          }

          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('[UPLOAD] Error - expected JSON but got:', text.substring(0, 200));
            clearTimeout(ackTimeout);
            pendingMessages.delete(messageId);
            throw new Error('Server returned non-JSON response');
          }

          const result = await response.json();
          console.log('[UPLOAD] Result:', result);

          if (result.success || result.ok) {
            // Upload successful - send via WebSocket
            const wsMessage = {
              type: 'image',
              id: messageId,
              messageId: messageId,
              nickname,
              timestamp,
              url: result.url,
              filename: result.filename || result.name,
              mime: result.mime,
              size: result.size,
              caption: text || ''
            };
            
            ws.send(JSON.stringify(wsMessage));
            console.log('[SEND] Photo message sent via WebSocket, id=' + messageId);
            
            // Clean up the preview
            removePhotoAttachment();
            
            // Update the optimistic message to show the real URL
            const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
            if (msgElement) {
              const img = msgElement.querySelector('.message-image');
              if (img) {
                img.src = result.url;
                img.setAttribute('data-url', result.url);
              }
            }
          } else {
            clearTimeout(ackTimeout);
            pendingMessages.delete(messageId);
            throw new Error(result.error || 'Upload failed');
          }
        } else {
          // Text-only message
          console.log('[SEND] Sending text message id=' + messageId);
          
          const messageData = {
            type: 'text',
            id: messageId,
            messageId: messageId,
            nickname,
            timestamp,
            text: text.substring(0, 1000)
          };
          
          // Add to UI immediately with "sending" status
          addMessage(messageData, true, messageId, 'sending');
          
          // Set timeout for ACK (1 second)
          const ackTimeout = setTimeout(() => {
            if (pendingMessages.has(messageId)) {
              console.error('[SEND] âŒ ACK TIMEOUT - No ACK received for message:', messageId);
              const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
              if (msgElement) {
                msgElement.classList.remove('message-sending');
                msgElement.classList.add('message-error');
                const statusSpan = msgElement.querySelector('.message-status');
                if (statusSpan) {
                  statusSpan.textContent = 'Failed to send (no ACK)';
                }
              }
              pendingMessages.delete(messageId);
            }
          }, 1000);
          
          pendingMessages.set(messageId, { data: messageData, timeout: ackTimeout });
          
          // Clear input immediately
          messageInput.value = '';
          
          // Send via WebSocket
          ws.send(JSON.stringify(messageData));
          console.log('[SEND] âœ“ Message sent via WebSocket, waiting for ACK...');
        }
      } catch (error) {
        console.error('[SEND] Error:', error);
        showStatus('Send failed: ' + error.message, 'error');
        
        // Mark message as error
        const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
        if (msgElement) {
          msgElement.classList.remove('message-sending');
          msgElement.classList.add('message-error');
          const statusSpan = msgElement.querySelector('.message-status');
          if (statusSpan) {
            statusSpan.textContent = 'Failed to send';
          }
        }
        
        // Clean up pending message
        const pending = pendingMessages.get(messageId);
        if (pending && pending.timeout) {
          clearTimeout(pending.timeout);
        }
        pendingMessages.delete(messageId);
      } finally {
        sendBtn.disabled = false;
      }
    }

    function handleMuted(data) {
      const statusDiv = document.getElementById('statusMessage');
      statusDiv.className = 'status-message status-muted';
      statusDiv.textContent = `Rate limit exceeded! Muted for ${data.seconds} seconds. Strikes: ${data.strikes}`;
      statusDiv.classList.remove('hidden');

      // Disable inputs
      disableInputs(true);

      // Clear existing timer
      clearTimeout(muteTimer);

      // Start countdown
      let remaining = data.seconds;
      const countdownInterval = setInterval(() => {
        remaining--;
        if (remaining > 0) {
          statusDiv.textContent = `Rate limit exceeded! Muted for ${remaining} seconds. Strikes: ${data.strikes}`;
        } else {
          clearInterval(countdownInterval);
        }
      }, 1000);

      // Re-enable after mute period
      muteTimer = setTimeout(() => {
        statusDiv.classList.add('hidden');
        disableInputs(false);
      }, data.seconds * 1000);
    }

    function disableInputs(disabled) {
      document.getElementById('sendBtn').disabled = disabled;
      document.getElementById('messageInput').disabled = disabled;
      document.getElementById('cameraBtn').disabled = disabled;
      document.getElementById('fileBtn').disabled = disabled;
    }

    function handleFileSelect() {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      
      if (!file) return;

      if (file.size > 10 * 1024 * 1024) {
        showStatus('File size must be less than 10MB', 'error');
        fileInput.value = '';
        return;
      }

      // Store the file and show preview
      selectedFile = file;
      
      // Revoke previous preview URL if exists
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
      }
      
      // Create preview URL
      previewURL = URL.createObjectURL(file);
      
      // Update composer UI
      const composer = document.getElementById('photoComposer');
      const previewImg = document.getElementById('previewImage');
      const previewFilename = document.getElementById('previewFilename');
      const previewSize = document.getElementById('previewSize');
      
      previewImg.src = previewURL;
      previewFilename.textContent = file.name;
      previewSize.textContent = formatFileSize(file.size);
      
      composer.classList.add('active');
      
      // Focus on message input for caption
      document.getElementById('messageInput').focus();
      
      console.log('Photo selected:', file.name, formatFileSize(file.size));
    }

    function removePhotoAttachment() {
      // Clean up
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
        previewURL = null;
      }
      
      selectedFile = null;
      
      // Clear file input
      document.getElementById('fileInput').value = '';
      
      // Hide composer
      const composer = document.getElementById('photoComposer');
      composer.classList.remove('active');
      
      console.log('Photo attachment removed');
    }

    async function openCamera() {
      try {
        const modal = document.getElementById('cameraModal');
        const video = document.getElementById('cameraPreview');
        
        cameraStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'user' },
          audio: false 
        });
        
        video.srcObject = cameraStream;
        modal.classList.add('active');
      } catch (error) {
        alert('Camera access denied or not available: ' + error.message);
      }
    }

    function closeCamera() {
      const modal = document.getElementById('cameraModal');
      const video = document.getElementById('cameraPreview');
      
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      
      video.srcObject = null;
      modal.classList.remove('active');
    }

    function capturePhoto() {
      const video = document.getElementById('cameraPreview');
      const canvas = document.getElementById('cameraCanvas');
      const context = canvas.getContext('2d');

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      context.drawImage(video, 0, 0);

      canvas.toBlob((blob) => {
        // Create a File object from the blob
        const file = new File([blob], `camera-${Date.now()}.jpg`, { type: 'image/jpeg' });
        
        // Store the file and show preview
        selectedFile = file;
        
        // Revoke previous preview URL if exists
        if (previewURL) {
          URL.revokeObjectURL(previewURL);
        }
        
        // Create preview URL
        previewURL = URL.createObjectURL(file);
        
        // Update composer UI
        const composer = document.getElementById('photoComposer');
        const previewImg = document.getElementById('previewImage');
        const previewFilename = document.getElementById('previewFilename');
        const previewSize = document.getElementById('previewSize');
        
        previewImg.src = previewURL;
        previewFilename.textContent = file.name;
        previewSize.textContent = formatFileSize(file.size);
        
        composer.classList.add('active');
        
        // Close camera modal
        closeCamera();
        
        // Focus on message input for caption
        document.getElementById('messageInput').focus();
        
        console.log('Photo captured:', file.name, formatFileSize(file.size));
      }, 'image/jpeg', 0.8);
    }

    function openImagePreview(url) {
      const modal = document.getElementById('imageModal');
      const img = document.getElementById('fullscreenImage');
      img.src = url;
      modal.classList.add('active');
    }

    function closeImagePreview() {
      const modal = document.getElementById('imageModal');
      modal.classList.remove('active');
    }

    function toggleDarkMode() {
      const body = document.body;
      const button = document.querySelector('.dark-mode-toggle');
      
      if (body.classList.contains('light-mode')) {
        body.className = 'dark-mode';
        button.textContent = 'Light Mode';
        localStorage.setItem('darkMode', 'true');
      } else {
        body.className = 'light-mode';
        button.textContent = 'Dark Mode';
        localStorage.setItem('darkMode', 'false');
      }
    }

    function scrollToBottom() {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Send message on Enter key
    document.getElementById('messageInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  </script>
</body>
</html>
