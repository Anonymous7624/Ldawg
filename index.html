<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Multiplayer Tank Game</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #222; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="info">
    Controls: WASD to move, SPACE/Mouse Click to shoot, T to chat
  </div>
  <!-- Load Three.js -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script>
    // Redirect if no nickname is stored
    if (!localStorage.getItem('nickname')) {
      window.location.href = "join.html";
    }
    const nickname = localStorage.getItem('nickname');
    const playerId = Math.floor(Math.random() * 1000000).toString();

    /*********** Scene, Camera, and Renderer Setup ***********/
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 10, 20);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Warm ambient and directional light (like a desert sun)
    const ambientLight = new THREE.AmbientLight(0xffcc66, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffcc66, 1);
    dirLight.position.set(20, 40, 10);
    scene.add(dirLight);

    /*********** Create a Canvas Texture for Sand ***********/
    const textureCanvas = document.createElement('canvas');
    textureCanvas.width = 512;
    textureCanvas.height = 512;
    const ctx = textureCanvas.getContext('2d');
    // Fill with a sandy tan color
    ctx.fillStyle = '#d2b48c';
    ctx.fillRect(0, 0, textureCanvas.width, textureCanvas.height);
    // Add random noise to simulate texture
    for (let i = 0; i < 10000; i++) {
      let x = Math.random() * textureCanvas.width;
      let y = Math.random() * textureCanvas.height;
      let alpha = Math.random() * 0.2;
      ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
      ctx.fillRect(x, y, 1, 1);
    }
    const sandTexture = new THREE.CanvasTexture(textureCanvas);
    sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping;
    sandTexture.repeat.set(50, 50);

    /*********** Create Terrain with Hills ***********/
    const groundGeo = new THREE.PlaneGeometry(200, 200, 100, 100);
    groundGeo.rotateX(-Math.PI / 2);
    const positions = groundGeo.attributes.position;
    // Use a sinusoidal function to create hills
    for (let i = 0; i < positions.count; i++) {
      const x = positions.getX(i);
      const z = positions.getZ(i);
      const height = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5;
      positions.setY(i, height);
    }
    positions.needsUpdate = true;
    const groundMat = new THREE.MeshStandardMaterial({ map: sandTexture });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.receiveShadow = true;
    scene.add(ground);

    // Helper function to compute terrain height at (x, z)
    function getHeight(x, z) {
      return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5;
    }

    /*********** Scatter Environment Objects (Rocks) ***********/
    function addRock(x, z) {
      const y = getHeight(x, z);
      const geometry = new THREE.DodecahedronGeometry(Math.random() * 0.5 + 0.5, 0);
      const material = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const rock = new THREE.Mesh(geometry, material);
      rock.position.set(x, y + 0.5, z);
      scene.add(rock);
    }
    for (let i = 0; i < 20; i++) {
      let x = Math.random() * 200 - 100;
      let z = Math.random() * 200 - 100;
      addRock(x, z);
    }

    /*********** Chat UI Setup ***********/
    const chatInput = document.createElement('input');
    chatInput.id = 'chatInput';
    chatInput.style.position = 'absolute';
    chatInput.style.bottom = '10px';
    chatInput.style.left = '10px';
    chatInput.style.width = '300px';
    chatInput.style.padding = '8px';
    chatInput.style.fontSize = '16px';
    chatInput.style.display = 'none';
    document.body.appendChild(chatInput);

    const chatLog = document.createElement('div');
    chatLog.id = 'chatLog';
    chatLog.style.position = 'absolute';
    chatLog.style.bottom = '50px';
    chatLog.style.left = '10px';
    chatLog.style.width = '300px';
    chatLog.style.maxHeight = '200px';
    chatLog.style.overflowY = 'auto';
    chatLog.style.background = 'rgba(0, 0, 0, 0.5)';
    chatLog.style.color = 'white';
    chatLog.style.fontFamily = 'sans-serif';
    chatLog.style.fontSize = '14px';
    chatLog.style.padding = '10px';
    document.body.appendChild(chatLog);

    function addChatMessage(text) {
      const messageElem = document.createElement('div');
      messageElem.textContent = text;
      chatLog.appendChild(messageElem);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Toggle chat input on pressing "t"
    document.addEventListener('keydown', (e) => {
      if (e.key === 't' && document.activeElement !== chatInput) {
        chatInput.style.display = 'block';
        chatInput.focus();
      }
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (chatInput.value.trim() !== '') {
          const message = chatInput.value.trim();
          const chatMsg = { type: "chat", id: playerId, nickname: nickname, message: message };
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(chatMsg));
          }
          addChatMessage(nickname + ": " + message);
          chatInput.value = '';
        }
        chatInput.style.display = 'none';
      }
    });

    /*********** Tank Creation ***********/
    function createTank(color) {
      const tank = new THREE.Group();
      // Tank body
      const bodyGeo = new THREE.BoxGeometry(4, 1, 6);
      const bodyMat = new THREE.MeshStandardMaterial({ color: color });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.5;
      tank.add(body);
      // Tank cannon
      const cannonGeo = new THREE.CylinderGeometry(0.3, 0.3, 4, 12);
      const cannonMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const cannon = new THREE.Mesh(cannonGeo, cannonMat);
      cannon.rotation.z = Math.PI / 2;
      cannon.position.set(0, 1, 3);
      tank.add(cannon);
      return tank;
    }

    const localTank = createTank(0x00ff00);
    // Place the local tank on the terrain
    localTank.position.set(0, getHeight(0, 0), 0);
    scene.add(localTank);

    // Add a floating nickname label
    function addNameLabel(tank, name) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = "30px Arial";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.fillText(name, canvas.width / 2, canvas.height / 2 + 10);
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMat = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMat);
      sprite.scale.set(4, 1, 1);
      sprite.position.set(0, 3, 0);
      tank.add(sprite);
    }
    addNameLabel(localTank, nickname);

    const remoteTanks = {};

    /*********** WebSocket Setup ***********/
    const ws = new WebSocket("ws://localhost:8080");
    ws.onopen = function() {
      const joinMsg = {
        type: "join",
        id: playerId,
        nickname: nickname,
        position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z }
      };
      ws.send(JSON.stringify(joinMsg));
    };

    ws.onmessage = function(event) {
      const msg = JSON.parse(event.data);
      if (msg.type === "chat") {
        addChatMessage(msg.nickname + ": " + msg.message);
      }
      if (msg.id === playerId) return;
      if (msg.type === "join") {
        if (!remoteTanks[msg.id]) {
          const remoteTank = createTank(0xff0000);
          remoteTank.position.set(msg.position.x, msg.position.y, msg.position.z);
          addNameLabel(remoteTank, msg.nickname);
          scene.add(remoteTank);
          remoteTanks[msg.id] = remoteTank;
        }
      } else if (msg.type === "update") {
        if (remoteTanks[msg.id]) {
          remoteTanks[msg.id].position.set(
            msg.position.x, msg.position.y, msg.position.z
          );
          remoteTanks[msg.id].rotation.y = msg.rotation;
        }
      } else if (msg.type === "shoot") {
        createMissile(msg.position, msg.rotation);
      } else if (msg.type === "leave") {
        if (remoteTanks[msg.id]) {
          scene.remove(remoteTanks[msg.id]);
          delete remoteTanks[msg.id];
        }
      }
    };

    /*********** Input Handling ***********/
    const controls = { forward: false, backward: false, left: false, right: false };

    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyW') controls.forward = true;
      if (e.code === 'KeyS') controls.backward = true;
      if (e.code === 'KeyA') controls.left = true;
      if (e.code === 'KeyD') controls.right = true;
      if (e.code === 'Space') shoot();
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') controls.forward = false;
      if (e.code === 'KeyS') controls.backward = false;
      if (e.code === 'KeyA') controls.left = false;
      if (e.code === 'KeyD') controls.right = false;
    });

    document.addEventListener('mousedown', () => { shoot(); });

    /*********** Camera Shake Function ***********/
    function cameraShake(intensity = 0.5, duration = 200) {
      const originalPos = camera.position.clone();
      let start = performance.now();
      function shake() {
        let now = performance.now();
        let elapsed = now - start;
        if (elapsed < duration) {
          camera.position.x = originalPos.x + (Math.random() - 0.5) * intensity;
          camera.position.y = originalPos.y + (Math.random() - 0.5) * intensity;
          camera.position.z = originalPos.z + (Math.random() - 0.5) * intensity;
          requestAnimationFrame(shake);
        } else {
          camera.position.copy(originalPos);
        }
      }
      shake();
    }

    /*********** Missile (Shooting) ***********/
    const missiles = [];
    function createMissile(startPos, rotation) {
      const geometry = new THREE.SphereGeometry(0.2, 8, 8);
      const material = new THREE.MeshStandardMaterial({ color: 0xffff00 });
      const missile = new THREE.Mesh(geometry, material);
      // Offset missile upward to avoid ground clipping
      missile.position.set(startPos.x, startPos.y + 1, startPos.z);
      const velocity = new THREE.Vector3(0, 0, 0.5);
      velocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
      missile.userData = { velocity: velocity };
      scene.add(missile);
      missiles.push(missile);
    }

    function shoot() {
      const startPos = new THREE.Vector3();
      startPos.copy(localTank.position);
      const offset = new THREE.Vector3(0, 1, 3);
      offset.applyEuler(localTank.rotation);
      startPos.add(offset);
      createMissile(startPos, localTank.rotation.y);
      // Minor recoil shake when firing
      cameraShake(0.2, 150);
      const shootMsg = {
        type: "shoot",
        id: playerId,
        position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
        rotation: localTank.rotation.y
      };
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(shootMsg));
      }
    }

    // Example function to simulate taking damage
    function takeDamage(amount) {
      // Process damage here...
      cameraShake(0.5, 300);
    }

    /*********** Movement and Update Loop ***********/
    const moveSpeed = 0.2;
    function updateMovement() {
      if (controls.forward) localTank.translateZ(moveSpeed);
      if (controls.backward) localTank.translateZ(-moveSpeed);
      if (controls.left) localTank.rotation.y += 0.05;
      if (controls.right) localTank.rotation.y -= 0.05;
      // Adjust tank height based on terrain
      localTank.position.y = getHeight(localTank.position.x, localTank.position.z);
      // Send update every frame
      const updateMsg = {
        type: "update",
        id: playerId,
        position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z },
        rotation: localTank.rotation.y
      };
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(updateMsg));
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      updateMovement();
      for (let i = missiles.length - 1; i >= 0; i--) {
        missiles[i].position.add(missiles[i].userData.velocity);
        if (missiles[i].position.length() > 200) {
          scene.remove(missiles[i]);
          missiles.splice(i, 1);
        }
      }
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
