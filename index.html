<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kennedy Chat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      height: 100vh;
      overflow: hidden;
      transition: background 0.3s ease;
    }

    body.light-mode {
      background: linear-gradient(135deg, #e0f4ff 0%, #ffffff 100%);
      color: #333;
    }

    body.dark-mode {
      background: linear-gradient(135deg, #001a33 0%, #003366 100%);
      color: #ffffff;
    }

    .container {
      display: flex;
      height: 100vh;
      max-width: 1400px;
      margin: 0 auto;
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      min-width: 0;
    }

    .sidebar {
      width: 300px;
      padding: 20px;
      border-left: 1px solid rgba(0, 0, 0, 0.1);
      overflow-y: auto;
    }

    body.dark-mode .sidebar {
      border-left-color: rgba(255, 255, 255, 0.2);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 28px;
      font-weight: 600;
    }

    .dark-mode-toggle {
      background: rgba(0, 0, 0, 0.1);
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    body.dark-mode .dark-mode-toggle {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .dark-mode-toggle:hover {
      transform: scale(1.05);
    }

    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 15px;
      padding: 20px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .chat-container {
      background: rgba(0, 26, 51, 0.5);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .messages {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 20px;
      padding-right: 10px;
    }

    .messages::-webkit-scrollbar {
      width: 8px;
    }

    .messages::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
    }

    .messages::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }

    body.dark-mode .messages::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .messages::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
    }

    .message {
      margin-bottom: 15px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 10px;
      animation: slideIn 0.3s ease;
      position: relative;
    }

    /* Own messages = GREEN */
    .message.own-message {
      background: rgba(34, 197, 94, 0.2);
      border-left: 3px solid #22c55e;
    }

    /* Others' messages = BLUE */
    .message.other-message {
      background: rgba(59, 130, 246, 0.2);
      border-left: 3px solid #3b82f6;
    }

    body.dark-mode .message {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .message.own-message {
      background: rgba(34, 197, 94, 0.15);
      border-left-color: #4ade80;
    }

    body.dark-mode .message.other-message {
      background: rgba(59, 130, 246, 0.15);
      border-left-color: #60a5fa;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(-20px);
      }
    }

    .message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
      opacity: 0.7;
    }

    .nickname {
      font-weight: 600;
      color: #0066cc;
    }

    body.dark-mode .nickname {
      color: #66b3ff;
    }

    .timestamp {
      font-size: 11px;
    }

    .message-content {
      word-wrap: break-word;
      line-height: 1.5;
    }

    .message-image {
      margin-top: 10px;
      max-width: 192px;
      max-height: 256px;
      cursor: pointer;
      border-radius: 8px;
      object-fit: cover;
      transition: transform 0.2s ease;
    }

    .message-image:hover {
      transform: scale(1.02);
    }

    .message-file {
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      display: inline-block;
    }

    body.dark-mode .message-file {
      background: rgba(255, 255, 255, 0.1);
    }

    .message-file a {
      color: #0066cc;
      text-decoration: none;
      font-weight: 500;
    }

    body.dark-mode .message-file a {
      color: #66b3ff;
    }

    /* BUG FIX #1: High contrast download links in message bubbles */
    .message.own-message .message-file a,
    .message.other-message .message-file a {
      color: white;
      background: rgba(0, 0, 0, 0.3);
      padding: 8px 16px;
      border-radius: 5px;
      display: inline-block;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.2s;
      margin-top: 8px;
    }

    .message.own-message .message-file a:hover,
    .message.other-message .message-file a:hover {
      background: rgba(0, 0, 0, 0.5);
      transform: translateY(-1px);
    }

    body.dark-mode .message.own-message .message-file a,
    body.dark-mode .message.other-message .message-file a {
      color: white;
      background: rgba(255, 255, 255, 0.2);
    }

    body.dark-mode .message.own-message .message-file a:hover,
    body.dark-mode .message.other-message .message-file a:hover {
      background: rgba(255, 255, 255, 0.35);
    }

    .file-info {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 5px;
    }

    .file-warning {
      font-size: 11px;
      font-style: italic;
      opacity: 0.7;
      margin-top: 5px;
      color: #856404;
    }

    body.dark-mode .file-warning {
      color: #ffc107;
    }

    .file-download-btn {
      display: inline-block;
      padding: 8px 16px;
      background: #0066cc;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      margin-top: 8px;
    }

    .file-download-btn:hover {
      background: #0052a3;
      transform: translateY(-1px);
    }

    body.dark-mode .file-download-btn {
      background: #3b82f6;
    }

    body.dark-mode .file-download-btn:hover {
      background: #2563eb;
    }

    /* BUG FIX #1: High contrast download buttons in message bubbles */
    .message.own-message .file-download-btn,
    .message.other-message .file-download-btn {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }

    .message.own-message .file-download-btn:hover,
    .message.other-message .file-download-btn:hover {
      background: white;
      color: #000;
    }

    body.dark-mode .message.own-message .file-download-btn,
    body.dark-mode .message.other-message .file-download-btn {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    body.dark-mode .message.own-message .file-download-btn:hover,
    body.dark-mode .message.other-message .file-download-btn:hover {
      background: rgba(255, 255, 255, 0.35);
      color: white;
    }

    .input-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .photo-composer {
      display: none;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
    }

    body.dark-mode .photo-composer {
      background: rgba(255, 255, 255, 0.1);
    }

    .photo-composer.active {
      display: block;
    }

    .composer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 14px;
      font-weight: 600;
      opacity: 0.8;
    }

    .composer-preview {
      display: flex;
      gap: 15px;
      align-items: flex-start;
    }

    .preview-image {
      max-width: 150px;
      max-height: 150px;
      border-radius: 8px;
      object-fit: cover;
    }

    .preview-details {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .preview-filename {
      font-size: 13px;
      font-weight: 500;
      word-break: break-all;
    }

    .preview-size {
      font-size: 12px;
      opacity: 0.7;
    }

    .btn-remove {
      background: #dc3545;
      color: white;
      padding: 8px 16px;
      font-size: 13px;
    }

    .btn-remove:hover {
      background: #c82333;
    }

    .message-sending {
      opacity: 0.6;
    }

    .message-error {
      border-left: 3px solid #dc3545;
    }

    .message-status {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 5px;
      font-style: italic;
    }

    .deleteBtn {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 10px;
      padding: 3px 6px;
      background: rgba(220, 53, 69, 0.9);
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 10;
      font-weight: 500;
    }

    /* Show delete button on hover for desktop */
    .message.own-message:hover .deleteBtn {
      opacity: 1;
    }

    /* Always show delete button on mobile/touch devices */
    @media (hover: none) and (pointer: coarse) {
      .deleteBtn {
        opacity: 0.7;
        position: static;
        display: inline-block;
        margin-top: 6px;
        margin-left: 8px;
      }
    }

    body.dark-mode .deleteBtn {
      background: rgba(220, 53, 69, 0.95);
      color: white;
    }

    .deleteBtn:hover {
      background: #dc3545;
      opacity: 1;
    }

    body.dark-mode .deleteBtn:hover {
      background: #ff6b6b;
    }

    .recording-indicator {
      background: rgba(220, 53, 69, 0.2);
      color: #dc3545;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
      display: none;
    }

    .recording-indicator.active {
      display: block;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .audio-draft {
      display: none;
      background: rgba(0, 102, 204, 0.1);
      border: 2px solid rgba(0, 102, 204, 0.3);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
    }

    body.dark-mode .audio-draft {
      background: rgba(102, 179, 255, 0.15);
      border-color: rgba(102, 179, 255, 0.3);
    }

    .audio-draft.active {
      display: block;
    }

    .audio-draft-header {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      opacity: 0.9;
    }

    .audio-draft-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .audio-draft audio {
      width: 100%;
      margin-bottom: 10px;
    }

    /* REMOVED - audio now uses unified media composer */

    /* Rich text toolbar */
    .text-toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 10px;
      background: rgba(0, 0, 0, 0.03);
      border-radius: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
      overflow: hidden;
      max-height: 200px;
    }

    .text-toolbar.collapsed {
      max-height: 0;
      padding: 0 10px;
      opacity: 0;
      margin-bottom: 0;
    }

    body.dark-mode .text-toolbar {
      background: rgba(255, 255, 255, 0.05);
    }

    .toolbar-toggle {
      background: rgba(0, 0, 0, 0.05);
      border: 1px solid rgba(0, 0, 0, 0.1);
      padding: 4px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 11px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    body.dark-mode .toolbar-toggle {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .toolbar-toggle:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .toolbar-toggle:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .toolbar-toggle-icon {
      transition: transform 0.3s ease;
    }

    .toolbar-toggle-icon.expanded {
      transform: rotate(180deg);
    }

    .toolbar-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      background: rgba(255, 255, 255, 0.8);
      border-radius: 5px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }

    body.dark-mode .toolbar-btn {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      color: white;
    }

    .toolbar-btn:hover {
      background: rgba(0, 102, 204, 0.2);
      border-color: #0066cc;
    }

    .toolbar-btn.active {
      background: #0066cc;
      color: white;
      border-color: #0066cc;
    }

    .toolbar-select {
      padding: 6px 10px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      background: rgba(255, 255, 255, 0.8);
      border-radius: 5px;
      font-size: 13px;
      cursor: pointer;
    }

    body.dark-mode .toolbar-select {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      color: white;
    }

    .emoji-picker-container {
      position: relative;
      display: inline-block;
    }

    /* BUG FIX #2: Emoji dropdown positioning to prevent cutoff */
    .emoji-panel {
      display: none;
      position: fixed; /* Changed from absolute to fixed for better viewport positioning */
      background: white;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      max-width: 320px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10000; /* Very high z-index to ensure it's above everything */
      margin-bottom: 8px;
    }

    body.dark-mode .emoji-panel {
      background: #003366;
      border-color: rgba(255, 255, 255, 0.2);
    }

    .emoji-panel.active {
      display: block;
    }

    .emoji-panel span {
      font-size: 24px;
      cursor: pointer;
      display: inline-block;
      padding: 5px;
      transition: transform 0.2s;
    }

    .emoji-panel span:hover {
      transform: scale(1.3);
    }

    .quick-emoji {
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 5px;
      transition: all 0.2s;
      display: inline-block;
    }

    .quick-emoji:hover {
      background: rgba(0, 0, 0, 0.1);
      transform: scale(1.2);
    }

    body.dark-mode .quick-emoji:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    #composer {
      flex: 1;
      padding: 12px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-family: inherit;
      min-height: 60px;
      max-height: 150px;
      overflow-y: auto;
      transition: all 0.3s ease;
    }

    body.dark-mode #composer {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    #composer:focus {
      outline: none;
      border-color: #0066cc;
    }

    body.dark-mode #composer:focus {
      border-color: #66b3ff;
    }

    #composer:empty:before {
      content: attr(data-placeholder);
      color: rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    body.dark-mode #composer:empty:before {
      color: rgba(255, 255, 255, 0.4);
    }

    .input-row {
      display: flex;
      gap: 10px;
    }

    input[type="text"],
    textarea {
      flex: 1;
      padding: 12px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-family: inherit;
      transition: all 0.3s ease;
    }

    body.dark-mode input[type="text"],
    body.dark-mode textarea {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: white;
    }

    input[type="text"]:focus,
    textarea:focus {
      outline: none;
      border-color: #0066cc;
    }

    body.dark-mode input[type="text"]:focus,
    body.dark-mode textarea:focus {
      border-color: #66b3ff;
    }

    textarea {
      resize: vertical;
      min-height: 60px;
    }

    .message-controls {
      display: flex;
      gap: 10px;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: #0066cc;
      color: white;
      flex: 1;
    }

    .btn-primary:hover:not(:disabled) {
      background: #0052a3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
    }

    .btn-icon {
      background: rgba(0, 0, 0, 0.1);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
    }

    body.dark-mode .btn-icon {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .btn-icon:hover:not(:disabled) {
      background: rgba(0, 0, 0, 0.2);
      transform: scale(1.1);
    }

    body.dark-mode .btn-icon:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.3);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .sidebar h2 {
      font-size: 18px;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid rgba(0, 102, 204, 0.3);
    }

    .sidebar-content {
      font-size: 14px;
      line-height: 1.8;
      opacity: 0.8;
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      position: relative;
    }

    body.dark-mode .modal-content {
      background: #003366;
    }

    .modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.2);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    body.dark-mode .modal-close {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .camera-preview {
      max-width: 100%;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .camera-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .fullscreen-image {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 10px;
    }

    /* Media menu dropdown */
    .media-menu {
      display: none;
      position: absolute;
      bottom: 100%;
      left: 0;
      background: white;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      min-width: 180px;
      margin-bottom: 8px;
    }

    body.dark-mode .media-menu {
      background: #003366;
      border-color: rgba(255, 255, 255, 0.2);
    }

    .media-menu.active {
      display: block;
    }

    .media-menu-item {
      padding: 12px 16px;
      cursor: pointer;
      transition: background 0.2s;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      font-size: 14px;
      font-weight: 500;
    }

    body.dark-mode .media-menu-item {
      border-bottom-color: rgba(255, 255, 255, 0.1);
    }

    .media-menu-item:last-child {
      border-bottom: none;
    }

    .media-menu-item:hover {
      background: rgba(0, 102, 204, 0.1);
    }

    body.dark-mode .media-menu-item:hover {
      background: rgba(102, 179, 255, 0.15);
    }

    /* Video quality selector */
    .video-quality-selector {
      padding: 15px;
    }

    .video-quality-option {
      padding: 12px;
      margin-bottom: 10px;
      border: 2px solid rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
    }

    .video-quality-option:last-child {
      margin-bottom: 0;
    }

    .video-quality-option:hover {
      background: rgba(0, 102, 204, 0.1);
      border-color: #0066cc;
    }

    .video-quality-option.selected {
      background: rgba(0, 102, 204, 0.2);
      border-color: #0066cc;
    }

    body.dark-mode .video-quality-option {
      border-color: rgba(255, 255, 255, 0.3);
    }

    body.dark-mode .video-quality-option:hover {
      background: rgba(102, 179, 255, 0.15);
      border-color: #66b3ff;
    }

    body.dark-mode .video-quality-option.selected {
      background: rgba(102, 179, 255, 0.2);
      border-color: #66b3ff;
    }

    .quality-title {
      font-weight: 600;
      font-size: 16px;
      margin-bottom: 4px;
    }

    .quality-subtitle {
      font-size: 12px;
      opacity: 0.7;
    }

    /* Video recording UI */
    .video-recording-ui {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .video-timer {
      font-size: 24px;
      font-weight: 600;
      color: #dc3545;
    }

    .video-progress {
      width: 100%;
      height: 6px;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    body.dark-mode .video-progress {
      background: rgba(255, 255, 255, 0.2);
    }

    .video-progress-bar {
      height: 100%;
      background: #dc3545;
      transition: width 0.1s linear;
    }

    /* Video message display */
    .message-video {
      margin-top: 10px;
      max-width: 300px;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s ease;
      position: relative;
      background: #000;
    }

    .message-video video {
      width: 100%;
      border-radius: 8px;
      display: block;
    }

    .message-video:hover {
      transform: scale(1.02);
    }

    .video-play-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .video-play-overlay::after {
      content: '‚ñ∂';
      color: white;
      font-size: 24px;
      margin-left: 4px;
    }

    /* Fullscreen video viewer */
    .fullscreen-video {
      max-width: 90%;
      max-height: 80vh;
      border-radius: 10px;
    }

    .status-message {
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
    }

    .status-error {
      background: rgba(220, 53, 69, 0.2);
      color: #dc3545;
    }

    .status-muted {
      background: rgba(255, 193, 7, 0.2);
      color: #856404;
    }

    body.dark-mode .status-muted {
      color: #ffc107;
    }

    .hidden {
      display: none;
    }

    input[type="file"] {
      display: none;
    }

    /* Toast notification for delete feedback */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
    }

    .toast.success {
      background: rgba(34, 197, 94, 0.9);
    }

    .toast.error {
      background: rgba(220, 53, 69, 0.9);
    }

    body.dark-mode .toast {
      background: rgba(0, 0, 0, 0.95);
    }

    /* Typing indicators */
    .typing-indicators {
      padding: 8px 12px;
      margin-bottom: 10px;
      font-size: 13px;
      font-style: italic;
      opacity: 0.7;
      min-height: 24px;
    }

    .typing-indicator {
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 0.7; }
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        border-left: none;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        max-height: 200px;
      }

      body.dark-mode .sidebar {
        border-top-color: rgba(255, 255, 255, 0.2);
      }
    }
  </style>
</head>
<body class="light-mode">
  <div class="container">
    <div class="main-content">
      <div class="header">
        <div style="display: flex; align-items: center; gap: 15px;">
          <h1>Kennedy Chat</h1>
          <div id="onlineBadge" style="display:flex;align-items:center;gap:8px;">
            <span id="onlineDot" style="width:10px;height:10px;border-radius:50%;background:#22c55e;display:inline-block;"></span>
            <span id="onlineCount">Online: 0</span>
          </div>
        </div>
        <button class="dark-mode-toggle" onclick="toggleDarkMode()">Dark Mode</button>
      </div>

      <div class="chat-container">
        <div class="messages" id="messages"></div>

        <!-- Typing indicators -->
        <div class="typing-indicators" id="typingIndicators"></div>

        <div id="statusMessage" class="hidden"></div>
        
        <div id="recordingIndicator" class="recording-indicator">
          Recording... <span id="recordingTimer">0s</span>
          <button class="btn-remove" onclick="stopAudioRecording()" style="margin-left: 10px;">Stop</button>
        </div>

        <!-- Audio Draft Composer - REMOVED (unified with media composer below) -->

        <div class="input-section">
          <input 
            type="text" 
            id="nickname" 
            placeholder="Your nickname (max 100 chars)" 
            maxlength="100"
            autocomplete="off"
          >
          
          <!-- Media Composer Preview (unified for photos, videos, audio, files) -->
          <div id="photoComposer" class="photo-composer">
            <div class="composer-header">
              <span id="mediaTypeLabel">Media Attached</span>
              <button class="btn-remove" onclick="removePhotoAttachment()">Remove</button>
            </div>
            <div class="composer-preview">
              <img id="previewImage" class="preview-image" src="" alt="Preview" style="display: none;">
              <video id="previewVideo" class="preview-image" controls style="display: none; max-width: 200px; max-height: 200px; cursor: pointer;"></video>
              <audio id="previewAudio" controls style="display: none; width: 100%; margin-bottom: 10px;"></audio>
              <div class="preview-details">
                <div class="preview-filename" id="previewFilename"></div>
                <div class="preview-size" id="previewSize"></div>
              </div>
            </div>
          </div>

          <!-- Toolbar Toggle Button -->
          <button class="toolbar-toggle" onclick="toggleToolbar()" id="toolbarToggle">
            <span class="toolbar-toggle-icon" id="toolbarToggleIcon">‚ñº</span>
            <span>Formatting</span>
          </button>

          <!-- Rich Text Toolbar -->
          <div class="text-toolbar collapsed" id="textToolbar">
            <button class="toolbar-btn" onclick="formatText('bold')" title="Bold"><b>B</b></button>
            <button class="toolbar-btn" onclick="formatText('italic')" title="Italic"><i>I</i></button>
            <button class="toolbar-btn" onclick="formatText('underline')" title="Underline"><u>U</u></button>
            <select class="toolbar-select" onchange="setTextStyle(this.value)" id="styleSelect">
              <option value="">Style</option>
              <option value="monospace">Monospace</option>
            </select>
            
            <!-- Quick Emojis -->
            <span class="quick-emoji" onclick="insertEmojiQuick('‚ù§Ô∏è')" title="Heart">‚ù§Ô∏è</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üòÇ')" title="Laughing">üòÇ</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üò≠')" title="Crying">üò≠</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üëç')" title="Thumbs up">üëç</span>
            <span class="quick-emoji" onclick="insertEmojiQuick('üî•')" title="Fire">üî•</span>
            
            <!-- Emoji Picker Dropdown -->
            <div class="emoji-picker-container">
              <button class="toolbar-btn" onclick="toggleEmojiPicker()" title="More Emojis">üòä+</button>
              <div class="emoji-panel" id="emojiPanel">
                <span onclick="insertEmoji('üòÄ')">üòÄ</span>
                <span onclick="insertEmoji('üòÅ')">üòÅ</span>
                <span onclick="insertEmoji('üòÇ')">üòÇ</span>
                <span onclick="insertEmoji('ü§£')">ü§£</span>
                <span onclick="insertEmoji('üòä')">üòä</span>
                <span onclick="insertEmoji('üòá')">üòá</span>
                <span onclick="insertEmoji('üôÇ')">üôÇ</span>
                <span onclick="insertEmoji('üòâ')">üòâ</span>
                <span onclick="insertEmoji('üòç')">üòç</span>
                <span onclick="insertEmoji('ü•∞')">ü•∞</span>
                <span onclick="insertEmoji('üòò')">üòò</span>
                <span onclick="insertEmoji('üòã')">üòã</span>
                <span onclick="insertEmoji('üòé')">üòé</span>
                <span onclick="insertEmoji('ü§î')">ü§î</span>
                <span onclick="insertEmoji('üò¥')">üò¥</span>
                <span onclick="insertEmoji('üò¢')">üò¢</span>
                <span onclick="insertEmoji('üò≠')">üò≠</span>
                <span onclick="insertEmoji('üò°')">üò°</span>
                <span onclick="insertEmoji('ü§Ø')">ü§Ø</span>
                <span onclick="insertEmoji('üò±')">üò±</span>
                <span onclick="insertEmoji('üëç')">üëç</span>
                <span onclick="insertEmoji('üëé')">üëé</span>
                <span onclick="insertEmoji('üëè')">üëè</span>
                <span onclick="insertEmoji('üôè')">üôè</span>
                <span onclick="insertEmoji('üí™')">üí™</span>
                <span onclick="insertEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</span>
                <span onclick="insertEmoji('üíî')">üíî</span>
                <span onclick="insertEmoji('ü•Ä')">ü•Ä</span>
                <span onclick="insertEmoji('üî•')">üî•</span>
                <span onclick="insertEmoji('‚≠ê')">‚≠ê</span>
                <span onclick="insertEmoji('üéâ')">üéâ</span>
              </div>
            </div>
          </div>

          <div class="input-row">
            <div 
              id="composer" 
              contenteditable="true" 
              data-placeholder="Type your message (max 1000 chars)"
            ></div>
          </div>
          <div class="message-controls">
            <div style="position: relative;">
              <button class="btn-icon" onclick="toggleMediaMenu()" title="Send Photo or Video" id="mediaBtn">
                Media
              </button>
              <div id="mediaMenu" class="media-menu">
                <div class="media-menu-item" onclick="selectMediaOption('photo')">Photo</div>
                <div class="media-menu-item" onclick="selectMediaOption('video')">Video</div>
                <div class="media-menu-item" onclick="selectMediaOption('file')">File</div>
              </div>
            </div>
            <button class="btn-icon" onclick="toggleAudioRecording()" title="Record Audio" id="audioBtn">
              Audio Message
            </button>
            <button class="btn-primary" onclick="sendMessage()" id="sendBtn">Send</button>
          </div>
          <input type="file" id="fileInput" onchange="handleFileSelect()">
          <input type="file" id="videoInput" accept="video/*" capture="environment" onchange="handleVideoSelect()" style="display: none;">
        </div>
      </div>
    </div>

    <div class="sidebar">
      <h2 style="font-size: 22px; font-weight: 700;">Rules</h2>
      <div class="sidebar-content" style="margin-bottom: 25px;">
        <p>No spamming (max 2 messages per 10s). Violators face escalating bans: 15s ‚Üí 1m ‚Üí 5m ‚Üí +5m each time.</p>
      </div>
      
      <h2 style="font-size: 22px; font-weight: 700;">Features</h2>
      <div class="sidebar-content">
        <ul style="list-style: disc; padding-left: 20px; line-height: 2;">
          <li>No moderators or login needed</li>
          <li>Rich text formatting + emojis</li>
          <li>Photo and GIF uploads</li>
          <li>Video messages (up to 10MB)</li>
          <li>Voice messages (up to 30s)</li>
          <li>Delete your own messages</li>
          <li>Typing indicators</li>
          <li>Online users count</li>
          <li>Dark Mode</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Camera/Video Modal -->
  <div id="cameraModal" class="modal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeCamera()">√ó</button>
      <h2 style="margin-bottom: 20px;" id="cameraModalTitle">Take a Photo</h2>
      
      <!-- Video Quality Selector (shown when video mode is selected) -->
      <div id="videoQualitySelector" class="video-quality-selector" style="display: none;">
        <div class="video-quality-option" onclick="selectVideoQuality('1080p', 10)">
          <div class="quality-title">1080p HD</div>
          <div class="quality-subtitle">Maximum 10 seconds</div>
        </div>
        <div class="video-quality-option" onclick="selectVideoQuality('720p', 30)">
          <div class="quality-title">720p</div>
          <div class="quality-subtitle">Maximum 30 seconds</div>
        </div>
      </div>
      
      <video id="cameraPreview" class="camera-preview" autoplay playsinline></video>
      <canvas id="cameraCanvas" style="display: none;"></canvas>
      
      <!-- Video Recording UI -->
      <div id="videoRecordingUI" class="video-recording-ui" style="display: none;">
        <div class="video-timer" id="videoTimer">0s</div>
        <div class="video-progress">
          <div class="video-progress-bar" id="videoProgressBar"></div>
        </div>
      </div>
      
      <div class="camera-controls" id="cameraControls">
        <button class="btn-primary" onclick="capturePhoto()" id="captureBtn">Capture</button>
        <button onclick="closeCamera()" style="background: #6c757d; color: white;">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Image Preview Modal -->
  <div id="imageModal" class="modal" onclick="closeImagePreview()">
    <div class="modal-content" onclick="event.stopPropagation()">
      <button class="modal-close" onclick="closeImagePreview()">√ó</button>
      <img id="fullscreenImage" class="fullscreen-image" src="" alt="Full size image">
    </div>
  </div>

  <!-- Video Preview Modal -->
  <div id="videoModal" class="modal" onclick="closeVideoPreview()">
    <div class="modal-content" onclick="event.stopPropagation()">
      <button class="modal-close" onclick="closeVideoPreview()">√ó</button>
      <video id="fullscreenVideo" class="fullscreen-video" controls></video>
      <a id="videoDownloadLink" download style="display: block; text-align: center; margin-top: 15px; color: #66b3ff; text-decoration: none; font-size: 14px;">
        ‚¨áÔ∏è Download Video
      </a>
    </div>
  </div>

  <!-- Toast notification -->
  <div id="toast" class="toast"></div>

  <script>
    let ws;
    let reconnectTimeout;
    let muteTimer;
    let cameraStream;
    const isDarkMode = localStorage.getItem('darkMode') === 'true';

    // DEBUG flag for delete feature troubleshooting
    const DEBUG_DELETE = true; // Set to false in production

    // Video recording state
    let videoRecorder = null;
    let videoStream = null;
    let videoChunks = [];
    let videoRecordTimer = null;
    let videoRecordingStartTime = 0;
    let videoMaxDuration = 10; // seconds
    let videoQuality = '1080p';
    let currentCameraMode = 'photo'; // 'photo' or 'video'

    // Client state - persist in sessionStorage to survive refreshes
    let myClientId = sessionStorage.getItem('myClientId') || null;
    let isVisible = !document.hidden;
    
    // Log client identity on startup
    if (myClientId) {
      console.log('[STARTUP] Restored myClientId from session:', myClientId);
    } else {
      console.log('[STARTUP] No existing client identity, will receive from server');
    }

    // Photo composer state
    let selectedFile = null;
    let previewURL = null;
    let pendingMessages = new Map(); // Map of client message ID to message data

    // Audio recording state
    let recorder = null;
    let audioStream = null;
    let audioChunks = [];
    let recordTimer = null;
    let recordingStartTime = 0;
    let audioDraftBlob = null;
    let audioDraftURL = null;

    // Typing indicator state
    let typingUsers = new Map(); // senderId -> { nickname, lastTs }
    let typingTimeout = null;
    let lastTypingSent = 0;
    const TYPING_THROTTLE = 800; // ms
    const TYPING_EXPIRE = 12000; // 12 seconds

    // Apply saved theme
    if (isDarkMode) {
      document.body.className = 'dark-mode';
      document.querySelector('.dark-mode-toggle').textContent = 'Light Mode';
    }

    // ========================================
    // TOKEN MANAGEMENT (Feature 2)
    // ========================================
    
    function getOrCreateToken() {
      // Try cookie first
      let token = getCookie('chat_token');
      
      // Fall back to localStorage
      if (!token) {
        token = localStorage.getItem('chat_token');
      }
      
      // Generate new token if none exists
      if (!token) {
        token = generateUUID();
        console.log('[TOKEN] Generated new token:', token);
      }
      
      // Store in both places
      setCookie('chat_token', token, 31536000); // 1 year
      localStorage.setItem('chat_token', token);
      
      return token;
    }

    // Initialize token on page load
    clientToken = getOrCreateToken();
    console.log('[TOKEN] Using client token:', clientToken);

    // WebSocket configuration
    const WS_URL = `wss://ws.ldawg7624.com?token=${encodeURIComponent(clientToken)}`;
    
    // Upload configuration
    const UPLOAD_URL = 'https://upload.ldawg7624.com/upload';

    // Ban state management
    function getCookie(name) {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
      return null;
    }

    function setCookie(name, value, maxAgeSeconds) {
      document.cookie = `${name}=${value}; path=/; max-age=${maxAgeSeconds}; SameSite=Lax; Secure`;
    }

    function getBanState() {
      // Check both localStorage and cookie
      const lsBanUntil = localStorage.getItem('chatBanUntil');
      const cookieBanUntil = getCookie('chatBanUntil');
      
      const banUntil = Math.max(
        lsBanUntil ? parseInt(lsBanUntil, 10) : 0,
        cookieBanUntil ? parseInt(cookieBanUntil, 10) : 0
      );
      
      return banUntil > Date.now() ? banUntil : null;
    }

    function setBanState(untilEpochMs) {
      const secondsRemaining = Math.ceil((untilEpochMs - Date.now()) / 1000);
      localStorage.setItem('chatBanUntil', untilEpochMs.toString());
      setCookie('chatBanUntil', untilEpochMs.toString(), secondsRemaining + 10);
    }

    function clearBanState() {
      localStorage.removeItem('chatBanUntil');
      setCookie('chatBanUntil', '', -1);
    }

    function checkAndApplyBanState() {
      const banUntil = getBanState();
      if (banUntil) {
        const secondsRemaining = Math.ceil((banUntil - Date.now()) / 1000);
        if (secondsRemaining > 0) {
          showBanMessage(banUntil);
          disableInputs(true);
          
          // Set timer to clear ban when it expires
          setTimeout(() => {
            clearBanState();
            disableInputs(false);
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.classList.add('hidden');
          }, secondsRemaining * 1000);
        } else {
          clearBanState();
        }
      }
    }

    function showBanMessage(untilEpochMs) {
      const statusDiv = document.getElementById('statusMessage');
      statusDiv.className = 'status-message status-error';
      
      function updateCountdown() {
        const remaining = Math.ceil((untilEpochMs - Date.now()) / 1000);
        if (remaining > 0) {
          const hours = Math.floor(remaining / 3600);
          const minutes = Math.floor((remaining % 3600) / 60);
          const seconds = remaining % 60;
          const timeStr = hours > 0 
            ? `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
            : `${minutes}:${seconds.toString().padStart(2, '0')}`;
          statusDiv.textContent = `Temporarily blocked until ${timeStr}`;
          setTimeout(updateCountdown, 1000);
        } else {
          statusDiv.classList.add('hidden');
          disableInputs(false);
          clearBanState();
        }
      }
      
      statusDiv.classList.remove('hidden');
      updateCountdown();
    }

    // Check ban state on page load
    checkAndApplyBanState();

    // Initialize toolbar state on page load
    window.addEventListener('DOMContentLoaded', initToolbarState);

    // Generate UUID v4
    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    // ========================================
    // HTML SANITIZATION (Feature 1)
    // ========================================
    
    function sanitizeHTML(html) {
      const div = document.createElement('div');
      div.innerHTML = html;
      
      // Allowed tags and attributes
      const allowedTags = ['B', 'STRONG', 'I', 'EM', 'U', 'BR', 'SPAN'];
      const allowedStyles = ['font-family', 'background', 'padding', 'border-radius'];
      
      function sanitizeNode(node) {
        // Text nodes are OK
        if (node.nodeType === 3) return true;
        
        // Element nodes must be in allowed list
        if (node.nodeType === 1) {
          if (!allowedTags.includes(node.tagName)) {
            return false;
          }
          
          // For SPAN, check style attribute
          if (node.tagName === 'SPAN') {
            const style = node.getAttribute('style');
            if (style) {
              // Parse and validate style
              const newStyle = [];
              const parts = style.split(';');
              for (const part of parts) {
                const [prop, value] = part.split(':').map(s => s.trim());
                if (allowedStyles.includes(prop)) {
                  if (prop === 'font-family') {
                    // Only allow monospace
                    if (value === 'monospace') {
                      newStyle.push(`${prop}: ${value}`);
                    }
                  } else if (prop === 'background') {
                    // Allow only rgba backgrounds
                    if (value.startsWith('rgba(')) {
                      newStyle.push(`${prop}: ${value}`);
                    }
                  } else if (prop === 'padding' || prop === 'border-radius') {
                    // Allow basic padding and border-radius
                    newStyle.push(`${prop}: ${value}`);
                  }
                }
              }
              node.setAttribute('style', newStyle.join('; '));
            }
            
            // Remove all other attributes
            const attrs = Array.from(node.attributes);
            for (const attr of attrs) {
              if (attr.name !== 'style') {
                node.removeAttribute(attr.name);
              }
            }
          } else {
            // Remove all attributes from other tags
            const attrs = Array.from(node.attributes);
            for (const attr of attrs) {
              node.removeAttribute(attr.name);
            }
          }
          
          return true;
        }
        
        return false;
      }
      
      function walk(node) {
        const children = Array.from(node.childNodes);
        for (const child of children) {
          if (!sanitizeNode(child)) {
            // Replace disallowed node with its text content
            const text = document.createTextNode(child.textContent);
            node.replaceChild(text, child);
          } else if (child.nodeType === 1) {
            walk(child);
          }
        }
      }
      
      walk(div);
      return div.innerHTML;
    }

    // ========================================
    // FILE UPLOAD VALIDATION
    // ========================================
    
    const BLOCKED_EXTENSIONS = [
      '.exe', '.msi', '.bat', '.cmd', '.com', '.scr', '.ps1', 
      '.vbs', '.js', '.jar', '.app', '.dmg', '.sh', '.deb', 
      '.rpm', '.apk', '.ipa'
    ];

    function isDangerousFile(filename) {
      const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
      return BLOCKED_EXTENSIONS.includes(ext);
    }

    function getFileExtension(filename) {
      return filename.substring(filename.lastIndexOf('.')).toLowerCase();
    }

    function isImageFile(filename, mime) {
      const imageExts = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
      const ext = getFileExtension(filename);
      return imageExts.includes(ext) || (mime && mime.startsWith('image/'));
    }

    function isAudioFile(filename, mime) {
      // Prioritize MIME type - if it's video, it's not audio even if extension matches
      if (mime) {
        if (mime.startsWith('video/')) return false;
        if (mime.startsWith('audio/')) return true;
      }
      // Fallback to extension (but ambiguous extensions like .webm, .ogg default to video)
      const audioExts = ['.mp3', '.wav', '.m4a', '.aac'];
      const ext = getFileExtension(filename);
      return audioExts.includes(ext);
    }

    function isVideoFile(filename, mime) {
      // Prioritize MIME type
      if (mime && mime.startsWith('video/')) return true;
      // Fallback to extension
      const videoExts = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.mkv'];
      const ext = getFileExtension(filename);
      return videoExts.includes(ext);
    }

    // ========================================
    // RICH TEXT EDITOR (Feature 1)
    // ========================================
    
    // Initialize toolbar state from sessionStorage
    function initToolbarState() {
      const toolbarExpanded = sessionStorage.getItem('toolbarExpanded') === 'true';
      const toolbar = document.getElementById('textToolbar');
      const toggleIcon = document.getElementById('toolbarToggleIcon');
      
      if (toolbarExpanded) {
        toolbar.classList.remove('collapsed');
        toggleIcon.classList.add('expanded');
      }
    }

    // Toggle toolbar collapsed/expanded state
    function toggleToolbar() {
      const toolbar = document.getElementById('textToolbar');
      const toggleIcon = document.getElementById('toolbarToggleIcon');
      const isCollapsed = toolbar.classList.contains('collapsed');
      
      if (isCollapsed) {
        toolbar.classList.remove('collapsed');
        toggleIcon.classList.add('expanded');
        sessionStorage.setItem('toolbarExpanded', 'true');
      } else {
        toolbar.classList.add('collapsed');
        toggleIcon.classList.remove('expanded');
        sessionStorage.setItem('toolbarExpanded', 'false');
      }
    }
    
    function formatText(command) {
      document.execCommand(command, false, null);
      document.getElementById('composer').focus();
    }

    function setTextStyle(style) {
      if (!style) return;
      
      const composer = document.getElementById('composer');
      const selection = window.getSelection();
      
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const span = document.createElement('span');
      
      if (style === 'monospace') {
        span.style.fontFamily = 'monospace';
        span.style.background = 'rgba(0, 0, 0, 0.05)';
        span.style.padding = '2px 4px';
        span.style.borderRadius = '3px';
      }
      
      try {
        range.surroundContents(span);
      } catch (e) {
        span.appendChild(range.extractContents());
        range.insertNode(span);
      }
      
      composer.focus();
      
      // Reset selector
      document.getElementById('styleSelect').value = '';
    }

    function toggleEmojiPicker() {
      const panel = document.getElementById('emojiPanel');
      const button = event.target.closest('.toolbar-btn');
      
      if (panel.classList.contains('active')) {
        panel.classList.remove('active');
      } else {
        // Calculate position relative to button
        if (button) {
          const rect = button.getBoundingClientRect();
          const panelHeight = 200; // max-height from CSS
          const spaceAbove = rect.top;
          const spaceBelow = window.innerHeight - rect.bottom;
          
          // Position below if there's more space, or if not enough space above
          if (spaceBelow > panelHeight || spaceAbove < panelHeight) {
            // Position below button
            panel.style.top = (rect.bottom + 8) + 'px';
            panel.style.bottom = 'auto';
          } else {
            // Position above button
            panel.style.bottom = (window.innerHeight - rect.top + 8) + 'px';
            panel.style.top = 'auto';
          }
          
          // Horizontal positioning
          panel.style.left = rect.left + 'px';
          
          // Ensure panel doesn't overflow viewport horizontally
          const maxLeft = window.innerWidth - 320 - 10; // 320px max-width + 10px margin
          if (rect.left > maxLeft) {
            panel.style.left = maxLeft + 'px';
          }
        }
        
        panel.classList.add('active');
      }
    }

    function insertEmoji(emoji) {
      const composer = document.getElementById('composer');
      composer.focus();
      document.execCommand('insertText', false, emoji);
      toggleEmojiPicker();
    }

    function insertEmojiQuick(emoji) {
      const composer = document.getElementById('composer');
      composer.focus();
      document.execCommand('insertText', false, emoji);
    }

    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
      const emojiContainer = document.querySelector('.emoji-picker-container');
      if (emojiContainer && !emojiContainer.contains(e.target)) {
        document.getElementById('emojiPanel').classList.remove('active');
      }
    });

    function getComposerHTML() {
      const composer = document.getElementById('composer');
      return sanitizeHTML(composer.innerHTML);
    }

    function getComposerText() {
      const composer = document.getElementById('composer');
      return composer.textContent || composer.innerText || '';
    }

    function clearComposer() {
      const composer = document.getElementById('composer');
      composer.innerHTML = '';
    }

    // ========================================
    // TYPING INDICATOR (Feature 3)
    // ========================================
    
    function sendTypingStatus(isTyping) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      
      const nickname = (document.getElementById('nickname').value.trim() || 'Anonymous').substring(0, 100);
      
      ws.send(JSON.stringify({
        type: 'typing',
        nickname,
        isTyping: !!isTyping,
        ts: Date.now()
      }));
    }

    function handleComposerInput() {
      const text = getComposerText().trim();
      const now = Date.now();
      
      if (text.length > 0) {
        // Throttle typing events
        if (now - lastTypingSent >= TYPING_THROTTLE) {
          sendTypingStatus(true);
          lastTypingSent = now;
        }
      } else {
        // Empty composer, send stop typing
        sendTypingStatus(false);
        lastTypingSent = 0;
      }
    }

    function updateTypingIndicators() {
      const now = Date.now();
      const container = document.getElementById('typingIndicators');
      
      // Remove expired entries
      for (const [senderId, info] of typingUsers) {
        if (now - info.lastTs > TYPING_EXPIRE) {
          typingUsers.delete(senderId);
        }
      }
      
      // Render
      const count = typingUsers.size;
      
      if (count === 0) {
        container.textContent = '';
      } else if (count <= 3) {
        const names = Array.from(typingUsers.values()).map(u => u.nickname);
        container.textContent = names.map(n => `${n} is typing...`).join(' ‚Ä¢ ');
      } else {
        container.textContent = 'Several people are typing...';
      }
    }

    // Set up typing detection
    document.getElementById('composer').addEventListener('input', handleComposerInput);
    document.getElementById('composer').addEventListener('blur', () => {
      sendTypingStatus(false);
    });

    // Auto-clean typing indicators every 1s
    setInterval(updateTypingIndicators, 1000);

    // ========================================
    // PRESENCE & ONLINE COUNT
    // ========================================
    
    function sendPresence(online) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "presence", online: !!online, ts: Date.now() }));
      }
    }

    // Set up visibility tracking
    document.addEventListener("visibilitychange", () => {
      isVisible = !document.hidden;
      sendPresence(isVisible);
    });

    window.addEventListener("focus", () => sendPresence(true));
    window.addEventListener("blur", () => sendPresence(false));

    // Online count display
    function setOnlineCount(n) {
      document.getElementById("onlineCount").textContent = `Online: ${n}`;
    }

    // ========================================
    // WEBSOCKET CONNECTION
    // ========================================
    
    function connect() {
      console.log('========================================');
      console.log('[CONNECT] Attempting WebSocket connection');
      console.log('[CONNECT] URL:', WS_URL);
      console.log('[CONNECT] Token:', clientToken);
      console.log('========================================');
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log('========================================');
        console.log('[CONNECT] ‚úì WebSocket connection OPEN');
        console.log('========================================');
        clearTimeout(reconnectTimeout);
        
        // Send initial presence
        sendPresence(isVisible);
        
        // Send a ping to verify ACK path works
        const pingId = generateUUID();
        const pingMessage = {
          type: 'ping',
          id: pingId,
          messageId: pingId,
          timestamp: Date.now()
        };
        
        console.log('[SELF-TEST] Sending ping with id=' + pingId);
        pendingMessages.set(pingId, { type: 'ping', testPing: true });
        
        const pingTimeout = setTimeout(() => {
          if (pendingMessages.has(pingId)) {
            console.error('[SELF-TEST] ‚ùå FAILED - No ACK received for ping');
            showStatus('Connected but ACK path not working', 'error');
            pendingMessages.delete(pingId);
          }
        }, 3000);
        
        pendingMessages.get(pingId).timeout = pingTimeout;
        ws.send(JSON.stringify(pingMessage));
      };

      ws.onmessage = (event) => {
        console.log('[WS] RX:', event.data);
        const data = JSON.parse(event.data);
        
        if (data.type === 'welcome') {
          // If we already have a session clientId, keep using it (for ownership persistence)
          // Otherwise, accept the new one from the server
          if (!myClientId) {
            myClientId = data.clientId;
            sessionStorage.setItem('myClientId', myClientId);
            console.log('[WELCOME] New myClientId assigned:', myClientId);
          } else {
            console.log('[WELCOME] Using existing myClientId from session:', myClientId);
            console.log('[WELCOME] Server offered:', data.clientId, '(ignored for ownership continuity)');
          }
          
          // If server sent us a token, store it
          if (data.token && data.token !== clientToken) {
            clientToken = data.token;
            setCookie('chat_token', clientToken, 31536000);
            localStorage.setItem('chat_token', clientToken);
            console.log('[TOKEN] Received token from server:', clientToken);
          }
          
          refreshDeleteButtons();
        } else if (data.type === 'online') {
          setOnlineCount(data.count);
        } else if (data.type === 'history') {
          console.log('[WS] History received with', data.items.length, 'items');
          displayHistory(data.items);
          // BUG FIX #3: Ensure delete buttons are refreshed after history loads
          // This handles the case where myClientId was restored from session storage
          // but messages from history need their delete buttons added retroactively
          setTimeout(() => refreshDeleteButtons(), 100);
        } else if (data.type === 'delete') {
          if (DEBUG_DELETE) {
            console.log('========================================');
            console.log('[DELETE] üì° Received delete broadcast from server');
            console.log('[DELETE] Message ID to delete:', data.id);
          }
          removeMessageFromUI(data.id);
        } else if (data.type === 'typing') {
          // Update typing indicator
          if (data.senderId !== myClientId) {
            if (data.isTyping) {
              typingUsers.set(data.senderId, {
                nickname: data.nickname,
                lastTs: data.ts || Date.now()
              });
            } else {
              typingUsers.delete(data.senderId);
            }
            updateTypingIndicators();
          }
        } else if (data.type === 'ack') {
          const ackId = data.messageId || data.id;
          console.log('[WS] ‚úì ACK RECEIVED for id=' + ackId);
          
          if (!ackId) return;
          
          const pendingMsg = pendingMessages.get(ackId);
          if (pendingMsg && pendingMsg.testPing) {
            console.log('[SELF-TEST] ‚úì Ping ACK received');
            if (pendingMsg.timeout) clearTimeout(pendingMsg.timeout);
            pendingMessages.delete(ackId);
            showStatus('Connected ‚úì', 'success');
            return;
          }
          
          const msgElement = document.querySelector(`[data-msg-id="${ackId}"]`);
          if (msgElement) {
            msgElement.classList.remove('message-sending');
            msgElement.classList.add('message-sent');
            const statusSpan = msgElement.querySelector('.message-status');
            if (statusSpan) {
              statusSpan.textContent = 'Sent ‚úì';
              setTimeout(() => statusSpan.remove(), 2000);
            }
            
            // BUG FIX #3: Add delete button when message transitions from 'sending' to 'sent'
            // Check if this is our own message and delete button doesn't exist yet
            const senderId = msgElement.getAttribute('data-sender-id');
            const isOwnMessage = senderId === myClientId;
            const existingDeleteBtn = msgElement.querySelector('.deleteBtn');
            
            if (isOwnMessage && !existingDeleteBtn) {
              const deleteBtn = document.createElement('button');
              deleteBtn.className = 'deleteBtn';
              deleteBtn.textContent = 'Delete';
              deleteBtn.title = 'Delete this message';
              deleteBtn.onclick = () => deleteMessage(ackId);
              msgElement.appendChild(deleteBtn);
              
              if (DEBUG_DELETE) {
                console.log('[ACK] ‚úì Added delete button to message after ACK:', ackId);
              }
            }
          }
        } else if (data.type === 'text' || data.type === 'image' || data.type === 'audio' || data.type === 'file' || data.type === 'video') {
          if (pendingMessages.has(data.id)) {
            console.log('[WS] Received broadcast of our own message id=' + data.id);
            const msgElement = document.querySelector(`[data-msg-id="${data.id}"]`);
            if (msgElement && data.type === 'image') {
              const img = msgElement.querySelector('.message-image');
              if (img && data.url) {
                img.src = data.url;
                img.onclick = () => openImagePreview(data.url);
              }
            } else if (msgElement && data.type === 'video') {
              const videoContainer = msgElement.querySelector('.message-video');
              if (videoContainer && data.url) {
                const video = videoContainer.querySelector('video source');
                if (video) {
                  video.src = data.url;
                }
                videoContainer.setAttribute('data-url', data.url);
                videoContainer.onclick = () => openVideoPreview(data.url, data.filename);
              }
            }
            pendingMessages.delete(data.id);
          } else {
            console.log('[WS] New message from another client');
            addMessage(data);
          }
        } else if (data.type === 'banned') {
          handleBanned(data);
        } else if (data.type === 'muted') {
          handleBanned({
            type: 'banned',
            until: data.until || (Date.now() + data.seconds * 1000),
            seconds: data.seconds,
            reason: 'rate'
          });
        }
      };

      ws.onclose = (event) => {
        console.log('[CLOSE] WebSocket connection closed');
        showStatus('Disconnected. Reconnecting...', 'error');
        reconnectTimeout = setTimeout(connect, 3000);
      };

      ws.onerror = (error) => {
        console.error('[ERROR] WebSocket error:', error);
        showStatus('Connection error', 'error');
      };
    }

    function showStatus(message, type) {
      const statusDiv = document.getElementById('statusMessage');
      statusDiv.className = `status-message ${type === 'error' ? 'status-error' : 'status-muted'}`;
      statusDiv.textContent = message;
      statusDiv.classList.remove('hidden');
      
      if (type === 'success') {
        setTimeout(() => {
          statusDiv.classList.add('hidden');
        }, 2000);
      }
    }

    function showToast(message, type = 'success') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${type} show`;
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, 2500);
    }

    function handleBanned(data) {
      const untilEpochMs = data.until || (Date.now() + (data.seconds || 0) * 1000);
      
      // Persist ban state
      setBanState(untilEpochMs);
      
      // Show ban message
      showBanMessage(untilEpochMs);
      
      // Disable inputs
      disableInputs(true);
      
      // Re-enable after ban period
      const secondsRemaining = Math.ceil((untilEpochMs - Date.now()) / 1000);
      setTimeout(() => {
        clearBanState();
        disableInputs(false);
        const statusDiv = document.getElementById('statusMessage');
        statusDiv.classList.add('hidden');
      }, secondsRemaining * 1000);
    }

    connect();

    // ========================================
    // MESSAGE DISPLAY
    // ========================================
    
    function displayHistory(items) {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.innerHTML = '';
      const displayItems = items.slice(-100);
      displayItems.forEach(item => addMessage(item, false));
      scrollToBottom();
    }

    function addMessage(data, scroll = true, messageId = null, status = 'sent') {
      const messagesDiv = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      
      if (status === 'sending') {
        messageDiv.classList.add('message-sending');
      } else if (status === 'error') {
        messageDiv.classList.add('message-error');
      }
      
      if (messageId || data.id) {
        messageDiv.setAttribute('data-msg-id', messageId || data.id);
      }
      
      if (data.senderId) {
        messageDiv.setAttribute('data-sender-id', data.senderId);
      }

      const timestamp = new Date(data.timestamp).toLocaleString();
      
      // Check if this is our own message (can delete + color green)
      const isOwnMessage = data.senderId && myClientId && data.senderId === myClientId;
      
      // Apply color classes based on ownership
      if (isOwnMessage) {
        messageDiv.classList.add('own-message');
      } else if (data.senderId) {
        // Only add 'other-message' if there's a senderId (not system messages)
        messageDiv.classList.add('other-message');
      }
      
      // Dev-only logging for ownership debugging (always enabled for now)
      console.log('[RENDER] üîç Ownership Check:', {
        messageId: data.id,
        senderId: data.senderId,
        myClientId: myClientId,
        isOwnMessage: isOwnMessage,
        canDelete: isOwnMessage && status === 'sent',
        colorClass: isOwnMessage ? 'GREEN' : 'BLUE'
      });
      
      let content = '';
      if (data.type === 'text') {
        // Prefer HTML if present, else text
        const displayContent = data.html ? sanitizeHTML(data.html) : escapeHtml(data.text);
        content = `<div class="message-content">${displayContent}</div>`;
      } else if (data.type === 'image') {
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        const imgId = 'img-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        content = `
          ${caption}
          <img id="${imgId}" src="${data.url}" class="message-image" data-url="${data.url}" alt="${escapeHtml(data.filename || 'Image')}">
        `;
      } else if (data.type === 'audio') {
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        const label = caption ? '' : '<div class="message-content">Voice message</div>';
        content = `
          ${caption || label}
          <audio controls src="${data.url}" style="max-width: 100%; margin-top: 8px;"></audio>
        `;
      } else if (data.type === 'video') {
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        const label = caption ? '' : '<div class="message-content">Video message</div>';
        const videoId = 'video-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        content = `
          ${caption || label}
          <div class="message-video" id="${videoId}" data-url="${data.url}" data-filename="${escapeHtml(data.filename || 'video')}">
            <video preload="metadata" style="width: 100%; max-width: 300px; border-radius: 8px;">
              <source src="${data.url}" type="${data.mime || 'video/webm'}">
            </video>
            <div class="video-play-overlay"></div>
          </div>
        `;
      } else if (data.type === 'file') {
        const sizeStr = formatFileSize(data.size);
        const caption = data.caption ? `<div class="message-content">${escapeHtml(data.caption)}</div>` : '';
        content = `
          ${caption || '<div class="message-content">Shared a file</div>'}
          <div class="message-file">
            <div style="font-weight: 600; margin-bottom: 8px;">${escapeHtml(data.filename)}</div>
            <div class="file-info">${sizeStr} ¬∑ ${data.mime || 'unknown'}</div>
            <a href="${data.url}" download="${escapeHtml(data.filename)}" class="file-download-btn">Download File</a>
            <div class="file-warning">‚ö†Ô∏è This site does not scan files for malicious content. Only download files you trust.</div>
          </div>
        `;
      }
      
      let statusHTML = '';
      if (status === 'sending') {
        statusHTML = '<div class="message-status">Sending...</div>';
      } else if (status === 'error') {
        statusHTML = '<div class="message-status">Failed to send</div>';
      }

      let deleteButtonHTML = '';
      if (isOwnMessage && status === 'sent') {
        deleteButtonHTML = `<button class="deleteBtn" onclick="deleteMessage('${data.id}')" title="Delete this message">Delete</button>`;
        
        if (DEBUG_DELETE) {
          console.log('[RENDER] ‚úì Added delete button for message:', data.id, '(green message)');
        }
      } else if (DEBUG_DELETE) {
        console.log('[RENDER] ‚äò No delete button for message:', data.id, 
          '- isOwnMessage:', isOwnMessage, 
          '- status:', status,
          '- senderId:', data.senderId,
          '- myClientId:', myClientId);
      }

      messageDiv.innerHTML = `
        <div class="message-header">
          <span class="nickname">${escapeHtml(data.nickname)}</span>
          <span class="timestamp">${timestamp}</span>
        </div>
        ${content}
        ${statusHTML}
        ${deleteButtonHTML}
      `;

      messagesDiv.appendChild(messageDiv);
      
      if (data.type === 'image') {
        const imgId = 'img-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        const imgElement = document.getElementById(imgId);
        if (imgElement) {
          imgElement.addEventListener('click', function() {
            openImagePreview(this.src);
          });
        }
      }
      
      if (data.type === 'video') {
        const videoId = 'video-' + (messageId || data.id || Math.random().toString(36).substr(2, 9));
        const videoElement = document.getElementById(videoId);
        if (videoElement) {
          videoElement.addEventListener('click', function() {
            const url = this.getAttribute('data-url');
            const filename = this.getAttribute('data-filename');
            openVideoPreview(url, filename);
          });
        }
      }
      
      if (scroll) {
        scrollToBottom();
      }
      
      return messageDiv;
    }

    function deleteMessage(msgId) {
      if (DEBUG_DELETE) {
        console.log('========================================');
        console.log('[DELETE] üóëÔ∏è  Delete button clicked');
        console.log('[DELETE] Message ID:', msgId);
        console.log('[DELETE] My Client ID:', myClientId);
        console.log('[DELETE] WebSocket state:', ws ? ws.readyState : 'no ws');
      }
      
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        if (DEBUG_DELETE) {
          console.error('[DELETE] ‚ùå Cannot delete - WebSocket not connected');
          console.log('========================================');
        }
        showToast('Cannot delete - not connected', 'error');
        return;
      }
      
      // Find the message to verify ownership
      const msgElement = document.querySelector(`[data-msg-id="${msgId}"]`);
      if (msgElement) {
        const senderId = msgElement.getAttribute('data-sender-id');
        if (DEBUG_DELETE) {
          console.log('[DELETE] Found message element');
          console.log('[DELETE] Message senderId:', senderId);
          console.log('[DELETE] Ownership match:', senderId === myClientId);
        }
        
        if (senderId !== myClientId) {
          if (DEBUG_DELETE) {
            console.error('[DELETE] ‚ùå Ownership mismatch - cannot delete');
            console.log('========================================');
          }
          showToast('Cannot delete - not your message', 'error');
          return;
        }
      }
      
      const deletePayload = { type: "delete", id: msgId };
      ws.send(JSON.stringify(deletePayload));
      
      if (DEBUG_DELETE) {
        console.log('[DELETE] ‚úì Delete request sent to server');
        console.log('[DELETE] Payload:', JSON.stringify(deletePayload));
        console.log('========================================');
      }
      
      // Optimistic UI update
      const elem = document.querySelector(`[data-msg-id="${msgId}"]`);
      if (elem) {
        elem.style.opacity = '0.5';
        elem.style.pointerEvents = 'none';
      }
    }

    function removeMessageFromUI(msgId) {
      if (DEBUG_DELETE) {
        console.log('========================================');
        console.log('[DELETE] üóëÔ∏è  Removing message from UI');
        console.log('[DELETE] Message ID:', msgId);
      }
      
      const msgElement = document.querySelector(`[data-msg-id="${msgId}"]`);
      if (msgElement) {
        // Check if this was our own message
        const senderId = msgElement.getAttribute('data-sender-id');
        const wasOwnMessage = senderId === myClientId;
        
        msgElement.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
          msgElement.remove();
          if (DEBUG_DELETE) {
            console.log('[DELETE] ‚úì Message removed from DOM');
            console.log('========================================');
          }
          
          // Show toast only if it was our own message being deleted
          if (wasOwnMessage) {
            showToast('Message deleted', 'success');
          }
        }, 300);
      } else {
        if (DEBUG_DELETE) {
          console.warn('[DELETE] ‚ö†Ô∏è  Message element not found in DOM');
          console.log('========================================');
        }
      }
    }

    // Refresh delete buttons and colors after myClientId is set/restored
    function refreshDeleteButtons() {
      if (!myClientId) {
        if (DEBUG_DELETE) {
          console.log('[REFRESH] ‚ö†Ô∏è  Skipping refresh - no myClientId yet');
        }
        return;
      }
      
      console.log('[REFRESH] üîÑ Refreshing ownership UI with myClientId:', myClientId);
      
      const allMessages = document.querySelectorAll('[data-msg-id]');
      let buttonCount = 0;
      let colorCount = 0;
      let ownMessageCount = 0;
      
      allMessages.forEach(msgElement => {
        const msgId = msgElement.getAttribute('data-msg-id');
        const senderId = msgElement.getAttribute('data-sender-id');
        
        if (!senderId) return; // Skip messages without senderId
        
        const isOwnMessage = senderId === myClientId;
        
        if (isOwnMessage) ownMessageCount++;
        
        // Apply color classes if not already applied
        if (isOwnMessage && !msgElement.classList.contains('own-message')) {
          msgElement.classList.remove('other-message');
          msgElement.classList.add('own-message');
          colorCount++;
        } else if (!isOwnMessage && !msgElement.classList.contains('other-message')) {
          msgElement.classList.remove('own-message');
          msgElement.classList.add('other-message');
          colorCount++;
        }
        
        // Add delete button if this is our message and button doesn't exist
        if (isOwnMessage) {
          const existingDeleteBtn = msgElement.querySelector('.deleteBtn');
          const canDelete = !msgElement.classList.contains('message-sending') && 
                           !msgElement.classList.contains('message-error');
          
          if (canDelete && !existingDeleteBtn) {
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'deleteBtn';
            deleteBtn.textContent = 'Delete';
            deleteBtn.title = 'Delete this message';
            deleteBtn.onclick = () => deleteMessage(msgId);
            msgElement.appendChild(deleteBtn);
            buttonCount++;
            if (DEBUG_DELETE) {
              console.log('[REFRESH] ‚úì Added delete button to message:', msgId);
            }
          }
        }
      });
      
      console.log('[REFRESH] ‚úì Found', ownMessageCount, 'own messages');
      console.log('[REFRESH] ‚úì Applied colors to', colorCount, 'messages');
      console.log('[REFRESH] ‚úì Added', buttonCount, 'delete buttons');
    }

    // ========================================
    // SEND MESSAGE (Updated for Feature 1)
    // ========================================
    
    async function sendMessage() {
      const nicknameInput = document.getElementById('nickname');
      const html = getComposerHTML();
      const text = getComposerText().trim();

      if (!text && !selectedFile) {
        return;
      }

      if (ws.readyState !== WebSocket.OPEN) {
        showStatus('Not connected. Please wait...', 'error');
        return;
      }

      const banUntil = getBanState();
      if (banUntil && banUntil > Date.now()) {
        showStatus('You are temporarily blocked from sending messages', 'error');
        return;
      }

      const nickname = (nicknameInput.value.trim() || 'Anonymous').substring(0, 100);
      const messageId = generateUUID();
      const timestamp = Date.now();

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      // Stop typing indicator
      sendTypingStatus(false);

      try {
        if (selectedFile) {
          // File upload flow
          console.log('[SEND] Uploading file with caption:', text.substring(0, 50));
          
          // Determine if it's an image, audio, video, or generic file
          const isImage = isImageFile(selectedFile.name, selectedFile.type);
          const isAudio = isAudioFile(selectedFile.name, selectedFile.type);
          const isVideo = isVideoFile(selectedFile.name, selectedFile.type);
          const fileType = isImage ? 'image' : (isAudio ? 'audio' : (isVideo ? 'video' : 'file'));
          
          console.log('[SEND] File type detected:', fileType, 'mime:', selectedFile.type);
          
          const optimisticData = {
            type: fileType,
            id: messageId,
            nickname,
            timestamp,
            url: previewURL,
            filename: selectedFile.name,
            caption: text || '',
            size: selectedFile.size,
            mime: selectedFile.type,
            senderId: myClientId
          };
          
          const msgElement = addMessage(optimisticData, true, messageId, 'sending');
          pendingMessages.set(messageId, optimisticData);
          
          const ackTimeout = setTimeout(() => {
            if (pendingMessages.has(messageId)) {
              const elem = document.querySelector(`[data-msg-id="${messageId}"]`);
              if (elem) {
                elem.classList.remove('message-sending');
                elem.classList.add('message-error');
                const statusSpan = elem.querySelector('.message-status');
                if (statusSpan) {
                  statusSpan.textContent = 'Failed to send (timeout)';
                }
              }
              pendingMessages.delete(messageId);
            }
          }, 5000);
          
          clearComposer();
          
          const fileToUpload = selectedFile;
          const formData = new FormData();
          formData.append('file', fileToUpload);
          
          const response = await fetch(UPLOAD_URL, {
            method: 'POST',
            body: formData
          });
          
          if (!response.ok) {
            clearTimeout(ackTimeout);
            const errorText = await response.text();
            let errorMessage = `Upload failed: ${response.status}`;
            try {
              const errorJson = JSON.parse(errorText);
              errorMessage = errorJson.error || errorMessage;
            } catch (e) {}
            throw new Error(errorMessage);
          }

          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('[UPLOAD] Error - expected JSON but got:', text.substring(0, 200));
            throw new Error('Server returned non-JSON response');
          }

          const result = await response.json();

          if (result.success || result.ok) {
            const wsMessage = {
              type: fileType,
              id: messageId,
              messageId: messageId,
              nickname,
              timestamp,
              url: result.url,
              filename: result.filename || result.name,
              mime: result.mime,
              size: result.size,
              caption: text || ''
            };
            
            ws.send(JSON.stringify(wsMessage));
            
            removePhotoAttachment();
            
            if (msgElement) {
              if (fileType === 'image') {
                const img = msgElement.querySelector('.message-image');
                if (img) {
                  img.src = result.url;
                  img.setAttribute('data-url', result.url);
                }
              } else if (fileType === 'audio') {
                const audio = msgElement.querySelector('audio');
                if (audio) {
                  audio.src = result.url;
                }
              } else if (fileType === 'video') {
                const video = msgElement.querySelector('video');
                if (video) {
                  const source = video.querySelector('source');
                  if (source) {
                    source.src = result.url;
                    source.type = result.mime || 'video/webm';
                  }
                  video.load(); // Reload the video with new source
                }
                const videoContainer = msgElement.querySelector('.message-video');
                if (videoContainer) {
                  videoContainer.setAttribute('data-url', result.url);
                }
              }
            }
          } else {
            clearTimeout(ackTimeout);
            throw new Error(result.error || 'Upload failed');
          }
        } else {
          // Text message with rich formatting
          console.log('[SEND] Sending text message with formatting');
          
          const messageData = {
            type: 'text',
            id: messageId,
            messageId: messageId,
            nickname,
            timestamp,
            html: html,
            text: text.substring(0, 1000),
            senderId: myClientId
          };
          
          addMessage(messageData, true, messageId, 'sending');
          pendingMessages.set(messageId, messageData);
          
          setTimeout(() => {
            if (pendingMessages.has(messageId)) {
              console.error('[SEND] ACK timeout for message:', messageId);
              const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
              if (msgElement) {
                msgElement.classList.remove('message-sending');
                msgElement.classList.add('message-error');
                const statusSpan = msgElement.querySelector('.message-status');
                if (statusSpan) {
                  statusSpan.textContent = 'Failed to send (timeout)';
                }
              }
              pendingMessages.delete(messageId);
            }
          }, 5000);
          
          clearComposer();
          ws.send(JSON.stringify(messageData));
          console.log('[SEND] Message sent, id=' + messageId);
        }
      } catch (error) {
        console.error('[SEND] Error:', error);
        showStatus('Send failed: ' + error.message, 'error');
        
        const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
        if (msgElement) {
          msgElement.classList.remove('message-sending');
          msgElement.classList.add('message-error');
          const statusSpan = msgElement.querySelector('.message-status');
          if (statusSpan) {
            statusSpan.textContent = 'Failed to send';
          }
        }
        
        pendingMessages.delete(messageId);
      } finally {
        sendBtn.disabled = false;
      }
    }

    function disableInputs(disabled) {
      document.getElementById('sendBtn').disabled = disabled;
      document.getElementById('composer').contentEditable = !disabled;
      document.getElementById('mediaBtn').disabled = disabled;
      document.getElementById('audioBtn').disabled = disabled;
    }

    // ========================================
    // AUDIO RECORDING (unchanged)
    // ========================================
    
    async function startAudioRecording() {
      try {
        let permissionGranted = false;
        
        if (navigator.permissions && navigator.permissions.query) {
          try {
            const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
            console.log('[MIC] Permission status:', permissionStatus.state);
            
            if (permissionStatus.state === 'denied') {
              showStatus('Mic blocked - please enable in browser settings', 'error');
              return;
            }
            
            permissionGranted = permissionStatus.state === 'granted';
          } catch (permErr) {
            console.log('[MIC] Permission query not supported');
          }
        }
        
        try {
          audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log('[MIC] Access granted');
        } catch (error) {
          console.error('[MIC] getUserMedia error:', error);
          
          if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            showStatus('Mic blocked - please enable in browser settings', 'error');
          } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            showStatus('Mic error (no device found)', 'error');
          } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            showStatus('Mic error (device busy or OS blocked)', 'error');
          } else {
            showStatus(`Mic error (${error.name || 'unknown'})`, 'error');
          }
          return;
        }
        
        audioChunks = [];
        
        let mimeType = 'audio/webm';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = 'audio/webm;codecs=opus';
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'audio/ogg;codecs=opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
              mimeType = '';
            }
          }
        }

        recorder = new MediaRecorder(audioStream, mimeType ? { mimeType } : {});

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) audioChunks.push(e.data);
        };

        recorder.onstop = () => {
          if (audioStream) {
            audioStream.getTracks().forEach(t => t.stop());
            audioStream = null;
          }

          const blob = new Blob(audioChunks, { type: recorder.mimeType || 'audio/webm' });
          if (blob.size === 0) {
            showStatus('Recording failed (empty audio)', 'error');
            resetAudioButton();
            return;
          }

          createAudioDraft(blob);
        };

        recorder.start();
        recordingStartTime = Date.now();

        const indicator = document.getElementById('recordingIndicator');
        indicator.classList.add('active');

        const timerInterval = setInterval(() => {
          if (!recorder || recorder.state === 'inactive') {
            clearInterval(timerInterval);
            return;
          }
          const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
          document.getElementById('recordingTimer').textContent = elapsed + 's / 30s';
        }, 100);

        recordTimer = setTimeout(() => {
          stopAudioRecording();
          clearInterval(timerInterval);
        }, 30000);

      } catch (error) {
        showStatus('Microphone access error: ' + error.message, 'error');
        console.error('[AUDIO] Error:', error);
        
        if (audioStream) {
          audioStream.getTracks().forEach(t => t.stop());
          audioStream = null;
        }
      }
    }

    function stopAudioRecording() {
      if (recordTimer) clearTimeout(recordTimer);
      recordTimer = null;
      
      if (recorder && recorder.state !== 'inactive') {
        recorder.stop();
      }

      const indicator = document.getElementById('recordingIndicator');
      indicator.classList.remove('active');
    }

    function resetAudioButton() {
      document.getElementById('audioBtn').textContent = 'Audio Message';
      document.getElementById('audioBtn').style.background = '';
    }

    function createAudioDraft(blob) {
      audioDraftBlob = blob;
      
      if (audioDraftURL) {
        URL.revokeObjectURL(audioDraftURL);
      }
      
      audioDraftURL = URL.createObjectURL(blob);
      
      // Create file attachment
      const ext = blob.type.includes('ogg') ? 'ogg' : 'webm';
      const file = new File([blob], `audio-${Date.now()}.${ext}`, { type: blob.type });
      selectedFile = file;
      
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
      }
      previewURL = audioDraftURL;
      
      // Show in unified media composer
      const composer = document.getElementById('photoComposer');
      const previewImg = document.getElementById('previewImage');
      const previewVideo = document.getElementById('previewVideo');
      const previewAudio = document.getElementById('previewAudio');
      const previewFilename = document.getElementById('previewFilename');
      const previewSize = document.getElementById('previewSize');
      const mediaTypeLabel = document.getElementById('mediaTypeLabel');
      
      // Hide other media types
      previewImg.style.display = 'none';
      previewVideo.style.display = 'none';
      
      // Show audio preview
      previewAudio.style.display = 'block';
      previewAudio.src = audioDraftURL;
      previewFilename.textContent = file.name;
      previewSize.textContent = formatFileSize(blob.size);
      mediaTypeLabel.textContent = 'Voice Message';
      
      composer.classList.add('active');
      document.getElementById('composer').focus();
      
      resetAudioButton();
      
      console.log('[AUDIO] Draft created in unified composer, size:', blob.size);
    }

    function discardAudioDraft() {
      // Just use the unified removal function
      removePhotoAttachment();
      
      if (audioDraftURL) {
        URL.revokeObjectURL(audioDraftURL);
        audioDraftURL = null;
      }
      
      audioDraftBlob = null;
    }

    // REMOVED: sendAudioDraft() - Audio now uses unified sendMessage() flow
    // Audio attachments are created in createAudioDraft() and sent via the main sendMessage() function

    function toggleAudioRecording() {
      if (recorder && recorder.state === 'recording') {
        stopAudioRecording();
      } else {
        startAudioRecording();
      }
    }

    // ========================================
    // MEDIA MENU & VIDEO RECORDING
    // ========================================
    
    /* Test matrix for video feature:
     * - Desktop Chrome/Edge: MediaRecorder API for video capture
     * - Desktop Safari: MediaRecorder API or fallback to native file input
     * - iPhone Safari: Native video capture input with size validation
     * - Android Chrome: MediaRecorder API or native input
     */
    
    function toggleMediaMenu() {
      const menu = document.getElementById('mediaMenu');
      menu.classList.toggle('active');
    }

    // Close media menu when clicking outside
    document.addEventListener('click', (e) => {
      const mediaBtn = document.getElementById('mediaBtn');
      const menu = document.getElementById('mediaMenu');
      if (menu && !mediaBtn.contains(e.target) && !menu.contains(e.target)) {
        menu.classList.remove('active');
      }
    });

    function selectMediaOption(option) {
      const menu = document.getElementById('mediaMenu');
      menu.classList.remove('active');
      
      if (option === 'photo') {
        openCamera();
      } else if (option === 'video') {
        openVideoCapture();
      } else if (option === 'file') {
        document.getElementById('fileInput').click();
      }
    }

    function openVideoCapture() {
      // Detect if we're on iPhone/iOS
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      
      if (isIOS) {
        // Use native video input on iOS
        console.log('[VIDEO] iOS detected - using native video input');
        document.getElementById('videoInput').click();
      } else {
        // Use custom recording UI on desktop
        console.log('[VIDEO] Desktop detected - showing quality selector');
        openVideoModal();
      }
    }

    function openVideoModal() {
      const modal = document.getElementById('cameraModal');
      const title = document.getElementById('cameraModalTitle');
      const qualitySelector = document.getElementById('videoQualitySelector');
      const preview = document.getElementById('cameraPreview');
      const controls = document.getElementById('cameraControls');
      const recordingUI = document.getElementById('videoRecordingUI');
      
      currentCameraMode = 'video';
      title.textContent = 'Record Video';
      qualitySelector.style.display = 'block';
      preview.style.display = 'none';
      controls.style.display = 'none';
      recordingUI.style.display = 'none';
      
      modal.classList.add('active');
    }

    function selectVideoQuality(quality, maxDuration) {
      videoQuality = quality;
      videoMaxDuration = maxDuration;
      
      console.log(`[VIDEO] Selected ${quality}, max ${maxDuration}s`);
      
      const qualitySelector = document.getElementById('videoQualitySelector');
      qualitySelector.style.display = 'none';
      
      startVideoRecording();
    }

    async function startVideoRecording() {
      try {
        const preview = document.getElementById('cameraPreview');
        const recordingUI = document.getElementById('videoRecordingUI');
        const controls = document.getElementById('cameraControls');
        const captureBtn = document.getElementById('captureBtn');
        
        console.log('[VIDEO] Starting video recording flow...');
        
        // Step 1: Check if we already have an active stream from photo mode
        if (cameraStream && cameraStream.active) {
          const existingVideoTrack = cameraStream.getVideoTracks()[0];
          if (existingVideoTrack && existingVideoTrack.readyState === 'live') {
            console.log('[VIDEO] Reusing existing camera stream from photo mode');
            videoStream = cameraStream;
            
            // Try to apply resolution constraints to the existing track
            try {
              const idealWidth = videoQuality === '1080p' ? 1920 : 1280;
              const idealHeight = videoQuality === '1080p' ? 1080 : 720;
              
              await existingVideoTrack.applyConstraints({
                width: { ideal: idealWidth },
                height: { ideal: idealHeight },
                frameRate: { ideal: 30 }
              });
              
              const settings = existingVideoTrack.getSettings();
              console.log('[VIDEO] Applied resolution constraints. New settings:', {
                width: settings.width,
                height: settings.height,
                frameRate: settings.frameRate
              });
            } catch (constraintError) {
              console.warn('[VIDEO] Could not apply resolution constraints, using existing resolution:', constraintError.message);
              // Continue anyway - we have a working stream
            }
            
            preview.srcObject = videoStream;
            preview.style.display = 'block';
            recordingUI.style.display = 'flex';
            controls.style.display = 'flex';
            
            captureBtn.textContent = 'Start Recording';
            captureBtn.onclick = beginVideoRecording;
            return;
          }
        }
        
        // Step 2: No existing stream, need to acquire a new one
        // First enumerate devices to check camera availability
        let devices = [];
        let videoInputs = [];
        try {
          devices = await navigator.mediaDevices.enumerateDevices();
          videoInputs = devices.filter(d => d.kind === 'videoinput');
          console.log('[VIDEO] Enumerated devices - found', videoInputs.length, 'videoinput device(s)');
        } catch (enumError) {
          console.warn('[VIDEO] Device enumeration failed:', enumError);
          // Continue anyway - getUserMedia might still work
        }
        
        // Step 3: Try getUserMedia with progressive fallback
        // Attempt A: video + audio
        let stream = null;
        let lastError = null;
        
        try {
          console.log('[VIDEO] Attempt A: getUserMedia({ video: true, audio: true })');
          stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          console.log('[VIDEO] ‚úì Success with video + audio');
        } catch (error) {
          console.warn('[VIDEO] Attempt A failed:', error.name, '-', error.message);
          console.log('[VIDEO] Full error object:', error);
          lastError = error;
          
          // Attempt B: video only (microphone issues must not block video)
          try {
            console.log('[VIDEO] Attempt B: getUserMedia({ video: true, audio: false })');
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
            console.log('[VIDEO] ‚úì Success with video only (no audio)');
          } catch (error2) {
            console.error('[VIDEO] Attempt B failed:', error2.name, '-', error2.message);
            console.log('[VIDEO] Full error object:', error2);
            lastError = error2;
          }
        }
        
        // If all attempts failed, show appropriate error message
        if (!stream) {
          console.error('[VIDEO] All getUserMedia attempts failed');
          
          // Classify error properly
          let errorMsg = 'Camera access failed';
          
          if (lastError.name === 'NotAllowedError' || lastError.name === 'PermissionDeniedError') {
            errorMsg = 'Camera permission denied';
          } else if (lastError.name === 'NotReadableError' || lastError.name === 'TrackStartError') {
            errorMsg = 'Camera is busy in another app';
          } else if (lastError.name === 'NotFoundError') {
            // Only show "No camera found" if we confirmed zero videoinput devices
            if (videoInputs.length === 0) {
              errorMsg = 'No camera found - please connect a camera';
            } else {
              errorMsg = 'Camera not available';
            }
          } else {
            errorMsg = `Camera error: ${lastError.name}`;
          }
          
          showStatus(errorMsg, 'error');
          closeCamera();
          return;
        }
        
        // Success - we have a stream
        videoStream = stream;
        
        // Step 4: Apply resolution constraints using track.applyConstraints with ideal (not exact)
        const videoTrack = videoStream.getVideoTracks()[0];
        if (videoTrack) {
          try {
            const idealWidth = videoQuality === '1080p' ? 1920 : 1280;
            const idealHeight = videoQuality === '1080p' ? 1080 : 720;
            
            console.log('[VIDEO] Applying resolution constraints:', { width: idealWidth, height: idealHeight });
            
            await videoTrack.applyConstraints({
              width: { ideal: idealWidth },
              height: { ideal: idealHeight },
              frameRate: { ideal: 30 }
            });
            
            const settings = videoTrack.getSettings();
            console.log('[VIDEO] Applied constraints. Stream settings:', {
              width: settings.width,
              height: settings.height,
              frameRate: settings.frameRate,
              deviceId: settings.deviceId
            });
          } catch (constraintError) {
            console.warn('[VIDEO] Could not apply resolution constraints:', constraintError.message);
            console.log('[VIDEO] Keeping recording at default resolution');
            // Continue anyway - we have a working stream
          }
        }
        
        preview.srcObject = videoStream;
        preview.style.display = 'block';
        recordingUI.style.display = 'flex';
        controls.style.display = 'flex';
        
        // Change capture button to "Start Recording"
        captureBtn.textContent = 'Start Recording';
        captureBtn.onclick = beginVideoRecording;
        
      } catch (error) {
        console.error('[VIDEO] Unexpected error in startVideoRecording:', error);
        showStatus('Camera access error: ' + error.message, 'error');
        closeCamera();
      }
    }

    async function beginVideoRecording() {
      try {
        videoChunks = [];
        
        // Check MediaRecorder support with proper fallback chain
        const mimeTypes = [
          'video/webm;codecs=vp9,opus',
          'video/webm;codecs=vp8,opus',
          'video/webm'
        ];
        
        let selectedMimeType = null;
        for (const mimeType of mimeTypes) {
          if (MediaRecorder.isTypeSupported(mimeType)) {
            selectedMimeType = mimeType;
            console.log('[VIDEO] Selected mimeType:', selectedMimeType);
            break;
          }
        }
        
        if (!selectedMimeType) {
          console.error('[VIDEO] No supported video mimeType found');
          showStatus('Video recording not supported on this browser. Please use a different browser or the native file picker.', 'error');
          closeCamera();
          // Fallback to native input
          document.getElementById('videoInput').click();
          return;
        }
        
        videoRecorder = new MediaRecorder(videoStream, {
          mimeType: selectedMimeType,
          videoBitsPerSecond: videoQuality === '1080p' ? 5000000 : 2500000
        });
        
        videoRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            videoChunks.push(e.data);
          }
        };
        
        videoRecorder.onstop = () => {
          handleVideoRecordingComplete();
        };
        
        videoRecorder.start();
        videoRecordingStartTime = Date.now();
        
        // Update UI
        const captureBtn = document.getElementById('captureBtn');
        captureBtn.textContent = 'Stop Recording';
        captureBtn.onclick = stopVideoRecording;
        captureBtn.style.background = '#dc3545';
        
        // Update timer
        const timerInterval = setInterval(() => {
          if (!videoRecorder || videoRecorder.state !== 'recording') {
            clearInterval(timerInterval);
            return;
          }
          
          const elapsed = (Date.now() - videoRecordingStartTime) / 1000;
          const remaining = videoMaxDuration - elapsed;
          
          document.getElementById('videoTimer').textContent = 
            `${elapsed.toFixed(1)}s / ${videoMaxDuration}s`;
          
          const progress = (elapsed / videoMaxDuration) * 100;
          document.getElementById('videoProgressBar').style.width = progress + '%';
        }, 100);
        
        // Auto-stop after max duration
        videoRecordTimer = setTimeout(() => {
          clearInterval(timerInterval);
          stopVideoRecording();
        }, videoMaxDuration * 1000);
        
      } catch (error) {
        console.error('[VIDEO] Recording start error:', error);
        showStatus('Failed to start recording: ' + error.message, 'error');
        closeCamera();
      }
    }

    function stopVideoRecording() {
      if (videoRecordTimer) {
        clearTimeout(videoRecordTimer);
        videoRecordTimer = null;
      }
      
      if (videoRecorder && videoRecorder.state !== 'inactive') {
        videoRecorder.stop();
      }
      
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
      }
    }

    async function handleVideoRecordingComplete() {
      const blob = new Blob(videoChunks, { type: 'video/webm' });
      
      console.log('[VIDEO] Recording complete, size:', formatFileSize(blob.size));
      
      // Check size (10MB limit)
      if (blob.size > 10 * 1024 * 1024) {
        showStatus('Video too large (>10MB). Please record a shorter video.', 'error');
        closeCamera();
        return;
      }
      
      // Create file and attach it
      const file = new File([blob], `video-${Date.now()}.webm`, { type: 'video/webm' });
      selectedFile = file;
      
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
      }
      
      previewURL = URL.createObjectURL(file);
      
      // Show in unified media composer with video preview
      const composer = document.getElementById('photoComposer');
      const previewImg = document.getElementById('previewImage');
      const previewVideo = document.getElementById('previewVideo');
      const previewAudio = document.getElementById('previewAudio');
      const previewFilename = document.getElementById('previewFilename');
      const previewSize = document.getElementById('previewSize');
      const mediaTypeLabel = document.getElementById('mediaTypeLabel');
      
      // Hide other media types
      previewImg.style.display = 'none';
      previewAudio.style.display = 'none';
      
      // Show video preview
      previewVideo.style.display = 'block';
      previewVideo.src = previewURL;
      previewFilename.textContent = file.name;
      previewSize.textContent = formatFileSize(file.size);
      mediaTypeLabel.textContent = 'Video Attached';
      
      // Add click handler for full preview
      previewVideo.onclick = () => openVideoPreview(previewURL);
      
      composer.classList.add('active');
      closeCamera();
      document.getElementById('composer').focus();
      
      showStatus('Video ready to send!', 'success');
    }

    async function handleVideoSelect() {
      const videoInput = document.getElementById('videoInput');
      const file = videoInput.files[0];
      
      if (!file) return;
      
      console.log('[VIDEO] Native input file selected:', file.name, formatFileSize(file.size));
      
      // Check size (10MB limit)
      if (file.size > 10 * 1024 * 1024) {
        showStatus('Video too large (>10MB). Please choose a smaller video.', 'error');
        videoInput.value = '';
        return;
      }
      
      selectedFile = file;
      
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
      }
      
      previewURL = URL.createObjectURL(file);
      
      // Show in unified media composer with video preview
      const composer = document.getElementById('photoComposer');
      const previewImg = document.getElementById('previewImage');
      const previewVideo = document.getElementById('previewVideo');
      const previewAudio = document.getElementById('previewAudio');
      const previewFilename = document.getElementById('previewFilename');
      const previewSize = document.getElementById('previewSize');
      const mediaTypeLabel = document.getElementById('mediaTypeLabel');
      
      // Hide other media types
      previewImg.style.display = 'none';
      previewAudio.style.display = 'none';
      
      // Show video preview
      previewVideo.style.display = 'block';
      previewVideo.src = previewURL;
      previewFilename.textContent = file.name;
      previewSize.textContent = formatFileSize(file.size);
      mediaTypeLabel.textContent = 'Video Attached';
      
      // Add click handler for full preview
      previewVideo.onclick = () => openVideoPreview(previewURL);
      
      composer.classList.add('active');
      document.getElementById('composer').focus();
      
      videoInput.value = '';
    }
      
      composer.classList.add('active');
      document.getElementById('composer').focus();
    }

    function openVideoPreview(url, filename) {
      const modal = document.getElementById('videoModal');
      const video = document.getElementById('fullscreenVideo');
      const downloadLink = document.getElementById('videoDownloadLink');
      
      video.src = url;
      downloadLink.href = url;
      downloadLink.download = filename || 'video.webm';
      
      modal.classList.add('active');
      video.play();
    }

    function closeVideoPreview() {
      const modal = document.getElementById('videoModal');
      const video = document.getElementById('fullscreenVideo');
      
      video.pause();
      video.src = '';
      modal.classList.remove('active');
    }

    // ========================================
    // FILE/PHOTO HANDLING
    // ========================================
    
    function handleFileSelect() {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      
      if (!file) return;

      // Check for dangerous file extensions
      if (isDangerousFile(file.name)) {
        showStatus(`File type not allowed for security reasons: ${getFileExtension(file.name)}`, 'error');
        fileInput.value = '';
        return;
      }

      if (file.size > 10 * 1024 * 1024) {
        showStatus('File size must be less than 10MB', 'error');
        fileInput.value = '';
        return;
      }

      selectedFile = file;
      
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
      }
      
      previewURL = URL.createObjectURL(file);
      
      const composer = document.getElementById('photoComposer');
      const previewImg = document.getElementById('previewImage');
      const previewVideo = document.getElementById('previewVideo');
      const previewAudio = document.getElementById('previewAudio');
      const previewFilename = document.getElementById('previewFilename');
      const previewSize = document.getElementById('previewSize');
      const mediaTypeLabel = document.getElementById('mediaTypeLabel');
      
      // Determine file type
      const isImage = isImageFile(file.name, file.type);
      const isVideo = isVideoFile(file.name, file.type);
      const isAudio = isAudioFile(file.name, file.type);
      
      // Hide all preview types first
      previewImg.style.display = 'none';
      previewVideo.style.display = 'none';
      previewAudio.style.display = 'none';
      
      if (isImage) {
        previewImg.style.display = 'block';
        previewImg.src = previewURL;
        previewImg.onclick = () => openImagePreview(previewURL);
        mediaTypeLabel.textContent = 'Photo Attached';
      } else if (isVideo) {
        previewVideo.style.display = 'block';
        previewVideo.src = previewURL;
        previewVideo.onclick = () => openVideoPreview(previewURL);
        mediaTypeLabel.textContent = 'Video Attached';
      } else if (isAudio) {
        previewAudio.style.display = 'block';
        previewAudio.src = previewURL;
        mediaTypeLabel.textContent = 'Audio Attached';
      } else {
        mediaTypeLabel.textContent = 'File Attached';
      }
      
      previewFilename.textContent = file.name;
      previewSize.textContent = formatFileSize(file.size);
      
      composer.classList.add('active');
      document.getElementById('composer').focus();
    }

    function removePhotoAttachment() {
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
        previewURL = null;
      }
      
      selectedFile = null;
      document.getElementById('fileInput').value = '';
      document.getElementById('videoInput').value = '';
      
      // Clear all preview elements
      const previewImg = document.getElementById('previewImage');
      const previewVideo = document.getElementById('previewVideo');
      const previewAudio = document.getElementById('previewAudio');
      
      previewImg.src = '';
      previewImg.style.display = 'none';
      previewVideo.src = '';
      previewVideo.style.display = 'none';
      previewAudio.src = '';
      previewAudio.style.display = 'none';
      
      const composer = document.getElementById('photoComposer');
      composer.classList.remove('active');
    }

    async function openCamera() {
      try {
        const modal = document.getElementById('cameraModal');
        const video = document.getElementById('cameraPreview');
        const title = document.getElementById('cameraModalTitle');
        const qualitySelector = document.getElementById('videoQualitySelector');
        const recordingUI = document.getElementById('videoRecordingUI');
        const controls = document.getElementById('cameraControls');
        const captureBtn = document.getElementById('captureBtn');
        
        currentCameraMode = 'photo';
        title.textContent = 'Take a Photo';
        qualitySelector.style.display = 'none';
        recordingUI.style.display = 'none';
        controls.style.display = 'flex';
        video.style.display = 'block';
        
        captureBtn.textContent = 'Capture';
        captureBtn.onclick = capturePhoto;
        captureBtn.style.background = '';
        
        cameraStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'user' },
          audio: false 
        });
        
        video.srcObject = cameraStream;
        modal.classList.add('active');
      } catch (error) {
        alert('Camera access denied or not available: ' + error.message);
      }
    }

    function closeCamera() {
      const modal = document.getElementById('cameraModal');
      const video = document.getElementById('cameraPreview');
      
      // Stop all tracks from both camera and video streams
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
      }
      
      if (videoRecorder && videoRecorder.state !== 'inactive') {
        videoRecorder.stop();
      }
      
      if (videoRecordTimer) {
        clearTimeout(videoRecordTimer);
        videoRecordTimer = null;
      }
      
      video.srcObject = null;
      modal.classList.remove('active');
      
      // Reset progress bar
      document.getElementById('videoProgressBar').style.width = '0%';
    }

    function capturePhoto() {
      const video = document.getElementById('cameraPreview');
      const canvas = document.getElementById('cameraCanvas');
      const context = canvas.getContext('2d');

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      context.drawImage(video, 0, 0);

      canvas.toBlob((blob) => {
        const file = new File([blob], `camera-${Date.now()}.jpg`, { type: 'image/jpeg' });
        
        // Store as pending attachment
        selectedFile = file;
        
        if (previewURL) {
          URL.revokeObjectURL(previewURL);
        }
        
        previewURL = URL.createObjectURL(file);
        
        // Show preview in unified media composer
        const composer = document.getElementById('photoComposer');
        const previewImg = document.getElementById('previewImage');
        const previewVideo = document.getElementById('previewVideo');
        const previewAudio = document.getElementById('previewAudio');
        const previewFilename = document.getElementById('previewFilename');
        const previewSize = document.getElementById('previewSize');
        const mediaTypeLabel = document.getElementById('mediaTypeLabel');
        
        // Hide other media types
        previewVideo.style.display = 'none';
        previewAudio.style.display = 'none';
        
        // Show image preview
        previewImg.style.display = 'block';
        previewImg.src = previewURL;
        previewFilename.textContent = file.name;
        previewSize.textContent = formatFileSize(file.size);
        mediaTypeLabel.textContent = 'Photo Attached';
        
        composer.classList.add('active');
        closeCamera();
        document.getElementById('composer').focus();
      }, 'image/jpeg', 0.8);
    }

    function openImagePreview(url) {
      const modal = document.getElementById('imageModal');
      const img = document.getElementById('fullscreenImage');
      img.src = url;
      modal.classList.add('active');
    }

    function closeImagePreview() {
      const modal = document.getElementById('imageModal');
      modal.classList.remove('active');
    }

    function toggleDarkMode() {
      const body = document.body;
      const button = document.querySelector('.dark-mode-toggle');
      
      if (body.classList.contains('light-mode')) {
        body.className = 'dark-mode';
        button.textContent = 'Light Mode';
        localStorage.setItem('darkMode', 'true');
      } else {
        body.className = 'light-mode';
        button.textContent = 'Dark Mode';
        localStorage.setItem('darkMode', 'false');
      }
    }

    function scrollToBottom() {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Send message on Enter key (Shift+Enter for new line in contenteditable)
    document.getElementById('composer').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  </script>
</body>
</html>
