<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Multiplayer Tank Game — v2.2.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Favicons -->
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png" />
  <style>
    :root{
      --ui-bg: rgba(0,0,0,.65);
      --ui-text:#ffdd00;
    }
    html,body{margin:0;padding:0;height:100%;background:#0e1317;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    canvas{display:block}

    /* Info bar (top-right, draggable) */
    #infoBar{
      position:fixed; top:12px; right:12px; z-index:200; user-select:none; cursor:move;
      background:var(--ui-bg); color:var(--ui-text); padding:10px 12px; border-radius:10px; font-size:14px;
    }
    #infoBar .line{display:flex; align-items:center; gap:10px; margin:4px 0}
    #capacityWrap{display:flex; align-items:center; gap:8px}
    #capacityBar{ width:120px; height:8px; background:#2a3340; border-radius:6px; overflow:hidden; border:1px solid #3b4756;}
    #capacityFill{height:100%; width:0%; background:#56d364}

    /* Minimap (top-left) */
    #minimap{
      position:fixed; top:12px; left:12px; width:220px; height:220px; border-radius:12px;
      border: 2px solid #fff; background: rgba(0,0,0,.55); z-index:120;
    }

    /* HUD */
    #globalChatLog{
      position:fixed; left:0; right:0; bottom:0; max-height:180px; overflow-y:auto;
      background:var(--ui-bg); color:#fff; padding:8px 10px; z-index:110; display:none;
    }
    #globalChatLog p{margin:2px 0}
    #chatInput{
      position:fixed; left:50%; transform:translateX(-50%); bottom:186px; width:min(720px,90vw);
      padding:10px 12px; font-size:16px; border-radius:10px; border:1px solid #666; outline:none; display:none; z-index:150;
      background:#0c1218; color:#e7eef5;
    }
    #healthBarContainer{
      position:fixed; bottom:210px; left:50%; transform:translateX(-50%); width:240px; height:18px; border-radius:10px;
      background:#3b3b3b; border:2px solid #222; z-index:140; display:none; /* shown after game start */
    }
    #healthBar{height:100%; width:100%; background:#16c60c; border-radius:8px}

    #killFeed{position:fixed; top:12px; right:12px; color:#fff; z-index:120; transform:translateY(72px);}
    #killFeed p{margin:2px 0}

    #damageOverlay{position:fixed; inset:0; pointer-events:none; z-index:160; background:rgba(255,0,0,0); transition:background .18s ease-out}
    #versionTag{position:fixed; bottom:12px; left:12px; color:#9aa3af; font-size:12px; z-index:120; opacity:.85}
  </style>

  <script>
    // ===== Redirect to login.html unless nickname & color are set =====
    (function(){
      const nick = localStorage.getItem("nickname");
      const color = localStorage.getItem("tankColor");
      if (!nick || !color) {
        // redirect early before any heavy initialization
        window.location.replace("login.html");
      }
    })();
  </script>
</head>
<body>
  <!-- Info Bar -->
  <div id="infoBar">
    <div class="line"><strong>Connection:</strong> <span id="latencyDisplay">Waiting…</span></div>
    <div class="line" id="capacityWrap">
      <strong>Players:</strong> <span id="playerCount">0/20</span>
      <div id="capacityBar"><div id="capacityFill"></div></div>
    </div>
  </div>

  <!-- HUD -->
  <canvas id="minimap" width="220" height="220"></canvas>
  <div id="killFeed"></div>
  <div id="globalChatLog"></div>
  <input id="chatInput" type="text" placeholder="Type a message and press Enter…" />
  <div id="healthBarContainer"><div id="healthBar"></div></div>
  <div id="damageOverlay"></div>
  <div id="versionTag">v2.2.0</div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
    /************ 0) Performance knobs ************/
    const PERF = {
      pixelRatioCap: 1.2,
      dynamicScale: true,
      dynamicScaleMin: 0.7,
      shadows: false,
      shadowMapSize: 1024,
      terrainSegments: 80,
      tiltOnGround: false,  // keeps turret steady
      minimapHz: 8,
      trailMax: 120,
      trailEveryMs: 80,
      labelFaceHz: 12,
    };

    /************ 1) Globals & Config ************/
    const VERSION = "2.2.0";
    const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;

    const els = {
      latency: document.getElementById("latencyDisplay"),
      players: document.getElementById("playerCount"),
      capFill: document.getElementById("capacityFill"),
      chatLog: document.getElementById("globalChatLog"),
      chatInput: document.getElementById("chatInput"),
      healthWrap: document.getElementById("healthBarContainer"),
      health: document.getElementById("healthBar"),
      minimap: document.getElementById("minimap"),
      killFeed: document.getElementById("killFeed"),
      damageOverlay: document.getElementById("damageOverlay"),
      infoBar: document.getElementById("infoBar"),
    };

    const thresholds = { excellent:50, good:100, ok:200, poor:400 };
    const world = { size: 1000, half: 500 };
    const moveSpeed = 16;       // units/sec
    const turnSpeed = 2.2;      // rad/sec
    const turnHoldLimit = 5.0;  // seconds; after holding L/R this long, turning stops until release
    const updateHz  = 14;       // network sends per sec
    const fireCooldownMs = 350; // no spacebar hold spam
    const maxPlayers = 20;

    const missileTypes = {
      bullet: { speed: 110, radius: 0.22, damage: 28, explosion: 5 },
      splash: { speed: 85,  radius: 0.30, damage: 22, explosion: 8 },
      rocket: { speed: 65,  radius: 0.20, damage: 45, explosion: 10 },
    };

    // Game state
    let scene, camera, renderer, clock;
    let localTank, ws;
    let remoteTanks = new Map(); // id -> { mesh, nickname, health }
    let missiles = [], trailParticles = [];
    let cameraMode = 1;
    let turretLocalTarget = 0; // desired turret local yaw
    let localHealth = 100;
    let lastNetUpdate = 0, lastSentPos, lastSentRot;
    let controls = { f:false, b:false, l:false, r:false, boost:false };
    let turnHold = { l:0, r:0 }; // seconds held
    let connected = false, lastPong = 0, pingTimer = null;
    let playerData = {
      id: Math.random().toString(36).slice(2,12),
      nickname: localStorage.getItem("nickname"),
      color: localStorage.getItem("tankColor") || ("#"+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,"0")),
    };
    let spaceHeld = false, lastFireTime = 0;

    /************ 2) Utils ************/
    function sanitize(s){return (s||"").toString().replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]))}
    function clamp(x,min,max){return Math.max(min,Math.min(max,x))}
    function normAngle(a){ a = (a + Math.PI) % (2*Math.PI); if (a < 0) a += 2*Math.PI; return a - Math.PI; }
    function lerpAngle(a,b,t){ let d = normAngle(b - a); return a + d * t; }
    function latencyLabel(ms){
      if (ms < thresholds.excellent) return "Excellent";
      if (ms < thresholds.good) return "Good";
      if (ms < thresholds.ok) return "Ok";
      if (ms < thresholds.poor) return "Poor";
      return "Poor";
    }
    function updateCapacityBar(count){
      const pct = clamp(Math.round((count/maxPlayers)*100), 0, 100);
      els.players.textContent = `${count}/${maxPlayers}`;
      els.capFill.style.width = pct + "%";
      els.capFill.style.background = pct < 70 ? "#56d364" : (pct < 90 ? "#ffb020" : "#ff5252");
    }
    function addKillFeed(text){
      const p=document.createElement("p"); p.textContent=text; els.killFeed.appendChild(p); setTimeout(()=>p.remove(),6000);
    }
    function addChat(text){
      els.chatLog.style.display="block";
      const p=document.createElement("p"); p.innerText=text; els.chatLog.appendChild(p);
      els.chatLog.scrollTop=els.chatLog.scrollHeight;
    }

    /************ 3) Three.js: Terrain helpers (no raycasts) ************/
    function terrainHeightAt(x, z) {
      return (Math.sin(x * 0.01) + Math.cos(z * 0.012) + Math.sin((x + z) * 0.006)) * 1.4;
    }

    /************ 4) Scene & Tank ************/
    function makeLabelSprite(name,text){
      const can=document.createElement("canvas"); can.width=256; can.height=64;
      const ctx=can.getContext("2d");
      ctx.fillStyle="rgba(0,0,0,.5)"; ctx.fillRect(0,0,can.width,can.height);
      ctx.font="28px Arial"; ctx.fillStyle="#fff"; ctx.textAlign="center";
      ctx.fillText(sanitize(text), can.width/2, can.height/2+10);
      const tex=new THREE.CanvasTexture(can);
      const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true}));
      spr.name=name; spr.scale.set(4.5,1.25,1); return spr;
    }
    function makeHealthBar(){
      const g=new THREE.Group();
      const bg=new THREE.Mesh(new THREE.PlaneGeometry(3.2,0.36), new THREE.MeshBasicMaterial({color:0x111111,transparent:true,opacity:.85}));
      const fg=new THREE.Mesh(new THREE.PlaneGeometry(3.0,0.24), new THREE.MeshBasicMaterial({color:0x16c60c}));
      fg.position.z=0.001; g.add(bg); g.add(fg); g.visible=false;
      return { group:g, set(pct){ const t=clamp(pct/100,0,1); fg.scale.x=t; fg.position.x=(t-1)*1.5; g.visible=pct<100; } };
    }
    function createTank(color,nickText){
      const tank=new THREE.Group();
      const body=new THREE.Mesh(
        new THREE.BoxGeometry(3.6,1.2,6.2),
        new THREE.MeshLambertMaterial({ color })
      );
      body.castShadow=body.receiveShadow=PERF.shadows; body.position.y=0.6; tank.add(body);
      const turret=new THREE.Group();
      const base=new THREE.Mesh(
        new THREE.BoxGeometry(2.6,1.0,3.0),
        new THREE.MeshLambertMaterial({ color })
      );
      base.position.y=0.5; base.castShadow=base.receiveShadow=PERF.shadows; turret.add(base);
      const cannon=new THREE.Mesh(
        new THREE.CylinderGeometry(0.2,0.2,5.2,16),
        new THREE.MeshLambertMaterial({ color: 0x333333 })
      );
      cannon.rotation.x=Math.PI/2; cannon.position.set(0,0.45,1.6); cannon.castShadow=cannon.receiveShadow=PERF.shadows; turret.add(cannon);
      turret.position.set(0,1.36,0); tank.add(turret);
      const label=makeLabelSprite("nickname", nickText);
      label.position.set(0,3.6,0); tank.add(label);
      const hb=makeHealthBar(); hb.group.position.set(0,3.2,0); tank.add(hb.group);
      tank.userData={ turret, cannon, label, healthBar:hb, health:100, nickname:nickText };
      return tank;
    }
    function buildTerrain(){
      const seg = PERF.terrainSegments;
      const geo = new THREE.PlaneGeometry(world.size, world.size, seg, seg);
      geo.rotateX(-Math.PI/2);
      const pos=geo.attributes.position;
      for(let i=0;i<pos.count;i++){
        const x=pos.getX(i), z=pos.getZ(i);
        const h=terrainHeightAt(x,z);
        pos.setY(i,h);
      }
      pos.needsUpdate=true; geo.computeVertexNormals();

      const loader = new THREE.TextureLoader();
      const tex = loader.load('rocky_trail_02_diff_4k.jpg');
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(50,50);
      // keep it light for GPU:
      tex.anisotropy = 1;

      const mat = new THREE.MeshLambertMaterial({ map: tex });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.receiveShadow = PERF.shadows;
      mesh.name = "terrain";
      return mesh;
    }

    /************ 5) Input ************/
    function onKeyDown(e){
      if (document.activeElement === els.chatInput) {
        if (e.key === "Escape") els.chatInput.blur();
        return;
      }
      switch(e.code){
        case "KeyW": case "ArrowUp": controls.f=true; break;
        case "KeyS": case "ArrowDown": controls.b=true; break;
        case "KeyA": case "ArrowLeft": controls.l=true; break;
        case "KeyD": case "ArrowRight": controls.r=true; break;
        case "ShiftLeft": controls.boost=true; break;
        case "Space":
          if (!spaceHeld) { spaceHeld = true; tryFire(); }
          e.preventDefault();
          break;
        case "Digit1": cameraMode=1; break;
        case "Digit2": cameraMode=2; break;
        case "Digit3": cameraMode=3; break;
        case "KeyC": toggleChat(); break;
      }
    }
    function onKeyUp(e){
      switch(e.code){
        case "KeyW": case "ArrowUp": controls.f=false; break;
        case "KeyS": case "ArrowDown": controls.b=false; break;
        case "KeyA": case "ArrowLeft": controls.l=false; turnHold.l = 0; break;
        case "KeyD": case "ArrowRight": controls.r=false; turnHold.r = 0; break;
        case "ShiftLeft": controls.boost=false; break;
        case "Space": spaceHeld=false; break;
      }
    }
    function onMouseDown(e){
      if (document.pointerLockElement === document.body && e.button===0) tryFire();
    }
    function onMouseMove(e){
      if (document.pointerLockElement !== document.body) return;
      if (!localTank) return;
      // Smooth, wrap-safe turret control
      turretLocalTarget = normAngle(turretLocalTarget - e.movementX * 0.002);
    }
    function toggleChat(){
      if (els.chatInput.style.display==="block"){
        els.chatInput.style.display="none";
        document.body.requestPointerLock?.();
      }else{
        els.chatInput.value="";
        els.chatInput.style.display="block";
        els.chatInput.focus();
        if (document.pointerLockElement===document.body) document.exitPointerLock();
      }
    }
    els.chatInput.addEventListener("keydown",(e)=>{
      if (e.key==="Enter"){
        const text = els.chatInput.value.trim();
        if (text && ws && ws.readyState===WebSocket.OPEN){
          ws.send(JSON.stringify({type:"chat", id:playerData.id, nickname:playerData.nickname, message:text}));
        }
        els.chatInput.value=""; els.chatInput.style.display="none"; document.body.requestPointerLock?.();
      } else if (e.key==="Escape"){
        els.chatInput.style.display="none"; document.body.requestPointerLock?.();
      }
    });

    /************ 6) Networking ************/
    function setupWebSocket(){
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        connected = true;
        els.latency.textContent = "Connected"; // show connected immediately
        // send join
        ws.send(JSON.stringify({
          type:"join",
          id: playerData.id,
          nickname: playerData.nickname,
          color: playerData.color,
          position: { x: localTank.position.x, y: localTank.position.y, z: localTank.position.z }
        }));
        // ping loop (if server replies with pong, we’ll show quality + player count)
        pingTimer = setInterval(()=>{
          if (ws && ws.readyState===WebSocket.OPEN) {
            ws.send(JSON.stringify({type:"ping", timestamp: performance.now()}));
          }
        }, 2000);
      };

      ws.onmessage = (ev) => {
        let msg; try{ msg=JSON.parse(ev.data);}catch{ return; }

        if (msg.type==="pong"){
          if (typeof msg.timestamp==="number"){
            const rtt = performance.now() - msg.timestamp;
            els.latency.textContent = latencyLabel(rtt);
            lastPong = performance.now();
          } else {
            els.latency.textContent = "Connected";
          }
          if (typeof msg.players==="number") updateCapacityBar(msg.players);
          return;
        }
        if (msg.type==="welcome"){
          els.latency.textContent = "Connected";
          if (typeof msg.players==="number") updateCapacityBar(msg.players);
          return;
        }

        const needsId = new Set(["join","leave","update","shoot","chat"]);
        if (needsId.has(msg.type)) {
          if (!msg.id) return;
          if (msg.id === playerData.id) return;
        }
        handleServerMessage(msg);
      };

      ws.onclose = () => {
        connected = false;
        els.latency.textContent = "Disconnected";
        clearInterval(pingTimer); pingTimer=null;
        setTimeout(setupWebSocket, 1500);
      };

      ws.onerror = (err) => console.error("WS error:", err);
    }

    function handleServerMessage(msg){
      switch(msg.type){
        case "join":{
          if (remoteTanks.has(msg.id)) return;
          const tank = createTank(msg.color, msg.nickname || "Player");
          tank.position.set(msg.position.x, msg.position.y, msg.position.z);
          scene.add(tank);
          remoteTanks.set(msg.id, { mesh:tank, nickname: msg.nickname || "Player", health:100 });
          updateCapacityBar( remoteTanks.size + 1 ); // + self
          break;
        }
        case "leave":{
          const r = remoteTanks.get(msg.id); if (!r) return;
          scene.remove(r.mesh); remoteTanks.delete(msg.id);
          updateCapacityBar( remoteTanks.size + 1 );
          break;
        }
        case "update":{
          const r = remoteTanks.get(msg.id); if (!r) return;
          const m = r.mesh;
          const target = new THREE.Vector3(msg.position.x, msg.position.y, msg.position.z);
          m.position.lerp(target, 0.12);
          m.rotation.y = THREE.MathUtils.lerp(m.rotation.y, msg.rotation, 0.12);
          break;
        }
        case "shoot":{
          spawnMissileForRemote(msg);
          addKillFeed(`${msg.nickname || "Player"} fired!`);
          break;
        }
        case "chat":{
          displayChatBubble(msg);
          addChat(`${msg.nickname}: ${msg.message}`);
          break;
        }
        case "kill":{
          addKillFeed(`${msg.killer} eliminated ${msg.victim}`);
          if (msg.victim === playerData.nickname) setTimeout(()=>location.reload(),1200);
          break;
        }
      }
    }

    /************ 7) Missiles ************/
    function tryFire(){
      const now = performance.now();
      if (now - lastFireTime < fireCooldownMs) return;
      lastFireTime = now;
      fireLocalMissile();
    }
    function fireLocalMissile(){
      const type="bullet";
      const props=missileTypes[type];
      const dir=new THREE.Vector3(); localTank.userData.turret.getWorldDirection(dir);
      const angle=Math.atan2(dir.x, dir.z);
      const start=new THREE.Vector3(); localTank.userData.cannon.getWorldPosition(start);
      start.add(dir.clone().multiplyScalar(3)); start.y += 0.8;
      spawnMissile(start, dir.clone().multiplyScalar(props.speed), type, playerData.id);
      if (ws && ws.readyState===WebSocket.OPEN){
        ws.send(JSON.stringify({
          type:"shoot", id:playerData.id, nickname:playerData.nickname,
          position:{x:start.x,y:start.y,z:start.z}, rotation:angle, missileType:type
        }));
      }
    }
    function spawnMissileForRemote(data){
      const type=data.missileType||"bullet"; const props=missileTypes[type]||missileTypes.bullet;
      const dir=new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), data.rotation);
      const start=new THREE.Vector3(data.position.x,data.position.y,data.position.z);
      spawnMissile(start, dir.multiplyScalar(props.speed), type, data.id);
    }
    function spawnMissile(position, velocity, type, ownerId){
      const props=missileTypes[type]||missileTypes.bullet;
      const geom=new THREE.SphereGeometry(props.radius,10,10);
      const mat=new THREE.MeshLambertMaterial({color:0xff5500});
      const mesh=new THREE.Mesh(geom,mat); mesh.position.copy(position); mesh.castShadow=PERF.shadows;
      missiles.push({mesh, velocity, type, ownerId, life:5, lastTrail:0});
      scene.add(mesh);
    }
    function createExplosion(pos, radius=2.2){
      const geom=new THREE.SphereGeometry(radius,12,12);
      const mat=new THREE.MeshBasicMaterial({color:0xffa000, transparent:true, opacity:.95});
      const shp=new THREE.Mesh(geom,mat); shp.position.copy(pos); scene.add(shp);
      const start=performance.now(), life=420;
      (function boom(){
        const t=performance.now()-start;
        if (t<life){ shp.material.opacity=Math.max(0,1-t/life); requestAnimationFrame(boom); }
        else scene.remove(shp);
      })();
      els.damageOverlay.style.background="rgba(255,0,0,.25)";
      setTimeout(()=>{ els.damageOverlay.style.background="rgba(255,0,0,0)"; },140);
    }

    /************ 8) Minimap, Camera, Grounding (no raycasts) ************/
    function updateMinimap(){
      const ctx=els.minimap.getContext("2d");
      const w=els.minimap.width, h=els.minimap.height;
      ctx.clearRect(0,0,w,h); ctx.fillStyle="rgba(0,0,0,.55)"; ctx.fillRect(0,0,w,h);
      function toMini(x,z){ return { x:(x+world.half)*(w/world.size), y:(world.half - z)*(h/world.size) }; }
      const lp=toMini(localTank.position.x, localTank.position.z);
      ctx.save(); ctx.translate(lp.x, lp.y); ctx.rotate(-localTank.rotation.y);
      ctx.beginPath(); ctx.moveTo(0,-7); ctx.lineTo(5.5,5); ctx.lineTo(-5.5,5); ctx.closePath();
      ctx.fillStyle = playerData.color; ctx.fill(); ctx.restore();
      ctx.fillStyle="#fff";
      remoteTanks.forEach(r=>{
        const p=toMini(r.mesh.position.x, r.mesh.position.z);
        ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
      });
    }

    function groundRayHeightCheap(group){
      const y = terrainHeightAt(group.position.x, group.position.z);
      group.position.y = y + 0.6;

      if (PERF.tiltOnGround) {
        const eps = 2;
        const h = y;
        const hX = terrainHeightAt(group.position.x + eps, group.position.z);
        const hZ = terrainHeightAt(group.position.x, group.position.z + eps);
        const normal = new THREE.Vector3(-(hX - h), eps, -(hZ - h)).normalize();
        const yaw = group.rotation.y;
        const f = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).projectOnPlane(normal).normalize();
        const r = new THREE.Vector3().crossVectors(normal,f).normalize();
        const m = new THREE.Matrix4().makeBasis(r,normal,f);
        const e = new THREE.Euler().setFromRotationMatrix(m);
        e.y=yaw; group.rotation.set(e.x,e.y,e.z);
      }
    }

    /************ 9) Trails + Missiles update ************/
    function updateMissiles(dt){
      for (let i=missiles.length-1;i>=0;i--){
        const m=missiles[i];
        m.mesh.position.add(m.velocity.clone().multiplyScalar(dt));
        m.life -= dt;

        // ground collision (cheap)
        const groundY = terrainHeightAt(m.mesh.position.x, m.mesh.position.z);
        if (m.mesh.position.y <= groundY + 0.5){
          createExplosion(m.mesh.position, missileTypes[m.type]?.explosion || 5);
          scene.remove(m.mesh); missiles.splice(i,1); continue;
        }

        // trail (throttled)
        if ((!m.lastTrail || (performance.now()-m.lastTrail) > PERF.trailEveryMs) && trailParticles.length < PERF.trailMax){
          const dot=new THREE.Mesh(new THREE.SphereGeometry(0.1,6,6), new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:.55}));
          dot.position.copy(m.mesh.position); dot.userData={life:.28}; scene.add(dot); trailParticles.push(dot);
          m.lastTrail = performance.now();
        }

        // hits
        if (m.ownerId===playerData.id){
          remoteTanks.forEach((r,rid)=>{
            if (m.mesh.position.distanceTo(r.mesh.position)<1.6){
              r.health = (r.health??100) - (missileTypes[m.type]?.damage || 30);
              r.mesh.userData.health = r.health;
              r.mesh.userData.healthBar.set(r.health);
              createExplosion(m.mesh.position, missileTypes[m.type]?.explosion || 5);
              scene.remove(m.mesh); missiles.splice(i,1);
              if (r.health<=0){
                if (ws && ws.readyState===WebSocket.OPEN){
                  ws.send(JSON.stringify({type:"kill", killer:playerData.nickname, victim:r.nickname||"Player"}));
                }
                scene.remove(r.mesh); remoteTanks.delete(rid); updateCapacityBar(remoteTanks.size+1);
              }
            }
          });
        } else {
          if (m.mesh.position.distanceTo(localTank.position)<1.6){
            localHealth -= (missileTypes[m.type]?.damage || 30);
            els.health.style.width = Math.max(localHealth,0) + "%";
            createExplosion(m.mesh.position, missileTypes[m.type]?.explosion || 5);
            scene.remove(m.mesh); missiles.splice(i,1);
            if (localHealth<=0) setTimeout(()=>location.reload(),1200);
          }
        }
        if (m.life<=0){
          createExplosion(m.mesh.position, missileTypes[m.type]?.explosion || 5);
          scene.remove(m.mesh); missiles.splice(i,1);
        }
      }
      // trail fade
      for (let j=trailParticles.length-1;j>=0;j--){
        const p=trailParticles[j]; p.userData.life -= dt; p.material.opacity = Math.max(0, p.userData.life/.28);
        if (p.userData.life<=0){ scene.remove(p); trailParticles.splice(j,1); }
      }
    }

    /************ 10) Scene init ************/
    function initScene(){
      clock=new THREE.Clock();
      scene=new THREE.Scene();

      // Use your sky texture (lightweight)
      const loader = new THREE.TextureLoader();
      loader.load('ClearSky.png', (tex) => { scene.background = tex; });

      scene.fog = null; // skybox handles background

      camera=new THREE.PerspectiveCamera(75, innerWidth/innerHeight, .1, 2000); camera.position.set(0,5.5,-10);

      const amb=new THREE.AmbientLight(0xffffff,.7); scene.add(amb);
      const dir=new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(90,120,-70);
      dir.castShadow = PERF.shadows;
      if (PERF.shadows){
        dir.shadow.mapSize.set(PERF.shadowMapSize, PERF.shadowMapSize);
        dir.shadow.camera.left=-240; dir.shadow.camera.right=240; dir.shadow.camera.top=240; dir.shadow.camera.bottom=-240;
      }
      scene.add(dir);

      renderer=new THREE.WebGLRenderer({ antialias: true });
      // cap pixel ratio
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, PERF.pixelRatioCap));
      renderer.setSize(innerWidth,innerHeight);
      renderer.shadowMap.enabled = PERF.shadows;
      if (PERF.shadows) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // dynamic scaling
      let renderScale = 1;
      function applyScale() {
        const w = Math.floor(innerWidth * renderScale);
        const h = Math.floor(innerHeight * renderScale);
        renderer.setSize(w, h, false);
        renderer.domElement.style.width = innerWidth + "px";
        renderer.domElement.style.height = innerHeight + "px";
      }
      applyScale();
      let ema = 0;
      function autoscale(dt) {
        if (!PERF.dynamicScale) return;
        ema = 0.9 * ema + 0.1 * dt;
        if (ema > 0.022 && renderScale > PERF.dynamicScaleMin) { renderScale -= 0.05; applyScale(); ema = 0; }
        else if (ema < 0.017 && renderScale < 1.0) { renderScale += 0.05; applyScale(); ema = 0; }
      }
      // stash for animate
      renderer.__applyScale = applyScale;
      renderer.__autoscale = autoscale;
      renderer.__renderScale = () => renderScale;

      // Ground
      scene.add(buildTerrain());

      // Local tank
      localTank = createTank(playerData.color, playerData.nickname);
      localTank.position.set(0, 0.6, 0);
      scene.add(localTank);

      els.healthWrap.style.display = "block";

      // Pointer lock on click
      document.body.addEventListener("click", ()=>{
        if (document.activeElement!==els.chatInput && document.pointerLockElement!==document.body) document.body.requestPointerLock?.();
      });

      // Draggable info bar
      makeDraggable(els.infoBar);

      // Inputs
      window.addEventListener("resize",()=>{
        camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.__applyScale();
      });
      window.addEventListener("keydown",onKeyDown); window.addEventListener("keyup",onKeyUp);
      window.addEventListener("mousedown",onMouseDown); document.addEventListener("mousemove",onMouseMove);

      // Net
      setupWebSocket();

      // Loop
      animate();
    }

    function makeDraggable(el){
      let drag=false, ox=0, oy=0;
      el.addEventListener("mousedown",(e)=>{drag=true; ox=e.clientX-el.offsetLeft; oy=e.clientY-el.offsetTop;});
      document.addEventListener("mousemove",(e)=>{ if(!drag) return; el.style.left=(e.clientX-ox)+"px"; el.style.top=(e.clientY-oy)+"px"; el.style.right="auto"; });
      document.addEventListener("mouseup",()=>drag=false);
    }

    function displayChatBubble(msg){
      const target = (msg.id===playerData.id) ? localTank : (remoteTanks.get(msg.id)?.mesh);
      if (!target) return;
      const can=document.createElement("canvas"); can.width=256; can.height=64;
      const ctx=can.getContext("2d"); ctx.fillStyle="rgba(0,0,0,.7)"; ctx.fillRect(0,0,256,64);
      ctx.font="20px Arial"; ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.fillText(sanitize(msg.message),128,32+7);
      const tex=new THREE.CanvasTexture(can);
      const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true}));
      spr.scale.set(4,1,1); spr.position.set(0,5,0); spr.name="chatBubble";
      const old=target.getObjectByName("chatBubble"); if(old) target.remove(old);
      target.add(spr); setTimeout(()=>{ if(target.getObjectByName("chatBubble")===spr) target.remove(spr); },3200);
    }

    /************ 11) Animate ************/
    let lastMini = 0, lastFace = 0;
    function animate(){
      requestAnimationFrame(animate);
      const dt=clock.getDelta(), now=performance.now();

      // Dynamic resolution autoscale
      renderer.__autoscale(dt);

      // Movement with turn-hold limit
      const spd = moveSpeed*dt*(controls.boost?1.6:1);
      if (controls.f) localTank.translateZ(spd);
      if (controls.b) localTank.translateZ(-spd);

      // Count hold time, stop turning after limit until key release
      if (controls.l) turnHold.l += dt; else turnHold.l = 0;
      if (controls.r) turnHold.r += dt; else turnHold.r = 0;

      if (controls.l && turnHold.l < turnHoldLimit) localTank.rotation.y += turnSpeed*dt;
      if (controls.r && turnHold.r < turnHoldLimit) localTank.rotation.y -= turnSpeed*dt;

      // yaw normalization to avoid drift
      localTank.rotation.y = THREE.MathUtils.euclideanModulo(localTank.rotation.y + Math.PI, Math.PI*2) - Math.PI;

      // Bounds + cheap grounding
      const b = world.half - 4;
      localTank.position.x = clamp(localTank.position.x, -b, b);
      localTank.position.z = clamp(localTank.position.z, -b, b);
      groundRayHeightCheap(localTank);

      // Turret smoothing (no jitter)
      const currentLocal = localTank.userData.turret.rotation.y - localTank.rotation.y;
      const nextLocal = lerpAngle(currentLocal, turretLocalTarget, 0.18);
      localTank.userData.turret.rotation.y = localTank.rotation.y + nextLocal;

      // Face labels/health less frequently
      if (now - lastFace > (1000 / PERF.labelFaceHz)) {
        lastFace = now;
        [localTank, ...Array.from(remoteTanks.values()).map(r=>r.mesh)].forEach(t=>{
          t.children.forEach(ch=>{
            if (ch.type==="Sprite") ch.lookAt(camera.position);
          });
          if (t.userData && t.userData.healthBar) t.userData.healthBar.group.lookAt(camera.position);
        });
      }

      // Camera
      updateCamera(dt);

      // Missiles & trails
      updateMissiles(dt);

      // Minimap throttled
      if (now - lastMini > (1000 / PERF.minimapHz)) { lastMini = now; updateMinimap(); }

      // Network updates
      if (ws && ws.readyState===WebSocket.OPEN){
        if (!lastSentPos) { lastSentPos = localTank.position.clone(); lastSentRot = localTank.rotation.y; }
        if (now - lastNetUpdate >= (1000/updateHz)){
          const pos=localTank.position.clone(); const dist=pos.distanceTo(lastSentPos);
          const rotDiff=Math.abs(localTank.rotation.y - lastSentRot);
          if (dist >= 0.05 || rotDiff >= 0.05){
            ws.send(JSON.stringify({type:"update", id:playerData.id, position:{x:pos.x,y:pos.y,z:pos.z}, rotation:localTank.rotation.y}));
            lastSentPos.copy(pos); lastSentRot=localTank.rotation.y; lastNetUpdate=now;
          }
        }
      }

      renderer.render(scene,camera);

      // If socket open but no pong, still show Connected (not Disconnected)
      if (ws && ws.readyState===WebSocket.OPEN){
        if (now - lastPong > 8000 && els.latency.textContent!=="Connected"){
          els.latency.textContent="Connected";
        }
      }
    }

    function updateCamera(dt){
      let target;
      if (cameraMode===1) target=new THREE.Vector3(0,5,-10).applyMatrix4(localTank.matrixWorld);
      else if (cameraMode===2) target=localTank.localToWorld(new THREE.Vector3(0,2.3,0.6));
      else target=localTank.position.clone().add(new THREE.Vector3(0,28,0));
      camera.position.lerp(target,0.1); camera.lookAt(localTank.position);
    }

    /************ 12) Start ************/
    initScene();
  </script>
</body>
</html>
